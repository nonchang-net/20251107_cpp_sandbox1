# 作業レポート - 2025/11/09 21:30

## 変更内容の概要

- C++20のconceptsとテンプレートメタプログラミングを使ったコンポーネント依存関係のコンパイル時検証手法を調査しました
- 5つのアプローチ（Concepts、型リスト、Builder Pattern、SFINAE、実用的手法）について実現可能性と実装例を検討しました
- 各手法のメリット・デメリット、実装の複雑さ、既存コードへの影響を分析しました

## 調査理由

- **型安全性の向上**: 実行時nullptrチェックではなく、コンパイル時に依存関係を検証したい
- **保守性の向上**: コメントではなく、型システムで依存関係を明示的に表現したい
- **開発効率の向上**: コンポーネント追加時の依存関係エラーを早期に発見したい

## 現在の実装の課題

### 依存関係の例

```cpp
// SpriteAnimator: SpriteRendererが必要
inline void SpriteAnimator::update(Entity* entity, Uint64 delta_time) {
  auto* sprite_renderer = entity->getComponent<SpriteRenderer>();
  if (!sprite_renderer) return;  // nullptrチェック（実行時）
  // ...
}

// DirectionalSpriteAnimator: DirectionComponent、SpriteAnimator、SpriteRendererが必要
inline void DirectionalSpriteAnimator::update(Entity* entity, Uint64 delta_time) {
  auto* direction_comp = entity->getComponent<DirectionComponent>();
  if (!direction_comp) return;  // nullptrチェック（実行時）

  auto* animator = entity->getComponent<SpriteAnimator>();
  auto* sprite_renderer = entity->getComponent<SpriteRenderer>();
  if (!animator) return;  // nullptrチェック（実行時）
  // ...
}

// VelocityMove: Locatorが必要
inline void VelocityMove::update(Entity* entity, Uint64 delta_time) {
  if (auto* locator = entity->getComponent<Locator>()) {
    // ...
  }
}
```

### 問題点

1. **実行時エラー**: 依存コンポーネントがない場合、実行時まで検出できない
2. **暗黙的な依存関係**: コメントやnullptrチェックでしか依存関係が分からない
3. **追加順序の制約なし**: addComponent()の順序に制約がないため、依存関係を無視できてしまう

---

## アプローチ1: C++20 Conceptsによる型制約

### 概要

コンポーネントクラスにrequires節を付けて依存関係を宣言し、Entity::addComponent()にconcept制約を追加する方式。

### 実装例（疑似コード）

```cpp
// 依存関係を表現するConcept
template <typename T>
concept HasDependencies = requires {
  typename T::Dependencies;  // 依存型リストを持つ
};

// 依存関係なしのコンポーネント
template <typename T>
concept NoDependencies = !HasDependencies<T>;

// コンポーネント定義に依存関係を宣言
class SpriteAnimator : public Component {
 public:
  // 依存コンポーネントを型リストで宣言
  using Dependencies = std::tuple<SpriteRenderer>;

  void update(Entity* entity, Uint64 delta_time) override {
    // ここではnullptrチェック不要（型システムが保証）
    auto* sprite_renderer = entity->getComponent<SpriteRenderer>();
    // ...
  }
};

class DirectionalSpriteAnimator : public Component {
 public:
  // 複数の依存関係を宣言
  using Dependencies = std::tuple<DirectionComponent, SpriteAnimator, SpriteRenderer>;

  void update(Entity* entity, Uint64 delta_time) override {
    // すべて存在が保証される
    auto* direction_comp = entity->getComponent<DirectionComponent>();
    auto* animator = entity->getComponent<SpriteAnimator>();
    auto* sprite_renderer = entity->getComponent<SpriteRenderer>();
    // ...
  }
};

// Entityクラスの修正
class Entity {
 public:
  // 依存関係なしのコンポーネントは無条件に追加可能
  template <NoDependencies T>
  void addComponent(std::unique_ptr<T> component) {
    components_[std::type_index(typeid(T))] = std::move(component);
  }

  // 依存関係ありのコンポーネントは検証が必要
  template <HasDependencies T>
  void addComponent(std::unique_ptr<T> component)
    requires AllDependenciesPresent<T, typename T::Dependencies>
  {
    components_[std::type_index(typeid(T))] = std::move(component);
  }

 private:
  // 依存関係がすべて存在するか検証するConcept（後述）
  template <typename Component, typename DepsType>
  concept AllDependenciesPresent = /* ... */;
};
```

### メリット

- **宣言的**: コンポーネントクラスで依存関係を明示的に宣言
- **自己文書化**: using Dependenciesで依存関係が一目瞭然
- **コンパイルエラーメッセージ**: requires節が満たされない場合、比較的分かりやすいエラー

### デメリット

- **動的な制約が困難**: std::unordered_mapで動的に管理している現状では、コンパイル時に存在を検証できない
- **部分的な検証**: addComponent()時点ではなく、実際にupdate()が呼ばれる時点まで依存コンポーネントが追加されているか保証できない
- **実装の複雑さ**: AllDependenciesPresentのような再帰的なConcept定義が必要

### 実装の複雑さ: ★★★☆☆（中程度）

現在の動的なコンポーネント管理（std::unordered_map）との相性が悪く、完全な検証には構造の大幅な変更が必要。

### 既存コードへの影響: ★★★★☆（大）

- 各コンポーネントクラスにusing Dependenciesを追加
- EntityクラスのaddComponent()を大幅に変更
- 既存のコンポーネント追加コードは互換性を維持できるが、検証が効かない

---

## アプローチ2: 型リスト + コンパイル時検証

### 概要

各コンポーネントに依存コンポーネントの型リストを定義し、テンプレートメタプログラミングでコンパイル時に検証する方式。

### 実装例（疑似コード）

```cpp
// 型リストのヘルパー
template <typename... Ts>
struct TypeList {};

// 型リストに型が含まれているか検証
template <typename T, typename List>
struct ContainsType;

template <typename T>
struct ContainsType<T, TypeList<>> : std::false_type {};

template <typename T, typename Head, typename... Tail>
struct ContainsType<T, TypeList<Head, Tail...>>
    : std::conditional_t<std::is_same_v<T, Head>, std::true_type,
                         ContainsType<T, TypeList<Tail...>>> {};

// コンポーネント定義
class SpriteAnimator : public Component {
 public:
  using Dependencies = TypeList<SpriteRenderer>;
  // ...
};

class DirectionalSpriteAnimator : public Component {
 public:
  using Dependencies = TypeList<DirectionComponent, SpriteAnimator, SpriteRenderer>;
  // ...
};

class VelocityMove : public Component {
 public:
  using Dependencies = TypeList<Locator>;
  // ...
};

// Entityクラスの検証ヘルパー
class Entity {
 public:
  // コンポーネントの依存関係をチェック
  template <typename T>
  void addComponent(std::unique_ptr<T> component) {
    // 依存関係の検証（コンパイル時）
    if constexpr (HasDependencies<T>) {
      static_assert(
          CheckDependencies<T, typename T::Dependencies>(),
          "Missing required component dependencies");
    }

    components_[std::type_index(typeid(T))] = std::move(component);
  }

 private:
  template <typename Component, typename DepsType>
  static constexpr bool CheckDependencies() {
    // 再帰的に依存関係をチェック
    // しかし、現在の型情報だけでは実行時の状態（どのコンポーネントが追加済みか）は分からない
    // → コンパイル時検証は不可能
    return true;
  }

  template <typename T>
  static constexpr bool HasDependencies = requires {
    typename T::Dependencies;
  };

  std::unordered_map<std::type_index, std::unique_ptr<Component>> components_;
};
```

### 問題点

**致命的な制約**: std::unordered_mapで動的に管理している以上、コンパイル時にどのコンポーネントが存在するか分からない。static_assertで検証しようとしても、実行時の状態は型システムで表現できない。

### メリット

- 型リストで依存関係を表現できる（文書化としては有用）

### デメリット

- **コンパイル時検証が不可能**: 動的なコンポーネント管理では、存在チェックは実行時にしかできない
- **false sense of security**: static_assertが書けても、実際には検証できない

### 実装の複雑さ: ★★☆☆☆（低）

型リスト自体は簡単だが、検証ロジックは意味がない。

### 既存コードへの影響: ★★☆☆☆（中）

- 各コンポーネントにusing Dependencies追加
- 検証が効かないので実質的な意味はない

---

## アプローチ3: Builder Pattern + Type State

### 概要

EntityBuilderで型パラメータとして追加済みコンポーネントを追跡し、必須コンポーネントが揃っていないとbuild()できないようにする方式。Rustのタイプステートパターンに類似。

### 実装例

```cpp
// 型リストの操作ヘルパー
template <typename... Ts>
struct TypeList {};

template <typename List, typename T>
struct AppendType;

template <typename... Ts, typename T>
struct AppendType<TypeList<Ts...>, T> {
  using type = TypeList<Ts..., T>;
};

template <typename T, typename List>
struct Contains;

template <typename T>
struct Contains<T, TypeList<>> : std::false_type {};

template <typename T, typename Head, typename... Tail>
struct Contains<T, TypeList<Head, Tail...>>
    : std::conditional_t<std::is_same_v<T, Head>, std::true_type,
                         Contains<T, TypeList<Tail...>>> {};

// EntityBuilderクラス
template <typename AddedComponents = TypeList<>>
class EntityBuilder {
 public:
  EntityBuilder() : entity_(std::make_unique<Entity>()) {}

  // コンポーネントを追加（型状態を更新）
  template <typename T>
  EntityBuilder<typename AppendType<AddedComponents, T>::type>
  with(std::unique_ptr<T> component) {
    entity_->addComponent(std::move(component));

    // 新しい型状態のBuilderを返す
    EntityBuilder<typename AppendType<AddedComponents, T>::type> next;
    next.entity_ = std::move(entity_);
    return next;
  }

  // 依存関係チェック付きコンポーネント追加
  template <typename T>
  auto withChecked(std::unique_ptr<T> component)
    requires AllDependenciesIn<typename T::Dependencies, AddedComponents>
  {
    return with(std::move(component));
  }

  // ビルド（いつでも可能、依存関係チェックはwithChecked()で行う）
  std::unique_ptr<Entity> build() {
    return std::move(entity_);
  }

 private:
  std::unique_ptr<Entity> entity_;

  // すべての依存関係が含まれているか検証
  template <typename Deps, typename Added>
  concept AllDependenciesIn = /* 再帰的にチェック */;
};

// 使用例
auto player = EntityBuilder<>()
    .with(std::make_unique<Locator>(100.0f, 100.0f))  // Locatorを追加
    .with(std::make_unique<SpriteRenderer>(texture, 8, 0, 1))  // SpriteRendererを追加
    .withChecked(std::make_unique<SpriteAnimator>(frames, 500))  // SpriteRendererが必要
    // ↑ Locator, SpriteRendererが追加済みなのでコンパイル成功
    .withChecked(std::make_unique<DirectionalSpriteAnimator>(
        down_frames, up_frames, right_frames))
    // ↑ DirectionComponent, SpriteAnimator, SpriteRendererが必要
    // DirectionComponentが未追加 → コンパイルエラー！
    .build();
```

### 完全な実装例

```cpp
// 依存関係の検証用Concept
template <typename Dep, typename AddedList>
struct IsInList;

template <typename Dep>
struct IsInList<Dep, TypeList<>> : std::false_type {};

template <typename Dep, typename Head, typename... Tail>
struct IsInList<Dep, TypeList<Head, Tail...>>
    : std::conditional_t<std::is_same_v<Dep, Head>, std::true_type,
                         IsInList<Dep, TypeList<Tail...>>> {};

template <typename Deps, typename AddedList>
struct AllInList;

template <typename AddedList>
struct AllInList<TypeList<>, AddedList> : std::true_type {};

template <typename DepHead, typename... DepTail, typename AddedList>
struct AllInList<TypeList<DepHead, DepTail...>, AddedList>
    : std::conditional_t<IsInList<DepHead, AddedList>::value,
                         AllInList<TypeList<DepTail...>, AddedList>,
                         std::false_type> {};

template <typename Deps, typename AddedList>
concept AllDependenciesIn = AllInList<Deps, AddedList>::value;

// EntityBuilderの完全版
template <typename AddedComponents = TypeList<>>
class EntityBuilder {
 public:
  EntityBuilder() : entity_(std::make_unique<Entity>()) {}

  // 依存関係なしで追加
  template <typename T>
  EntityBuilder<typename AppendType<AddedComponents, T>::type>
  with(std::unique_ptr<T> component) {
    entity_->addComponent(std::move(component));

    EntityBuilder<typename AppendType<AddedComponents, T>::type> next;
    next.entity_ = std::move(entity_);
    return next;
  }

  // 依存関係チェック付き追加
  template <typename T>
  EntityBuilder<typename AppendType<AddedComponents, T>::type>
  withChecked(std::unique_ptr<T> component)
    requires AllDependenciesIn<typename T::Dependencies, AddedComponents>
  {
    entity_->addComponent(std::move(component));

    EntityBuilder<typename AppendType<AddedComponents, T>::type> next;
    next.entity_ = std::move(entity_);
    return next;
  }

  std::unique_ptr<Entity> build() {
    return std::move(entity_);
  }

 private:
  template <typename, typename>
  friend class EntityBuilder;

  std::unique_ptr<Entity> entity_;
};

// 使用例（正常）
auto player = EntityBuilder<>()
    .with(std::make_unique<Locator>(100.0f, 100.0f))
    .with(std::make_unique<DirectionComponent>(Direction::Down))
    .with(std::make_unique<SpriteRenderer>(texture, 8, 0, 1))
    .withChecked(std::make_unique<SpriteAnimator>(frames, 500))
    // ↑ SpriteRendererが追加済み → OK
    .withChecked(std::make_unique<DirectionalSpriteAnimator>(
        down_frames, up_frames, right_frames))
    // ↑ DirectionComponent, SpriteAnimator, SpriteRendererすべて追加済み → OK
    .build();

// 使用例（コンパイルエラー）
auto broken_player = EntityBuilder<>()
    .with(std::make_unique<Locator>(100.0f, 100.0f))
    .withChecked(std::make_unique<SpriteAnimator>(frames, 500))
    // ↑ SpriteRendererが未追加 → コンパイルエラー！
    // error: constraints not satisfied for 'withChecked'
    .build();
```

### メリット

- **完全なコンパイル時検証**: 型状態でコンポーネントの存在を追跡できる
- **型安全**: 依存関係が満たされていないとコンパイルが通らない
- **明確なエラーメッセージ**: requires節で明示的にエラーを出せる
- **実行時オーバーヘッドなし**: すべてコンパイル時に解決

### デメリット

- **使い勝手の変更**: 既存のentity->addComponent()ではなく、Builderパターンを強制
- **型の複雑さ**: TypeList<Locator, SpriteRenderer, ...>のような長い型が出現
- **柔軟性の低下**: 動的にコンポーネントを追加/削除するケースに対応できない
- **実装コストが高い**: 型リスト操作、Conceptの定義など、多くのテンプレートメタプログラミングが必要

### 実装の複雑さ: ★★★★★（非常に高い）

型リスト操作、Concept定義、Builderパターンの実装など、高度なテンプレートメタプログラミングが必要。

### 既存コードへの影響: ★★★★★（非常に大）

- すべてのエンティティ生成をBuilderパターンに変更
- addComponent()の直接呼び出しは非推奨（型チェックが効かない）
- ゲームロジック中の動的なコンポーネント追加が困難

---

## アプローチ4: static_assert + SFINAE

### 概要

SFINAE（Substitution Failure Is Not An Error）を使って、依存関係が満たされていない場合にテンプレート置換を失敗させる方式。

### 実装例

```cpp
// SFINAEヘルパー（型が存在するか検証）
template <typename T, typename = void>
struct HasDependencies : std::false_type {};

template <typename T>
struct HasDependencies<T, std::void_t<typename T::Dependencies>>
    : std::true_type {};

// Entityクラス
class Entity {
 public:
  // 依存関係なしのコンポーネント
  template <typename T, std::enable_if_t<!HasDependencies<T>::value, int> = 0>
  void addComponent(std::unique_ptr<T> component) {
    components_[std::type_index(typeid(T))] = std::move(component);
  }

  // 依存関係ありのコンポーネント（SFINAEで選択）
  template <typename T, std::enable_if_t<HasDependencies<T>::value, int> = 0>
  void addComponent(std::unique_ptr<T> component) {
    // 警告を出す（実行時チェックしかできない）
    static_assert(
        HasDependencies<T>::value,
        "This component has dependencies. Make sure to add them first.");

    components_[std::type_index(typeid(T))] = std::move(component);
  }

 private:
  std::unordered_map<std::type_index, std::unique_ptr<Component>> components_;
};
```

### 問題点

SFINAEで関数を選択できるが、結局は実行時の状態（どのコンポーネントが追加済みか）を検証できない。static_assertで警告は出せるが、強制力はない。

### メリット

- テンプレートの分岐によって依存関係の有無を識別できる
- コンパイル時に警告を出せる

### デメリット

- **検証が不完全**: 依存関係を検証できない（警告のみ）
- **SFINAEの複雑さ**: std::enable_ifやstd::void_tを多用し、可読性が低下
- **C++20以降ならConceptsで十分**: SFINAEよりConceptsの方が明快

### 実装の複雑さ: ★★★☆☆（中程度）

SFINAEは慣れないと難しいが、検証ロジック自体は単純。

### 既存コードへの影響: ★★☆☆☆（中）

- 各コンポーネントにusing Dependenciesを追加
- addComponent()のオーバーロードを追加
- 既存コードは互換性を維持

---

## アプローチ5: 実用的なハイブリッドアプローチ

### 概要

完全なコンパイル時検証は困難なので、以下を組み合わせる実用的な方式：

1. **文書化としての型リスト**: using Dependenciesで依存関係を宣言（Conceptsでも可）
2. **実行時チェックの強化**: デバッグビルドで詳細な依存関係チェック
3. **開発支援ツール**: エンティティ構築時にコンポーネント依存関係を静的解析

### 実装例

```cpp
// コンポーネントクラスに依存関係を宣言
class SpriteAnimator : public Component {
 public:
  // 依存関係を型リストで宣言（文書化 + 静的解析で使用）
  using Dependencies = TypeList<SpriteRenderer>;

  void update(Entity* entity, Uint64 delta_time) override {
    auto* sprite_renderer = entity->getComponent<SpriteRenderer>();

    #ifdef DEBUG
    // デバッグビルドでは詳細なエラーメッセージ
    if (!sprite_renderer) {
      SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                   "SpriteAnimator requires SpriteRenderer component");
      assert(false && "Missing required component: SpriteRenderer");
    }
    #else
    // リリースビルドでは早期リターン
    if (!sprite_renderer) return;
    #endif

    // 実際の処理
    // ...
  }
};

class DirectionalSpriteAnimator : public Component {
 public:
  using Dependencies = TypeList<DirectionComponent, SpriteAnimator, SpriteRenderer>;

  void update(Entity* entity, Uint64 delta_time) override {
    #ifdef DEBUG
    // デバッグビルドで依存関係を一括チェック
    checkDependencies<DirectionComponent, SpriteAnimator, SpriteRenderer>(entity);
    #endif

    auto* direction_comp = entity->getComponent<DirectionComponent>();
    auto* animator = entity->getComponent<SpriteAnimator>();
    auto* sprite_renderer = entity->getComponent<SpriteRenderer>();

    if (!direction_comp || !animator) return;
    // ...
  }

 private:
  template <typename... Deps>
  void checkDependencies(Entity* entity) {
    ((checkSingleDependency<Deps>(entity)), ...);
  }

  template <typename T>
  void checkSingleDependency(Entity* entity) {
    if (!entity->hasComponent<T>()) {
      SDL_LogError(SDL_LOG_CATEGORY_APPLICATION,
                   "Missing required component: %s", typeid(T).name());
      assert(false);
    }
  }
};

// Entityクラスにヘルパー追加
class Entity {
 public:
  // デバッグビルド用の依存関係チェック
  #ifdef DEBUG
  template <typename T>
  void addComponent(std::unique_ptr<T> component) {
    // 依存関係チェック（実行時）
    if constexpr (HasDependencies<T>) {
      checkDependenciesFor<T>();
    }

    components_[std::type_index(typeid(T))] = std::move(component);
  }
  #else
  template <typename T>
  void addComponent(std::unique_ptr<T> component) {
    components_[std::type_index(typeid(T))] = std::move(component);
  }
  #endif

 private:
  template <typename T>
  void checkDependenciesFor() {
    // T::Dependenciesから依存コンポーネントを取得して検証
    // TypeListを展開してhasComponent()でチェック
    // 見つからない場合は警告ログ + assert
  }

  template <typename T>
  static constexpr bool HasDependencies = requires {
    typename T::Dependencies;
  };

  std::unordered_map<std::type_index, std::unique_ptr<Component>> components_;
};

// 静的解析ツールの補助（コンパイル時警告）
// 各コンポーネントのusing Dependenciesを読み取って、
// initializeEntities()などでコンポーネント追加順序を検証する外部ツール
```

### メリット

- **実用的**: コンパイル時検証は諦め、実行時に詳細なエラーを出す
- **開発効率**: デバッグビルドで依存関係の欠落を即座に検出
- **既存コードへの影響が小さい**: using Dependenciesを追加するだけ
- **段階的な導入が可能**: 既存コンポーネントに順次追加できる
- **柔軟性**: 動的なコンポーネント追加/削除に対応

### デメリット

- **コンパイル時検証ではない**: 実行して初めてエラーが分かる
- **リリースビルドでは検証しない**: パフォーマンスのため、デバッグビルドのみでチェック

### 実装の複雑さ: ★★☆☆☆（低）

using Dependenciesの宣言と、デバッグ用チェックロジックの追加のみ。

### 既存コードへの影響: ★★☆☆☆（小～中）

- 各コンポーネントにusing Dependenciesを追加
- Entityクラスにチェックロジックを追加（DEBUGビルドのみ）
- 既存のaddComponent()呼び出しは変更不要

---

## 比較表

| アプローチ | 型安全性 | 実装の複雑さ | 実行時オーバーヘッド | 既存コードへの影響 | コンパイルエラーメッセージ |
|-----------|---------|------------|-------------------|----------------|----------------------|
| 1. C++20 Concepts | △（部分的） | ★★★☆☆ | なし | ★★★★☆ | 分かりやすい |
| 2. 型リスト + メタプログラミング | × | ★★☆☆☆ | なし | ★★☆☆☆ | 意味なし |
| 3. Builder Pattern + Type State | ◎ | ★★★★★ | なし | ★★★★★ | 非常に分かりやすい |
| 4. static_assert + SFINAE | △（警告のみ） | ★★★☆☆ | なし | ★★☆☆☆ | 分かりにくい |
| 5. ハイブリッド（実用） | △（実行時） | ★★☆☆☆ | DEBUG時のみ | ★★☆☆☆ | 実行時エラー |

---

## 推奨アプローチ

### 現実的な推奨: **アプローチ5（ハイブリッド）**

**理由:**

1. **既存システムとの相性**: 現在の動的コンポーネント管理（std::unordered_map）を変更せずに導入可能
2. **段階的導入**: 既存コンポーネントに順次using Dependenciesを追加できる
3. **開発効率**: デバッグビルドで依存関係エラーを即座に発見できる
4. **実装コストが低い**: 高度なテンプレートメタプログラミング不要
5. **保守性**: using Dependenciesによる文書化で、依存関係が明確になる

### 理想的だが現実的でない: **アプローチ3（Builder Pattern + Type State）**

**理由:**

- 完全なコンパイル時検証が可能で、型安全性が最高
- しかし、実装コストと既存コードへの影響が非常に大きい
- ゲーム開発の柔軟性（動的なコンポーネント追加/削除）を失う

**適用シーン:**

- 新規プロジェクト
- コンポーネント構成が静的に決まっている場合
- 型安全性を最優先する場合

---

## 実装例: アプローチ5（ハイブリッド）の詳細

### ステップ1: 型リストの定義

```cpp
// component.h

// 型リストの定義
template <typename... Ts>
struct TypeList {};

// コンポーネントが依存関係を持つか判定
template <typename T, typename = void>
struct HasDependencies : std::false_type {};

template <typename T>
struct HasDependencies<T, std::void_t<typename T::Dependencies>>
    : std::true_type {};

template <typename T>
inline constexpr bool has_dependencies_v = HasDependencies<T>::value;
```

### ステップ2: コンポーネントに依存関係を宣言

```cpp
// component.h

class VelocityMove : public Component {
 public:
  // 依存関係を宣言
  using Dependencies = TypeList<Locator>;

  // ... 既存のコード
};

class SpriteAnimator : public Component {
 public:
  using Dependencies = TypeList<SpriteRenderer>;

  // ... 既存のコード
};

class DirectionalSpriteAnimator : public Component {
 public:
  using Dependencies = TypeList<DirectionComponent, SpriteAnimator, SpriteRenderer>;

  // ... 既存のコード
};
```

### ステップ3: Entityクラスに検証ロジックを追加

```cpp
// entity_manager.h

class Entity {
 public:
  template <typename T>
  void addComponent(std::unique_ptr<T> component) {
    #ifdef DEBUG
    // デバッグビルドでは依存関係をチェック
    if constexpr (has_dependencies_v<T>) {
      checkDependenciesFor<T>();
    }
    #endif

    components_[std::type_index(typeid(T))] = std::move(component);
  }

 private:
  // 依存関係チェックヘルパー
  template <typename T>
  void checkDependenciesFor() {
    checkDependenciesList<T, typename T::Dependencies>();
  }

  template <typename T, typename... Deps>
  void checkDependenciesList(TypeList<Deps...>) {
    ((checkSingleDependency<T, Deps>()), ...);
  }

  template <typename Component, typename Dependency>
  void checkSingleDependency() {
    if (!hasComponent<Dependency>()) {
      SDL_LogError(
          SDL_LOG_CATEGORY_APPLICATION,
          "Component '%s' requires '%s', but it's not present",
          typeid(Component).name(),
          typeid(Dependency).name());

      // assertで停止
      assert(false && "Missing required component dependency");
    }
  }

  std::unordered_map<std::type_index, std::unique_ptr<Component>> components_;
};
```

### ステップ4: update()にも検証を追加（オプション）

```cpp
// component.h

class DirectionalSpriteAnimator : public Component {
 public:
  using Dependencies = TypeList<DirectionComponent, SpriteAnimator, SpriteRenderer>;

  void update(Entity* entity, Uint64 delta_time) override {
    #ifdef DEBUG
    // デバッグビルドでは毎フレーム依存関係を検証
    validateDependencies<DirectionComponent, SpriteAnimator, SpriteRenderer>(entity);
    #endif

    auto* direction_comp = entity->getComponent<DirectionComponent>();
    if (!direction_comp) return;

    // ...（既存のコード）
  }

 private:
  template <typename... Deps>
  void validateDependencies(Entity* entity) {
    ((assert(entity->hasComponent<Deps>() && "Missing dependency")), ...);
  }
};
```

### 使用例

```cpp
// test_impl_3.h

void initializeEntities() {
  // プレイヤーキャラクター
  auto player = std::make_unique<Entity>(5);

  // 依存関係なしのコンポーネントから追加
  player->addComponent(std::make_unique<Locator>(320.0f, 240.0f));
  player->addComponent(std::make_unique<Scaler>(4.0f, 4.0f));

  // VelocityMoveはLocatorが必要 → DEBUG時にチェックされる
  player->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));

  player->addComponent(std::make_unique<DirectionComponent>(Direction::Down));
  player->addComponent(std::make_unique<SpriteRenderer>(texture_, 8, 0, 1));

  // SpriteAnimatorはSpriteRendererが必要 → DEBUG時にチェックされる
  player->addComponent(std::make_unique<SpriteAnimator>(down_frames, 500));

  // DirectionalSpriteAnimatorは3つのコンポーネントが必要 → DEBUG時にチェックされる
  player->addComponent(std::make_unique<DirectionalSpriteAnimator>(
      down_frames, up_frames, right_frames));

  entity_manager_.addEntity(std::move(player));
}

// もし依存関係を満たさない場合
void brokenExample() {
  auto broken = std::make_unique<Entity>(5);

  // Locatorを追加せずにVelocityMoveを追加
  broken->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));
  // ↑ DEBUG時にエラーログ + assert発火
  // "Component 'VelocityMove' requires 'Locator', but it's not present"
}
```

---

## まとめ

### コンパイル時検証の限界

現在の動的なコンポーネント管理（std::unordered_map）では、**完全なコンパイル時検証は不可能**です。

- 型システムはコンパイル時の静的な情報しか扱えない
- 実行時にどのコンポーネントが追加されるかは、実行してみないと分からない

### 推奨する実用的アプローチ

**アプローチ5（ハイブリッド）** を推奨します：

1. **文書化**: using Dependenciesで依存関係を宣言
2. **デバッグサポート**: DEBUGビルドで実行時チェック
3. **エラー検出**: assert + 詳細なログでエラーを即座に発見

### 将来の発展

必要に応じて以下を検討：

1. **静的解析ツール**: using Dependenciesを読み取って、コンポーネント追加順序を検証
2. **Builder Pattern**: 特定のエンティティタイプ（プレイヤー、エネミーなど）に対してBuilderを導入
3. **テンプレート特殊化**: 重要なコンポーネント組み合わせに対して専用のEntityサブクラスを定義

---

## コード例の動作確認

以下のコードは概念実証レベルの実装です。実際にコンパイルして動作確認はしていませんが、C++20の機能を正しく使えば実現可能です。

### Builder Pattern + Type Stateの完全例

```cpp
#include <memory>
#include <type_traits>
#include <SDL3/SDL.h>

// 型リストの定義
template <typename... Ts>
struct TypeList {};

template <typename List, typename T>
struct AppendType;

template <typename... Ts, typename T>
struct AppendType<TypeList<Ts...>, T> {
  using type = TypeList<Ts..., T>;
};

// 型が型リストに含まれているか
template <typename T, typename List>
struct Contains;

template <typename T>
struct Contains<T, TypeList<>> : std::false_type {};

template <typename T, typename Head, typename... Tail>
struct Contains<T, TypeList<Head, Tail...>>
    : std::conditional_t<std::is_same_v<T, Head>, std::true_type,
                         Contains<T, TypeList<Tail...>>> {};

// すべての依存関係が含まれているか
template <typename Deps, typename Added>
struct AllInList;

template <typename Added>
struct AllInList<TypeList<>, Added> : std::true_type {};

template <typename DepHead, typename... DepTail, typename Added>
struct AllInList<TypeList<DepHead, DepTail...>, Added>
    : std::conditional_t<Contains<DepHead, Added>::value,
                         AllInList<TypeList<DepTail...>, Added>,
                         std::false_type> {};

template <typename Deps, typename Added>
concept AllDependenciesIn = AllInList<Deps, Added>::value;

// EntityBuilderの定義
template <typename AddedComponents = TypeList<>>
class EntityBuilder {
 public:
  EntityBuilder() : entity_(std::make_unique<Entity>()) {}

  // コンポーネント追加（依存関係チェックなし）
  template <typename T>
  EntityBuilder<typename AppendType<AddedComponents, T>::type>
  with(std::unique_ptr<T> component) {
    entity_->addComponent(std::move(component));

    EntityBuilder<typename AppendType<AddedComponents, T>::type> next;
    next.entity_ = std::move(entity_);
    return next;
  }

  // コンポーネント追加（依存関係チェックあり）
  template <typename T>
  EntityBuilder<typename AppendType<AddedComponents, T>::type>
  withChecked(std::unique_ptr<T> component)
    requires AllDependenciesIn<typename T::Dependencies, AddedComponents>
  {
    entity_->addComponent(std::move(component));

    EntityBuilder<typename AppendType<AddedComponents, T>::type> next;
    next.entity_ = std::move(entity_);
    return next;
  }

  std::unique_ptr<Entity> build() {
    return std::move(entity_);
  }

 private:
  template <typename, typename>
  friend class EntityBuilder;

  std::unique_ptr<Entity> entity_;
};

// 使用例
void createPlayer() {
  // 正しい順序でコンポーネントを追加
  auto player = EntityBuilder<>()
      .with(std::make_unique<Locator>(100.0f, 100.0f))
      .with(std::make_unique<DirectionComponent>(Direction::Down))
      .with(std::make_unique<SpriteRenderer>(texture, 8, 0, 1))
      .withChecked(std::make_unique<SpriteAnimator>(frames, 500))
      // ↑ SpriteRendererが追加済み → コンパイル成功
      .withChecked(std::make_unique<DirectionalSpriteAnimator>(
          down_frames, up_frames, right_frames))
      // ↑ すべての依存関係が満たされている → コンパイル成功
      .build();
}

void createBrokenPlayer() {
  // 依存関係が満たされていない
  auto broken = EntityBuilder<>()
      .with(std::make_unique<Locator>(100.0f, 100.0f))
      .withChecked(std::make_unique<SpriteAnimator>(frames, 500));
      // ↑ SpriteRendererが未追加 → コンパイルエラー！
      // error: constraints not satisfied for 'withChecked<SpriteAnimator>'
      // note: the required expression 'AllDependenciesIn<TypeList<SpriteRenderer>, TypeList<Locator>>' is false
}
```

このように、**Builder Pattern + Type State** は完全なコンパイル時検証を実現できますが、既存コードへの影響が非常に大きく、実装コストも高いです。

**実用的には、アプローチ5（ハイブリッド）** で十分な依存関係検証とエラー検出が可能です。
