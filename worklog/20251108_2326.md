# 作業レポート - 2025/11/08 23:26

## 変更内容の概要

- RotateRectEntityをコンポーネントシステムで完全に代替し、rotate_rect_entity.hを削除しました
- AngularVelocityコンポーネントを作成し、角速度による回転機能を実現しました
- RotatedRectRendererコンポーネントを作成し、ピボットポイントを考慮した回転矩形の描画を実現しました

## 変更理由

- **コンポーネントシステムの実証**: RectEntityに続き、より複雑なRotateRectEntityもコンポーネントで完全に代替できることを実証しました
- **機能の分離と再利用**: 回転機能をAngularVelocity、描画機能をRotatedRectRendererとして分離し、他のエンティティでも再利用可能にしました
- **柔軟性の向上**: ピボットポイントの動的変更もDynamicPivotコンポーネントとして実装し、機能を自由に組み合わせられるようにしました

## 技術的な実装詳細

### 1. AngularVelocityコンポーネント (component.h)

```cpp
/**
 * @brief 角速度による回転を行うコンポーネント
 *
 * 毎フレーム、Rotaterコンポーネントの角度を角速度分だけ回転させます。
 * Rotaterコンポーネントが必要です。
 */
class AngularVelocity : public Component {
 public:
  explicit AngularVelocity(float angular_vel = 0.0f)
      : angular_velocity_(angular_vel) {}

  void update(Entity* entity, Uint64 delta_time) override;

  void setAngularVelocity(float angular_vel) { angular_velocity_ = angular_vel; }
  float getAngularVelocity() const { return angular_velocity_; }

 private:
  float angular_velocity_;  // 角速度（度/秒）
};
```

**実装 (entity_manager.h):**
```cpp
inline void AngularVelocity::update(Entity* entity, Uint64 delta_time) {
  // Rotaterコンポーネントを取得して角度を更新
  if (auto* rotater = entity->getComponent<Rotater>()) {
    float angle = rotater->getAngle();
    // delta_timeをミリ秒→秒に変換して角速度を適用
    angle += angular_velocity_ * (delta_time / 1000.0f);

    // 角度を0-360度に正規化
    while (angle >= 360.0f) angle -= 360.0f;
    while (angle < 0.0f) angle += 360.0f;

    rotater->setAngle(angle);
  }
}
```

**特徴:**
- Rotaterコンポーネントの角度を毎フレーム更新
- delta_timeを考慮してフレームレート非依存
- 角度を0-360度の範囲に正規化

### 2. RotatedRectRendererコンポーネント (component.h)

```cpp
/**
 * @brief 回転する矩形を描画するコンポーネント
 *
 * ピボットポイントを考慮して回転した矩形を描画します。
 * Entityのワールド座標・回転・スケールを考慮して描画されます。
 */
class RotatedRectRenderer : public Component {
 public:
  RotatedRectRenderer(float width, float height, SDL_Color color,
                      float pivot_x = 0.5f, float pivot_y = 0.5f)
      : width_(width), height_(height), color_(color),
        pivot_x_(pivot_x), pivot_y_(pivot_y) {}

  void render(Entity* entity, SDL_Renderer* renderer) override;

  void setSize(float width, float height);
  std::pair<float, float> getSize() const;

  void setColor(SDL_Color color);
  SDL_Color getColor() const;

  void setPivot(float pivot_x, float pivot_y);
  std::pair<float, float> getPivot() const;

 private:
  float width_, height_;
  SDL_Color color_;
  float pivot_x_, pivot_y_;  // 回転の原点（0.0～1.0）
};
```

**実装 (entity_manager.h):**
```cpp
inline void RotatedRectRenderer::render(Entity* entity, SDL_Renderer* renderer) {
  // Entityのワールド座標、回転角度、スケールを取得
  auto [world_x, world_y] = entity->getWorldPosition();
  float world_angle = entity->getWorldAngle();
  auto [scale_x, scale_y] = entity->getWorldScale();

  // カメラを使用してワールド座標から画面座標に変換
  float screen_x = world_x;
  float screen_y = world_y;
  if (auto* camera = entity->getRenderCamera()) {
    auto [sx, sy] = camera->worldToScreen(world_x, world_y);
    screen_x = sx;
    screen_y = sy;
  }

  // スケールを適用したサイズ
  float scaled_width = width_ * scale_x;
  float scaled_height = height_ * scale_y;

  // 角度をラジアンに変換
  float rad = world_angle * (3.14159265358979323846f / 180.0f);
  float cos_a = std::cos(rad);
  float sin_a = std::sin(rad);

  // 矩形の半分のサイズ
  float half_w = scaled_width / 2.0f;
  float half_h = scaled_height / 2.0f;

  // ピボット位置のオフセット（矩形の中心からの相対位置）
  float pivot_offset_x = (pivot_x_ - 0.5f) * scaled_width;
  float pivot_offset_y = (pivot_y_ - 0.5f) * scaled_height;

  // 回転前の4頂点（中心が原点）
  SDL_FPoint local_vertices[4] = {
      {-half_w, -half_h},  // 左上
      {half_w, -half_h},   // 右上
      {half_w, half_h},    // 右下
      {-half_w, half_h}    // 左下
  };

  // 回転した頂点を計算
  SDL_FPoint vertices[4];
  for (int i = 0; i < 4; i++) {
    // 頂点のピボットからの相対位置
    float x = local_vertices[i].x - pivot_offset_x;
    float y = local_vertices[i].y - pivot_offset_y;

    // 回転
    float rotated_x = x * cos_a - y * sin_a;
    float rotated_y = x * sin_a + y * cos_a;

    // ピボット位置に戻して画面座標に移動
    vertices[i].x = rotated_x + pivot_offset_x + screen_x;
    vertices[i].y = rotated_y + pivot_offset_y + screen_y;
  }

  // SDL_RenderGeometryで描画（塗りつぶし）
  SDL_Vertex sdl_vertices[4];
  for (int i = 0; i < 4; i++) {
    sdl_vertices[i].position = vertices[i];
    sdl_vertices[i].color = {color_.r, color_.g, color_.b, color_.a};
    sdl_vertices[i].tex_coord = {0.0f, 0.0f};
  }

  int indices[6] = {0, 1, 2, 2, 3, 0};
  SDL_RenderGeometry(renderer, nullptr, sdl_vertices, 4, indices, 6);
}
```

**特徴:**
- ワールド座標、回転角度、スケールを考慮
- カメラの座標変換を適用
- ピボットポイントを考慮した回転計算
- SDL_RenderGeometryで任意の角度に回転した矩形を描画

### 3. createRotateRectEntity()ヘルパー関数 (entity_manager.h)

```cpp
/**
 * @brief RotateRectEntityをコンポーネントで代替するヘルパー関数
 *
 * Locator + Rotater + VelocityMove + AngularVelocity + RotatedRectRendererを持つEntityを作成します。
 */
inline std::unique_ptr<Entity> createRotateRectEntity(
    int layer, float x, float y, float w, float h, SDL_Color color,
    float angle = 0.0f, float pivot_x = 0.5f, float pivot_y = 0.5f) {
  auto entity = std::make_unique<Entity>(layer);

  entity->addComponent(std::make_unique<Locator>(x, y));
  entity->addComponent(std::make_unique<Rotater>(angle));
  entity->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));
  entity->addComponent(std::make_unique<AngularVelocity>(0.0f));
  entity->addComponent(std::make_unique<RotatedRectRenderer>(w, h, color, pivot_x, pivot_y));

  return entity;
}
```

**RotateRectEntityの完全な代替:**
- Locator: 座標管理
- Rotater: 回転角度管理
- VelocityMove: 移動機能
- AngularVelocity: 角速度による回転
- RotatedRectRenderer: 回転矩形の描画（ピボット機能含む）

### 4. DynamicPivotコンポーネント (test_impl_3.h)

DynamicPivotRectEntityの機能もコンポーネント化しました：

```cpp
/**
 * @brief ピボットポイントを動的に変更するコンポーネント
 *
 * RotatedRectRendererコンポーネントのピボット位置を周期的に変更します。
 */
class DynamicPivot : public Component {
 public:
  explicit DynamicPivot(Uint64 period_ms = 2000)
      : period_(period_ms), timer_(0) {}

  void update(Entity* entity, Uint64 delta_time) override {
    auto* renderer = entity->getComponent<RotatedRectRenderer>();
    if (!renderer) return;

    // ピボットを周期的に変更（円運動させる）
    timer_ += delta_time;
    float t = timer_ / static_cast<float>(period_);
    float pivot_x = 0.5f + 0.4f * std::cos(t);
    float pivot_y = 0.5f + 0.4f * std::sin(t);
    renderer->setPivot(pivot_x, pivot_y);
  }

 private:
  Uint64 period_;
  Uint64 timer_;
};
```

### 5. test_impl_3.hでの使用例

**変更前（RotateRectEntity使用）:**
```cpp
auto rotate_rect1 = std::make_unique<Entities::RotateRectEntity>(
    3, 320, 240, 100, 100, SDL_Color{255, 200, 0, 255});
rotate_rect1->setAngularVelocity(45.0f);
rotate_rect1->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
entity_manager_.addEntity(std::move(rotate_rect1));
```

**変更後（コンポーネント使用）:**
```cpp
auto rotate_rect1 = createRotateRectEntity(
    3, 320, 240, 100, 100, SDL_Color{255, 200, 0, 255});
rotate_rect1->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
if (auto* ang_vel = rotate_rect1->getComponent<AngularVelocity>()) {
  ang_vel->setAngularVelocity(45.0f);
}
entity_manager_.addEntity(std::move(rotate_rect1));
```

**ピボットポイントのデモ（時計の針）:**
```cpp
// 左上を原点に回転（時計の針のような動き）
auto pivot_rect1 = createRotateRectEntity(
    4, 100, 100, 120, 10, SDL_Color{255, 255, 100, 255}, 0.0f, 0.0f, 0.0f);
pivot_rect1->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
if (auto* ang_vel = pivot_rect1->getComponent<AngularVelocity>()) {
  ang_vel->setAngularVelocity(30.0f);
}
entity_manager_.addEntity(std::move(pivot_rect1));
```

**動的ピボット変更（複雑な回転運動）:**
```cpp
auto dynamic_pivot = createRotateRectEntity(
    4, 320, 400, 100, 80, SDL_Color{200, 150, 255, 255});
dynamic_pivot->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
if (auto* ang_vel = dynamic_pivot->getComponent<AngularVelocity>()) {
  ang_vel->setAngularVelocity(90.0f);
}
dynamic_pivot->addComponent(std::make_unique<DynamicPivot>(2000));
entity_manager_.addEntity(std::move(dynamic_pivot));
```

### 6. 削除されたファイル

- **game_manager/entities/rotate_rect_entity.h**: コンポーネント組み合わせで完全に代替されたため削除

## コンポーネントの組み合わせ例

### 基本的な回転矩形

```cpp
auto entity = createRotateRectEntity(1, 100, 100, 50, 50, color);
if (auto* ang_vel = entity->getComponent<AngularVelocity>()) {
  ang_vel->setAngularVelocity(45.0f);  // 45度/秒で回転
}
```

### 移動しながら回転する矩形

```cpp
auto entity = createRotateRectEntity(1, 100, 100, 50, 50, color);
if (auto* ang_vel = entity->getComponent<AngularVelocity>()) {
  ang_vel->setAngularVelocity(90.0f);
}
if (auto* vel = entity->getComponent<VelocityMove>()) {
  vel->setVelocity(2.0f, 1.5f);
}
```

### カスタムピボットで回転（時計の針）

```cpp
auto entity = createRotateRectEntity(
    1, 100, 100, 120, 10, color, 0.0f, 0.0f, 0.0f);  // 左上を原点に
if (auto* ang_vel = entity->getComponent<AngularVelocity>()) {
  ang_vel->setAngularVelocity(30.0f);
}
```

### ピボットを動的に変更（複雑な回転）

```cpp
auto entity = createRotateRectEntity(1, 100, 100, 50, 50, color);
if (auto* ang_vel = entity->getComponent<AngularVelocity>()) {
  ang_vel->setAngularVelocity(90.0f);
}
entity->addComponent(std::make_unique<DynamicPivot>(2000));
```

## メリット

| 項目 | RotateRectEntity（継承） | コンポーネント |
|------|------------------------|---------------|
| 機能の追加 | 新しい派生クラスを作成 | コンポーネントを追加 |
| ピボット変更 | setPivot()メソッドを呼ぶ | DynamicPivotコンポーネントを追加 |
| 機能の組み合わせ | 複雑な継承階層 | コンポーネントの追加のみ |
| コードの再利用 | 基底クラスの機能のみ | 全コンポーネントを再利用可能 |
| 柔軟性 | 低い（継承階層が固定） | 高い（実行時に追加・削除可能） |

## コンポーネントシステムの実証

RectEntityとRotateRectEntityの両方をコンポーネントで代替できたことで、以下が実証されました：

1. **単純な描画**: RectRenderer
2. **移動機能**: VelocityMove
3. **回転機能**: Rotater + AngularVelocity
4. **回転描画**: RotatedRectRenderer（ピボット機能含む）
5. **動的な振る舞い**: DynamicPivot

これらのコンポーネントを自由に組み合わせることで、様々なエンティティを作成できます。

## ビルド結果

ビルドが正常に完了し、rotate_rect_entity.hなしで動作することを確認しました。

これにより、コンポーネントシステムが複雑な機能（回転、ピボット、動的変更）にも対応できることが実証され、今後は全てのエンティティをコンポーネント組み合わせで実装できる基盤が整いました。
