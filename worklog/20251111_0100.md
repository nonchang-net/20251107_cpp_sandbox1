# 20251111_0100 - エフェクトシステムの汎用化（任意個数のエフェクト追加・削除機能）

## 変更内容の概要

- BiquadFilterをAudioEffect基底クラスから継承するように修正し、全エフェクトが統一インターフェースを持つように整備
- SimpleSynthesizerのエフェクト管理を汎用化し、任意個数のエフェクトを動的に追加・削除できるエフェクトチェーン方式に変更
- 同じエフェクト（BiquadFilter、VolumeModulation）を設定違いで複数重ねることが可能に（例：複数のフィルターを直列接続）
- 既存の個別エフェクトメソッド（enableFilter、getFilter等）を削除し、統一的なAPI（addEffect、clearEffects）に置き換え

## 変更理由

従来のSimpleSynthesizerは、BiquadFilterとVolumeModulationをそれぞれ個別のメンバー変数（`filter_`、`volume_mod_`）として保持していたため、各エフェクトは1つずつしか使えず、拡張性に欠けていた。今回、エフェクトチェーン方式（`std::vector<std::unique_ptr<AudioEffect>>`）を採用することで、任意個数のエフェクトを自由に組み合わせられるようになり、より柔軟なサウンド設計が可能になった。また、エフェクト設定変更時は「全削除→再追加」というシンプルなフローで扱えるため、実装もわかりやすくなった。

## 修正したファイル

### 1. sound/effect/biquad_filter.h

**変更内容**: BiquadFilterをAudioEffectから継承

```cpp
#include "audio_effect.h"

// 変更前
class BiquadFilter {

// 変更後
class BiquadFilter : public AudioEffect {
 public:
  // process()とreset()にoverride指定を追加
  float process(float input) override;
  void reset() override;
```

**設計のポイント**:
- AudioEffectを継承することで、BiquadFilterもエフェクトチェーンに追加可能に
- `process()`と`reset()`が既に実装されていたため、`override`キーワードを追加するだけで対応完了

### 2. sound/core/synthesizer.h

**変更内容**: エフェクト管理の汎用化

```cpp
// インクルードの変更
#include <vector>
#include "../effect/audio_effect.h"
// 削除: #include "../effect/biquad_filter.h"
// 削除: #include "../effect/volume_modulation.h"

// 削除: 前方宣言（BiquadFilter、VolumeModulation）

// メンバー変数の変更
// 削除:
// std::unique_ptr<BiquadFilter> filter_;
// std::unique_ptr<VolumeModulation> volume_mod_;

// 追加:
std::vector<std::unique_ptr<AudioEffect>> effects_;  // エフェクトチェーン
```

**新しいメソッド**:

```cpp
/**
 * @brief エフェクトを追加
 *
 * エフェクトをエフェクトチェーンの末尾に追加します。
 * エフェクトの所有権はシンセサイザーに移動します。
 * 追加したエフェクトは追加順に直列に処理されます。
 */
void addEffect(std::unique_ptr<AudioEffect> effect);

/**
 * @brief 全てのエフェクトを削除
 *
 * エフェクトチェーンから全てのエフェクトを削除します。
 * エフェクトを変更する際は、一度clearEffects()で全削除してから
 * 改めてaddEffect()で追加し直すことを推奨します。
 */
void clearEffects();

/**
 * @brief エフェクト数を取得
 * @return 現在設定されているエフェクトの数
 */
size_t getEffectCount() const;
```

**削除したメソッド**:
- `enableFilter()` / `disableFilter()` / `isFilterEnabled()` / `getFilter()`
- `enableVolumeModulation()` / `disableVolumeModulation()` / `isVolumeModulationEnabled()` / `getVolumeModulation()`

### 3. sound/core/synthesizer.cc

**変更内容**:

**コンストラクタ**:
```cpp
// 変更前
SimpleSynthesizer::SimpleSynthesizer(int sample_rate)
    : oscillator_(...),
      envelope_(...),
      filter_(nullptr),      // 削除
      volume_mod_(nullptr),  // 削除
      stream_(nullptr),

// 変更後
SimpleSynthesizer::SimpleSynthesizer(int sample_rate)
    : oscillator_(...),
      envelope_(...),
      effects_(),            // エフェクトチェーンは空で初期化
      stream_(nullptr),
```

**新しいメソッドの実装**:
```cpp
void SimpleSynthesizer::addEffect(std::unique_ptr<AudioEffect> effect) {
  if (effect) {
    effects_.push_back(std::move(effect));
    SYNTH_LOG("Effect added to chain (total: %zu effects)", effects_.size());
  }
}

void SimpleSynthesizer::clearEffects() {
  effects_.clear();
  SYNTH_LOG("All effects cleared");
}

size_t SimpleSynthesizer::getEffectCount() const {
  return effects_.size();
}
```

**generateSamples()の変更**:
```cpp
// 変更前
samples[i] = wave * envelope_value * note_volume_ * master_volume_;

// フィルター適用（有効な場合のみ）
if (filter_) {
  samples[i] = filter_->process(samples[i]);
}

// ボリュームモジュレーション適用（有効な場合のみ）
if (volume_mod_) {
  samples[i] = volume_mod_->process(samples[i]);
}

// 変更後
samples[i] = wave * envelope_value * note_volume_ * master_volume_;

// エフェクトチェーンを適用（追加順に処理）
for (auto& effect : effects_) {
  samples[i] = effect->process(samples[i]);
}
```

**処理の流れ**:
1. 波形生成
2. エンベロープ × ボリューム適用
3. **エフェクトチェーンを順番に適用** ← 変更点
4. クリッピング防止

### 4. game/test_impl_3.h

**変更内容**: テストコードを新しいAPIに対応

**キー8のハンドラー（ノイズ＋フィルターテスト1）**:
```cpp
// 変更前
synthesizer_->enableFilter();
auto* filter = synthesizer_->getFilter();
filter->setType(BiquadFilterType::Lowpass);
filter->setFrequency(2000.0f);
filter->setQ(0.7f);

// 変更後
synthesizer_->clearEffects();  // 既存エフェクトをクリア

auto filter = std::make_unique<BiquadFilter>(synthesizer_->getSampleRate());
filter->setType(BiquadFilterType::Lowpass);
filter->setFrequency(2000.0f);
filter->setQ(0.7f);
synthesizer_->addEffect(std::move(filter));
```

**キー9のハンドラー（複数エフェクトの組み合わせ）**:
```cpp
// 変更前
synthesizer_->enableFilter();
synthesizer_->enableVolumeModulation();
auto* filter = synthesizer_->getFilter();
filter->setType(BiquadFilterType::Highpass);
filter->setFrequency(5000.0f);
filter->setQ(1.5f);
auto* volume_mod = synthesizer_->getVolumeModulation();
volume_mod->setWaveType(WaveType::Square);

// 変更後
synthesizer_->clearEffects();  // 既存エフェクトをクリア

// フィルターを追加
auto filter = std::make_unique<BiquadFilter>(synthesizer_->getSampleRate());
filter->setType(BiquadFilterType::Highpass);
filter->setFrequency(5000.0f);
filter->setQ(1.5f);
synthesizer_->addEffect(std::move(filter));

// ボリュームモジュレーションを追加
auto volume_mod = std::make_unique<VolumeModulation>(synthesizer_->getSampleRate());
volume_mod->setWaveType(WaveType::Square);
synthesizer_->addEffect(std::move(volume_mod));
```

## 使用例

### 基本的な使い方

```cpp
// 1. エフェクトを追加（フィルター）
auto filter = std::make_unique<BiquadFilter>(44100);
filter->setType(BiquadFilterType::Lowpass);
filter->setFrequency(1000.0f);
filter->setQ(1.0f);
synth->addEffect(std::move(filter));

// 2. エフェクトを追加（トレモロ）
auto tremolo = std::make_unique<VolumeModulation>(44100);
tremolo->setRate(5.0f);
tremolo->setDepth(0.5f);
synth->addEffect(std::move(tremolo));

// 処理順序: 波形 → エンベロープ×ボリューム → フィルター → トレモロ → クリッピング防止
```

### 複数の同じエフェクトを重ねる例

```cpp
// 複数のフィルターを直列接続（カスケード接続）
synth->clearEffects();

// 1段目: Lowpass 2kHz
auto filter1 = std::make_unique<BiquadFilter>(44100);
filter1->setType(BiquadFilterType::Lowpass);
filter1->setFrequency(2000.0f);
synth->addEffect(std::move(filter1));

// 2段目: Lowpass 1kHz（さらに急峻な特性になる）
auto filter2 = std::make_unique<BiquadFilter>(44100);
filter2->setType(BiquadFilterType::Lowpass);
filter2->setFrequency(1000.0f);
synth->addEffect(std::move(filter2));

// 3段目: Peaking（特定周波数を強調）
auto filter3 = std::make_unique<BiquadFilter>(44100);
filter3->setType(BiquadFilterType::Peaking);
filter3->setFrequency(500.0f);
filter3->setQ(5.0f);
filter3->setGain(12.0f);  // +12dB
synth->addEffect(std::move(filter3));
```

### エフェクト設定の変更フロー

```cpp
// エフェクトを変更する場合は、一度全削除してから再追加
synth->clearEffects();

// 新しい設定を追加
auto filter = std::make_unique<BiquadFilter>(44100);
filter->setType(BiquadFilterType::Highpass);
filter->setFrequency(5000.0f);
synth->addEffect(std::move(filter));
```

## API設計の特徴

### 所有権の移動

エフェクトの所有権はシンセサイザーに移動します。これにより：
- **シンプル**: 複数箇所でエフェクトインスタンスを管理する必要がない
- **安全**: エフェクトの寿命がシンセサイザーのライフサイクルに紐付く
- **明確**: 使い回しを考慮しなくて良いため、実装がわかりやすい

```cpp
auto filter = std::make_unique<BiquadFilter>(44100);
filter->setFrequency(1000.0f);
synth->addEffect(std::move(filter));  // 所有権を移動
// この後、filterは使用不可（nullptr）
```

### エフェクト変更時のベストプラクティス

推奨されるフロー:
1. `clearEffects()` - 全エフェクトを削除
2. 新しいエフェクトを作成・設定
3. `addEffect()` - 追加

これにより、エフェクト設定の状態管理が明確になります。

## 拡張性と今後の可能性

### Phase 1（今回の実装）: 基本的なエフェクトチェーン
- ✅ 任意個数のエフェクトを追加・削除
- ✅ 同じエフェクトを複数重ねることが可能
- ✅ 統一的なAPI（addEffect、clearEffects）

### Phase 2（将来の拡張可能性）:
- **エフェクトスロット**: 特定位置のエフェクトを入れ替え
  ```cpp
  synth->replaceEffect(index, new_effect);
  synth->removeEffect(index);
  synth->insertEffect(index, effect);
  ```

- **エフェクトのバイパス**: エフェクトを削除せずに一時的に無効化
  ```cpp
  class AudioEffect {
    bool enabled_ = true;
    virtual float process(float input) {
      return enabled_ ? processInternal(input) : input;
    }
  };
  ```

- **エフェクトチェーンの保存・復元**: プリセット機能
  ```cpp
  synth->saveEffectChain("preset1");
  synth->loadEffectChain("preset1");
  ```

- **パラレルエフェクトチェーン**: 直列ではなく並列でエフェクトを処理
  ```cpp
  // ドライ音とウェット音をミックス
  float dry = input;
  float wet = effect->process(input);
  return dry * (1.0f - mix) + wet * mix;
  ```

## パフォーマンスへの影響

### メモリ使用量
- 変更前: 固定2個のエフェクト用ポインタ（16バイト）
- 変更後: `std::vector`（24バイト + エフェクト数 × 8バイト）
- 影響: ほぼ無視できるレベル

### 処理コスト
- 変更前: `if (filter_)` と `if (volume_mod_)` の2回の分岐チェック
- 変更後: `for (auto& effect : effects_)` のループ処理
- 影響: エフェクト数が0の場合は分岐なし（ループがスキップされる）、エフェクト数が増えても線形的な増加のみ

### 結論
パフォーマンスへの影響は非常に小さく、柔軟性の向上のメリットが大きい。

## ビルド結果

```bash
cmake --build build
```

**結果**: ✅ ビルド成功（エラーなし）

## テスト方法

1. ビルド実行: `cmake --build build`
2. アプリケーション起動: `./build/main`
3. キー8を押す: ノイズ + Lowpassフィルター（2kHz）
4. キー9を押す: ノイズ + Highpassフィルター（5kHz）+ トレモロ（Square波）

## まとめ

SimpleSynthesizerのエフェクト管理を汎用化し、任意個数のエフェクトを動的に追加・削除できるようになった。これにより、同じエフェクトを設定違いで複数重ねることが可能になり、より柔軟なサウンドデザインが実現できるようになった。また、統一的なAPI（addEffect、clearEffects）により、実装もシンプルでわかりやすくなった。
