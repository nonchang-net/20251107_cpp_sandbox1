# 作業レポート - 2025/11/08 22:25

## 変更内容の概要

- Entity Component System (ECS) パターンを導入し、Entityの機能をコンポーネント化しました
- Locator（座標）、Rotater（回転）、Scaler（スケール）、RectRenderer（矩形描画）の基本コンポーネントを作成しました
- Camera2Dクラスを追加し、EntityManagerがカメラを保持するようにしました

## 変更理由

- **機能の分離と組み合わせ**: コンポーネントシステムにより、座標・回転・スケール・描画などの機能を個別に管理し、自由に組み合わせられるようになります
- **柔軟性の向上**: 座標を持たないEntity、回転しないEntity、描画しないEntityなど、必要な機能のみを持つEntityを簡単に作成できます
- **拡張性**: 新しい機能（例: 物理演算、当たり判定、アニメーション）をコンポーネントとして追加できます
- **カメラシステム**: ゲーム全体の視点を管理する Camera2D を導入し、画面のスクロール・回転・ズームを実現する土台を作りました

## 技術的な実装詳細

### 1. Component基底クラス (game_manager/component.h)

```cpp
class Component {
 public:
  virtual ~Component() = default;

  // コンポーネントの更新処理
  virtual void update(Entity* entity, Uint64 delta_time) {}

  // コンポーネントの描画処理
  virtual void render(Entity* entity, SDL_Renderer* renderer) {}
};
```

すべてのコンポーネントの基底クラスです。Entityへのポインタを受け取り、そのEntityの状態を読み書きできます。

### 2. 基本コンポーネント

**Locator - 2D座標:**
```cpp
class Locator : public Component {
  float x_, y_;  // ローカル座標

 public:
  Locator(float x = 0.0f, float y = 0.0f);
  void setPosition(float x, float y);
  std::pair<float, float> getPosition() const;
};
```

**Rotater - 2D回転:**
```cpp
class Rotater : public Component {
  float angle_;  // 回転角度（度数法）

 public:
  explicit Rotater(float angle = 0.0f);
  void setAngle(float angle);
  float getAngle() const;
};
```

**Scaler - 2Dスケール:**
```cpp
class Scaler : public Component {
  float scale_x_, scale_y_;

 public:
  Scaler(float scale_x = 1.0f, float scale_y = 1.0f);
  void setScale(float scale_x, float scale_y);
  std::pair<float, float> getScale() const;
};
```

**RectRenderer - 矩形描画:**
```cpp
class RectRenderer : public Component {
  float width_, height_;
  SDL_Color color_;

 public:
  RectRenderer(float width, float height, SDL_Color color);
  void render(Entity* entity, SDL_Renderer* renderer) override;
  // サイズと色のgetter/setter
};
```

### 3. Entityのコンポーネント管理

**コンポーネントの保存:**
```cpp
class Entity {
  std::unordered_map<std::type_index, std::unique_ptr<Component>> components_;

  // コンポーネントの追加
  template <typename T>
  void addComponent(std::unique_ptr<T> component) {
    components_[std::type_index(typeid(T))] = std::move(component);
  }

  // コンポーネントの取得
  template <typename T>
  T* getComponent() {
    auto it = components_.find(std::type_index(typeid(T)));
    if (it != components_.end()) {
      return static_cast<T*>(it->second.get());
    }
    return nullptr;
  }

  // コンポーネントの存在確認
  template <typename T>
  bool hasComponent() const;

  // コンポーネントの削除
  template <typename T>
  void removeComponent();
};
```

**使用例:**
```cpp
auto entity = std::make_unique<Entity>(1);  // レイヤー1

// 座標コンポーネントを追加
entity->addComponent(std::make_unique<Locator>(100, 200));

// 回転コンポーネントを追加
entity->addComponent(std::make_unique<Rotater>(45.0f));

// スケールコンポーネントを追加
entity->addComponent(std::make_unique<Scaler>(2.0f, 2.0f));

// 矩形描画コンポーネントを追加
entity->addComponent(std::make_unique<RectRenderer>(
    50, 50, SDL_Color{255, 100, 100, 255}));

// コンポーネントへのアクセス
if (auto* locator = entity->getComponent<Locator>()) {
  locator->setPosition(150, 250);
}
```

### 4. ワールド座標計算の変更

**従来:**
```cpp
class Entity {
  float local_x_, local_y_, local_angle_;  // 直接保持
};
```

**変更後:**
```cpp
class Entity {
  // コンポーネントから取得
  std::pair<float, float> getLocalPosition() const {
    if (const auto* locator = getComponent<Locator>()) {
      return locator->getPosition();
    }
    return {0.0f, 0.0f};  // Locatorがない場合は(0, 0)
  }

  float getLocalAngle() const {
    if (const auto* rotater = getComponent<Rotater>()) {
      return rotater->getAngle();
    }
    return 0.0f;  // Rotaterがない場合は0
  }

  std::pair<float, float> getLocalScale() const {
    if (const auto* scaler = getComponent<Scaler>()) {
      return scaler->getScale();
    }
    return {1.0f, 1.0f};  // Scalerがない場合は(1, 1)
  }
};
```

**ワールド座標の計算にスケールを追加:**
```cpp
std::pair<float, float> getWorldPosition() const {
  auto [local_x, local_y] = getLocalPosition();

  if (!parent_) {
    return {local_x, local_y};
  }

  auto [parent_x, parent_y] = parent_->getWorldPosition();
  float parent_angle = parent_->getWorldAngle();
  auto [parent_scale_x, parent_scale_y] = parent_->getWorldScale();

  // 親のスケールを適用
  float scaled_x = local_x * parent_scale_x;
  float scaled_y = local_y * parent_scale_y;

  // 親の回転を考慮
  float rad = parent_angle * (M_PI / 180.0f);
  float rotated_x = scaled_x * cos(rad) - scaled_y * sin(rad);
  float rotated_y = scaled_x * sin(rad) + scaled_y * cos(rad);

  return {parent_x + rotated_x, parent_y + rotated_y};
}
```

### 5. コンポーネントの更新と描画

**updateWithChildren():**
```cpp
void updateWithChildren(Uint64 delta_time) {
  if (active_) {
    // 従来のupdate()（後方互換性）
    update(delta_time);

    // 全コンポーネントのupdate()を呼ぶ
    for (auto& [type, component] : components_) {
      component->update(this, delta_time);
    }

    // 子エンティティも更新
    for (auto& child : children_) {
      child->updateWithChildren(delta_time);
    }
  }
}
```

**renderWithChildren():**
```cpp
void renderWithChildren(SDL_Renderer* renderer, size_t visible_flag_index = 0) {
  if (active_ && getStateFlag(visible_flag_index)) {
    // 従来のrender()（後方互換性）
    render(renderer);

    // 全コンポーネントのrender()を呼ぶ
    for (auto& [type, component] : components_) {
      component->render(this, renderer);
    }
  }

  // 子エンティティも描画
  for (auto& child : children_) {
    child->renderWithChildren(renderer, visible_flag_index);
  }
}
```

### 6. RootEntityの変更

```cpp
class RootEntity : public Entity {
 public:
  RootEntity() : Entity(0) {
    // rootはコンポーネントを持たない
    // 座標は常に(0, 0)
    setStateFlag(0, 1);
  }

  // rootは常に(0, 0), 回転0, スケール(1, 1)を返す
  std::pair<float, float> getWorldPosition() const override {
    return {0.0f, 0.0f};
  }
  float getWorldAngle() const override {
    return 0.0f;
  }
  std::pair<float, float> getWorldScale() const override {
    return {1.0f, 1.0f};
  }
};
```

rootはコンポーネントを一切持たず、ワールド座標系の原点として機能します。

### 7. Camera2Dクラス

```cpp
class Camera2D {
 public:
  Camera2D() : center_x_(0.0f), center_y_(0.0f), rotation_(0.0f), zoom_(1.0f) {}

  // カメラの中心座標
  void setCenter(float x, float y);
  std::pair<float, float> getCenter() const;

  // カメラの回転角度
  void setRotation(float angle);
  float getRotation() const;

  // カメラのズーム倍率
  void setZoom(float zoom);
  float getZoom() const;

 private:
  float center_x_, center_y_;  // カメラの中心座標
  float rotation_;             // カメラの回転角度
  float zoom_;                 // ズーム倍率
};
```

**EntityManagerでの使用:**
```cpp
class EntityManager {
  std::unique_ptr<RootEntity> root_;
  std::unique_ptr<Camera2D> camera_;

 public:
  Camera2D* getCamera() { return camera_.get(); }
};
```

**使用例:**
```cpp
// カメラをEntityに追従させる
auto camera = entity_manager.getCamera();
auto [player_x, player_y] = player_entity->getWorldPosition();
camera->setCenter(player_x, player_y);

// ズームイン
camera->setZoom(2.0f);  // 2倍に拡大

// カメラを回転
camera->setRotation(45.0f);  // 45度回転
```

## ファイル構成

### 新規作成

- **game_manager/component.h**: コンポーネントシステムの定義
  - Component基底クラス
  - Locator, Rotater, Scaler
  - RectRenderer

### 大幅な変更

- **game_manager/entity_manager.h**:
  - Entityにコンポーネント管理機能を追加
  - local_x_, local_y_, local_angle_を削除（コンポーネント化）
  - getWorldScale()を追加
  - Camera2Dクラスを追加
  - RectRenderer::render()の実装を追加（inline）

## メリット

| 項目 | 変更前 | 変更後 |
|------|--------|--------|
| 座標管理 | Entity内に直接保持 | Locatorコンポーネント（オプション） |
| 回転管理 | Entity内に直接保持 | Rotaterコンポーネント（オプション） |
| スケール | なし | Scalerコンポーネントで実現 |
| 描画 | 派生クラスで実装 | コンポーネントで実現可能 |
| 機能の組み合わせ | 継承ベース | コンポーネントの追加/削除 |
| カメラ | なし | Camera2Dで視点管理が可能 |

## ECSパターンの利点

1. **構成による設計 (Composition over Inheritance)**:
   - 継承の代わりにコンポーネントを組み合わせる
   - 深い継承階層を避けられる

2. **柔軟な機能の追加・削除**:
   - 実行時にコンポーネントを追加/削除可能
   - 必要な機能のみを持つEntityを作成

3. **コードの再利用**:
   - コンポーネントは独立しているため、異なるEntityで再利用可能

4. **明確な責務の分離**:
   - 座標管理 → Locator
   - 回転管理 → Rotater
   - 描画処理 → RectRenderer

## 後方互換性

- 既存のEntity派生クラス（RectEntity, RotateRectEntity, TextEntity）は引き続き動作
- setLocalPosition(), getLocalPosition()などのメソッドは内部的にコンポーネントを使用
- update()とrender()の仮想関数は維持（コンポーネントと併用可能）

## 今後の展開

このコンポーネントシステムにより、以下のような機能を追加できます：

1. **物理演算コンポーネント**: 速度、加速度、重力
2. **当たり判定コンポーネント**: AABB、円、ポリゴン
3. **アニメーションコンポーネント**: スプライトアニメーション
4. **サウンドコンポーネント**: 音声再生
5. **パーティクルコンポーネント**: パーティクル効果
6. **AI コンポーネント**: 敵の行動パターン

また、Camera2Dを活用することで：
- プレイヤー追従カメラ
- 画面の揺れ（シェイク）エフェクト
- ズームイン・ズームアウト
- カメラの回転演出

が実現できます。

これにより、game_managerライブラリの設計がより柔軟で拡張性の高いものになりました。
