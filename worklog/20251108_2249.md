# 作業レポート - 2025/11/08 22:49

## 変更内容の概要

- VelocityMoveコンポーネントを作成し、速度による移動機能を実現しました
- RectEntityをコンポーネント組み合わせ（Locator + VelocityMove + RectRenderer）で完全に代替しました
- rect_entity.hを削除し、createRectEntity()ヘルパー関数で置き換えました

## 変更理由

- **コンポーネントシステムの実証**: 既存のRectEntityをコンポーネントで完全に代替できることを実証し、コンポーネントシステムの有効性を確認しました
- **機能の分離**: 移動機能をVelocityMoveコンポーネントとして独立させることで、他のエンティティでも再利用可能にしました
- **コードの簡潔化**: 継承ベースの実装からコンポーネント組み合わせに移行し、より柔軟で保守しやすいコードにしました

## 技術的な実装詳細

### 1. VelocityMoveコンポーネント (game_manager/component.h)

```cpp
class VelocityMove : public Component {
 public:
  VelocityMove(float vx = 0.0f, float vy = 0.0f)
      : velocity_x_(vx), velocity_y_(vy) {}

  void update(Entity* entity, Uint64 delta_time) override {
    // Locatorコンポーネントを取得して座標を更新
    if (auto* locator = entity->getComponent<Locator>()) {
      auto [x, y] = locator->getPosition();
      locator->setPosition(x + velocity_x_, y + velocity_y_);
    }
  }

  void setVelocity(float vx, float vy);
  std::pair<float, float> getVelocity() const;

 private:
  float velocity_x_, velocity_y_;
};
```

**特徴:**
- 毎フレーム、Locatorコンポーネントの座標を速度分だけ移動
- Locatorコンポーネントが必要（依存関係が明確）
- 速度の設定・取得が可能

### 2. createRectEntity() ヘルパー関数 (game_manager/entity_manager.h)

```cpp
inline std::unique_ptr<Entity> createRectEntity(
    int layer, float x, float y, float w, float h, SDL_Color color) {
  auto entity = std::make_unique<Entity>(layer);

  // 座標コンポーネント
  entity->addComponent(std::make_unique<Locator>(x, y));

  // 移動コンポーネント
  entity->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));

  // 描画コンポーネント
  entity->addComponent(std::make_unique<RectRenderer>(w, h, color));

  return entity;
}
```

**RectEntityの完全な代替:**
- Locator: 座標管理
- VelocityMove: 移動機能
- RectRenderer: 矩形描画

**使用例:**
```cpp
auto rect = createRectEntity(1, 100, 100, 50, 50, SDL_Color{255, 100, 100, 255});

// 速度を設定
if (auto* vel = rect->getComponent<VelocityMove>()) {
  vel->setVelocity(2.0f, 1.5f);
}

entity_manager.addEntity(std::move(rect));
```

### 3. test_impl_3.h の新しいコンポーネント

**BounceOnEdge - 画面端で跳ね返る:**
```cpp
class BounceOnEdge : public Component {
 public:
  void update(Entity* entity, Uint64 delta_time) override {
    auto* locator = entity->getComponent<Locator>();
    auto* velocity = entity->getComponent<VelocityMove>();
    auto* renderer = entity->getComponent<RectRenderer>();

    if (!locator || !velocity || !renderer) return;

    auto [x, y] = locator->getPosition();
    auto [w, h] = renderer->getSize();
    auto [vx, vy] = velocity->getVelocity();

    // 画面端で速度を反転
    if (x < 0 || x + w > 640) vx = -vx;
    if (y < 0 || y + h > 480) vy = -vy;

    velocity->setVelocity(vx, vy);
  }
};
```

**Blink - 点滅:**
```cpp
class Blink : public Component {
 public:
  explicit Blink(Uint64 interval_ms = 500);

  void update(Entity* entity, Uint64 delta_time) override {
    if (entity->getStateFlag(toIndex(TestImpl3StateFlag::Blinking))) {
      timer_ += delta_time;
      if (timer_ > interval_) {
        // 表示フラグを反転
        size_t visible_idx = toIndex(TestImpl3StateFlag::Visible);
        entity->setStateFlag(visible_idx, !entity->getStateFlag(visible_idx));
        timer_ = 0;
      }
    }
  }

 private:
  Uint64 interval_, timer_;
};
```

### 4. Entityの変更

**純粋仮想関数から通常の仮想関数に変更:**
```cpp
class Entity {
  // 変更前: 純粋仮想関数
  // virtual void update(Uint64 delta_time) = 0;
  // virtual void render(SDL_Renderer* renderer) = 0;

  // 変更後: デフォルト実装を持つ仮想関数
  virtual void update(Uint64 delta_time) {}
  virtual void render(SDL_Renderer* renderer) {}
};
```

**理由:**
- コンポーネントのみで動作するEntityを作成可能にするため
- createRectEntity()でEntityを直接インスタンス化できるようにするため

### 5. test_impl_3.h の修正

**変更前（RectEntity使用）:**
```cpp
auto rect = std::make_unique<RectEntity>(1, 100, 100, 50, 50, color);
rect->setVelocity(2.0f, 1.5f);
```

**変更後（コンポーネント使用）:**
```cpp
auto rect = createRectEntity(1, 100, 100, 50, 50, color);
rect->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);

if (auto* vel = rect->getComponent<VelocityMove>()) {
  vel->setVelocity(2.0f, 1.5f);
}

// 跳ね返り機能を追加
rect->addComponent(std::make_unique<BounceOnEdge>());
```

**点滅する矩形:**
```cpp
auto blink_rect = createRectEntity(2, 250, 150, 80, 80, color);
blink_rect->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
blink_rect->setStateFlag(toIndex(TestImpl3StateFlag::Blinking), 1);
blink_rect->addComponent(std::make_unique<Blink>(500));  // 500ms周期
```

### 6. 削除されたファイル

- **game_manager/entities/rect_entity.h**: コンポーネント組み合わせで完全に代替されたため削除

## コンポーネントの組み合わせ例

### 基本的な静止矩形

```cpp
auto entity = std::make_unique<Entity>(0);
entity->addComponent(std::make_unique<Locator>(100, 100));
entity->addComponent(std::make_unique<RectRenderer>(50, 50, color));
// VelocityMoveなし = 移動しない
```

### 動く矩形

```cpp
auto entity = createRectEntity(1, 100, 100, 50, 50, color);
if (auto* vel = entity->getComponent<VelocityMove>()) {
  vel->setVelocity(2.0f, 1.5f);
}
```

### 跳ね返る矩形

```cpp
auto entity = createRectEntity(1, 100, 100, 50, 50, color);
entity->getComponent<VelocityMove>()->setVelocity(2.0f, 1.5f);
entity->addComponent(std::make_unique<BounceOnEdge>());
```

### 点滅する矩形

```cpp
auto entity = createRectEntity(2, 250, 150, 80, 80, color);
entity->setStateFlag(toIndex(TestImpl3StateFlag::Blinking), 1);
entity->addComponent(std::make_unique<Blink>(500));
```

### 跳ね返って点滅する矩形

```cpp
auto entity = createRectEntity(1, 100, 100, 50, 50, color);
entity->setStateFlag(toIndex(TestImpl3StateFlag::Blinking), 1);
entity->getComponent<VelocityMove>()->setVelocity(2.0f, 1.5f);
entity->addComponent(std::make_unique<BounceOnEdge>());
entity->addComponent(std::make_unique<Blink>(500));
```

## メリット

| 項目 | RectEntity（継承） | コンポーネント |
|------|-------------------|----------------|
| 機能の追加 | 新しい派生クラスを作成 | コンポーネントを追加 |
| 機能の組み合わせ | 多重継承や複雑な階層 | コンポーネントの追加のみ |
| コードの再利用 | 基底クラスの機能のみ | 全コンポーネントを再利用可能 |
| 柔軟性 | 低い（継承階層が固定） | 高い（実行時に追加・削除可能） |
| 保守性 | 階層が深くなると困難 | 個別コンポーネントで管理しやすい |

## コンポーネントシステムの利点の実証

1. **機能の独立性**: VelocityMove, BounceOnEdge, Blinkはそれぞれ独立したコンポーネント
2. **再利用性**: これらのコンポーネントは任意のEntityで使用可能
3. **組み合わせの自由**: 必要な機能のみを組み合わせられる
4. **実行時の変更**: addComponent()で動的に機能を追加可能

## ビルド結果

ビルドが正常に完了し、rect_entity.hなしで動作することを確認しました。

これにより、コンポーネントシステムが実用的であることが実証され、今後は全てのエンティティをコンポーネント組み合わせで実装できる基盤が整いました。
