# 20251110_1820 - マルチトラックシーケンサーとBGMマネージャーの実装

## 変更内容の概要

- MultiTrackSequencerクラスを実装: 1曲を複数トラック（パート）で管理する機能
- BGMManagerクラスを実装: 複数のBGMを登録してID指定で切り替える機能
- test_impl_3.hにBGMManagerのテストケースを追加（F1-F3でBGM切り替え、F5-F7で停止・一時停止・再開）
- 3つのBGMプリセットを追加（2トラックBGM × 2、3トラックBGM × 1）

## 変更理由

サウンドシステムが充実してきたため、BGM実装において複数のパートを同時に演奏する機能が必要になった。また、ゲーム内でBGMを切り替える仕組みも必要なため、MultiTrackSequencerとBGMManagerという2層のアーキテクチャを実装した。これにより、楽曲全体の管理と複数BGMの管理を分離できる。

## 変更箇所

### game_manager/sound_synthesizer.h

#### 1. MultiTrackSequencerクラスの実装

**概要**:
1つの楽曲を複数トラック（パート）で管理するクラス。初期化時に指定したトラック数分のシンセサイザーとシーケンサーのペアを内部で保持する。

**コンストラクタ**:
```cpp
explicit MultiTrackSequencer(size_t track_count, int sample_rate = 44100, float bpm = 120.0f)
    : track_count_(track_count), bpm_(bpm), master_volume_(1.0f), is_paused_(false) {
  for (size_t i = 0; i < track_count; ++i) {
    auto synth = std::make_unique<SimpleSynthesizer>(sample_rate);
    auto seq = std::make_unique<Sequencer>(synth.get(), bpm);
    synthesizers_.push_back(std::move(synth));
    sequencers_.push_back(std::move(seq));
  }
}
```

**主要メソッド**:

```cpp
// トラックへのアクセス
SimpleSynthesizer* getSynthesizer(size_t track_index);
Sequencer* getSequencer(size_t track_index);

// シーケンス設定
void setTrackSequence(size_t track_index, const FixedNoteSequence& notes) {
  if (track_index >= track_count_) return;
  sequencers_[track_index]->setSequence(notes);
}

// 全体制御
void setMasterVolume(float volume);  // 全トラックに適用
void setLoop(bool enabled, int count = -1);  // 全トラックに適用
void play();  // 全トラックを同時再生
void stop();  // 全トラックを停止

// 一時停止・再開
void pause() {
  if (!is_paused_) {
    is_paused_ = true;
    for (auto& seq : sequencers_) {
      if (seq->isPlaying()) {
        seq->pause();
      }
    }
  }
}

void resume() {
  if (is_paused_) {
    is_paused_ = false;
    for (auto& seq : sequencers_) {
      seq->resume();
    }
  }
}

// 状態確認
bool isPlaying() const;
bool isPaused() const;

// 更新
void update() {
  for (auto& synth : synthesizers_) {
    synth->update();
  }
  for (auto& seq : sequencers_) {
    seq->update();
  }
}
```

**メンバー変数**:
```cpp
size_t track_count_;
float bpm_;
float master_volume_;
bool is_paused_;
std::vector<std::unique_ptr<SimpleSynthesizer>> synthesizers_;
std::vector<std::unique_ptr<Sequencer>> sequencers_;
```

#### 2. BGMManagerクラスの実装

**概要**:
複数のMultiTrackSequencerをID（文字列）で管理し、任意のタイミングで切り替えられるクラス。

**主要メソッド**:

```cpp
// BGM登録
void registerBGM(const std::string& id, std::unique_ptr<MultiTrackSequencer> bgm) {
  bgm_map_[id] = std::move(bgm);
}

// BGM取得
MultiTrackSequencer* getBGM(const std::string& id) {
  auto it = bgm_map_.find(id);
  return (it != bgm_map_.end()) ? it->second.get() : nullptr;
}

// BGM再生（自動的に現在のBGMを停止）
bool play(const std::string& id) {
  auto* bgm = getBGM(id);
  if (!bgm) return false;

  // 現在のBGMを停止
  if (!current_bgm_id_.empty() && current_bgm_id_ != id) {
    auto* current = getBGM(current_bgm_id_);
    if (current) {
      current->stop();
    }
  }

  current_bgm_id_ = id;
  bgm->play();
  return true;
}

// 現在のBGM制御
void stop();
void pause();
void resume();

// マスターボリューム
void setMasterVolume(float volume) {
  master_volume_ = SDL_clamp(volume, 0.0f, 1.0f);
  for (auto& [id, bgm] : bgm_map_) {
    bgm->setMasterVolume(master_volume_);
  }
}

// 状態確認
const std::string& getCurrentBGMId() const { return current_bgm_id_; }
bool isPlaying() const;

// 更新
void update() {
  if (!current_bgm_id_.empty()) {
    auto* bgm = getBGM(current_bgm_id_);
    if (bgm) {
      bgm->update();
    }
  }
}
```

**メンバー変数**:
```cpp
std::unordered_map<std::string, std::unique_ptr<MultiTrackSequencer>> bgm_map_;
std::string current_bgm_id_;
float master_volume_ = 1.0f;
```

### game/test_impl_3.h

#### 1. MMLプリセットの追加

```cpp
namespace MMLPresets {
  // BGM1: 2トラック構成（メロディー + ベース）
  constexpr auto bgm1_melody = "t140 o5 l8 @0 v12 cdefg4 agfe d4.r4 efga b4>cd<b a4.r4"_mml;
  constexpr auto bgm1_bass = "t140 o3 l4 @1 v10 c2c2 g2g2 f2a2 d2d2"_mml;

  // BGM2: 3トラック構成（メロディー + 和音1 + 和音2）
  constexpr auto bgm2_melody = "t120 o5 l8 @0 v15 gagf e4d4 c4<b4 a2>c2"_mml;
  constexpr auto bgm2_chord1 = "t120 o4 l4 @1 v10 e2c2 g2e2"_mml;
  constexpr auto bgm2_chord2 = "t120 o3 l4 @2 v10 c2a2 e2c2"_mml;

  // BGM3: 2トラック構成（リズミカルな曲）
  constexpr auto bgm3_lead = "t160 o4 l16 @1 v14 ccccdddd eeeegggg aaaab4 >c4<b4a4"_mml;
  constexpr auto bgm3_backing = "t160 o3 l8 @2 v11 c4c4d4d4 e4e4g4g4 a4a4b4b4 >c4<b4a4g4"_mml;
}
```

#### 2. BGMManagerメンバー変数の追加

```cpp
// BGMマネージャー
BGMManager bgm_manager_;
float bgm_master_volume_ = 0.6f;
```

#### 3. BGMManager初期化メソッド

```cpp
void initializeBGMManager() {
  // BGM1: 2トラック構成（メロディー + ベース）
  auto bgm1 = std::make_unique<MultiTrackSequencer>(2, 44100, 140.0f);
  bgm1->setMasterVolume(bgm_master_volume_);
  bgm1->setLoop(true, -1);  // 無限ループ
  bgm1->setTrackSequence(0, MMLPresets::bgm1_melody);
  bgm1->setTrackSequence(1, MMLPresets::bgm1_bass);
  // 各トラックのエンベロープを設定
  bgm1->getSynthesizer(0)->getEnvelope().setADSR(0.05f, 0.1f, 0.7f, 0.15f);
  bgm1->getSynthesizer(1)->getEnvelope().setADSR(0.01f, 0.1f, 0.5f, 0.1f);
  bgm_manager_.registerBGM("bgm1", std::move(bgm1));

  // BGM2: 3トラック構成（メロディー + 和音1 + 和音2）
  auto bgm2 = std::make_unique<MultiTrackSequencer>(3, 44100, 120.0f);
  bgm2->setMasterVolume(bgm_master_volume_);
  bgm2->setLoop(true, -1);  // 無限ループ
  bgm2->setTrackSequence(0, MMLPresets::bgm2_melody);
  bgm2->setTrackSequence(1, MMLPresets::bgm2_chord1);
  bgm2->setTrackSequence(2, MMLPresets::bgm2_chord2);
  // 各トラックのエンベロープを設定
  bgm2->getSynthesizer(0)->getEnvelope().setADSR(0.05f, 0.1f, 0.7f, 0.15f);
  bgm2->getSynthesizer(1)->getEnvelope().setADSR(0.02f, 0.15f, 0.6f, 0.2f);
  bgm2->getSynthesizer(2)->getEnvelope().setADSR(0.02f, 0.15f, 0.6f, 0.2f);
  bgm_manager_.registerBGM("bgm2", std::move(bgm2));

  // BGM3: 2トラック構成（リズミカルな曲）
  auto bgm3 = std::make_unique<MultiTrackSequencer>(2, 44100, 160.0f);
  bgm3->setMasterVolume(bgm_master_volume_);
  bgm3->setLoop(true, -1);  // 無限ループ
  bgm3->setTrackSequence(0, MMLPresets::bgm3_lead);
  bgm3->setTrackSequence(1, MMLPresets::bgm3_backing);
  // 各トラックのエンベロープを設定
  bgm3->getSynthesizer(0)->getEnvelope().setADSR(0.01f, 0.05f, 0.8f, 0.1f);
  bgm3->getSynthesizer(1)->getEnvelope().setADSR(0.02f, 0.1f, 0.6f, 0.15f);
  bgm_manager_.registerBGM("bgm3", std::move(bgm3));

  SDL_Log("BGMManager initialized with 3 BGMs");
}
```

#### 4. キーバインディングの追加

```cpp
case SDL_SCANCODE_F1: {
  // F1キー: BGM1を再生（2トラック: メロディー + ベース）
  bgm_manager_.play("bgm1");
  break;
}
case SDL_SCANCODE_F2: {
  // F2キー: BGM2を再生（3トラック: メロディー + 和音1 + 和音2）
  bgm_manager_.play("bgm2");
  break;
}
case SDL_SCANCODE_F3: {
  // F3キー: BGM3を再生（2トラック: リズミカルな曲）
  bgm_manager_.play("bgm3");
  break;
}
case SDL_SCANCODE_F5: {
  // F5キー: 現在のBGMを停止
  bgm_manager_.stop();
  break;
}
case SDL_SCANCODE_F6: {
  // F6キー: 現在のBGMを一時停止
  bgm_manager_.pause();
  break;
}
case SDL_SCANCODE_F7: {
  // F7キー: 現在のBGMを再開
  bgm_manager_.resume();
  break;
}
case SDL_SCANCODE_LEFTBRACKET: {
  // [キー: BGMマスターボリュームを下げる
  bgm_master_volume_ -= 0.1f;
  if (bgm_master_volume_ < 0.0f) bgm_master_volume_ = 0.0f;
  bgm_manager_.setMasterVolume(bgm_master_volume_);
  break;
}
case SDL_SCANCODE_RIGHTBRACKET: {
  // ]キー: BGMマスターボリュームを上げる
  bgm_master_volume_ += 0.1f;
  if (bgm_master_volume_ > 1.0f) bgm_master_volume_ = 1.0f;
  bgm_manager_.setMasterVolume(bgm_master_volume_);
  break;
}
```

#### 5. update()メソッドにBGMManager更新を追加

```cpp
// BGMマネージャーを更新
bgm_manager_.update();
```

#### 6. ヘルプテキストの更新

```cpp
SDL_RenderDebugText(renderer_, 10, 50, "F1-F3: BGM1-3, F5: Stop, F6: Pause, F7: Resume, []: Vol");
```

## アーキテクチャ

```
BGMManager
├── MultiTrackSequencer ("bgm1")
│   ├── Track 0: SimpleSynthesizer + Sequencer (メロディー)
│   └── Track 1: SimpleSynthesizer + Sequencer (ベース)
├── MultiTrackSequencer ("bgm2")
│   ├── Track 0: SimpleSynthesizer + Sequencer (メロディー)
│   ├── Track 1: SimpleSynthesizer + Sequencer (和音1)
│   └── Track 2: SimpleSynthesizer + Sequencer (和音2)
└── MultiTrackSequencer ("bgm3")
    ├── Track 0: SimpleSynthesizer + Sequencer (リード)
    └── Track 1: SimpleSynthesizer + Sequencer (バッキング)
```

**階層的な責務分離**:
- **SimpleSynthesizer**: 単一の音色生成
- **Sequencer**: 単一パートのMML演奏
- **MultiTrackSequencer**: 1曲の複数パート管理
- **BGMManager**: 複数曲の管理と切り替え

## 使用例

```cpp
// BGMManager初期化
BGMManager bgm_manager;

// BGMを登録
auto bgm1 = std::make_unique<MultiTrackSequencer>(2, 44100, 140.0f);
bgm1->setTrackSequence(0, melody_mml);
bgm1->setTrackSequence(1, bass_mml);
bgm1->setLoop(true, -1);
bgm_manager.registerBGM("title_screen", std::move(bgm1));

auto bgm2 = std::make_unique<MultiTrackSequencer>(3, 44100, 120.0f);
bgm2->setTrackSequence(0, melody_mml);
bgm2->setTrackSequence(1, chord1_mml);
bgm2->setTrackSequence(2, chord2_mml);
bgm2->setLoop(true, -1);
bgm_manager.registerBGM("stage1", std::move(bgm2));

// BGMを再生（自動的に現在のBGMを停止）
bgm_manager.play("title_screen");

// ステージ開始時にBGM切り替え
bgm_manager.play("stage1");

// 一時停止・再開
bgm_manager.pause();
bgm_manager.resume();

// ボリューム調整
bgm_manager.setMasterVolume(0.7f);

// 毎フレーム更新
bgm_manager.update();
```

## テスト方法

1. ビルドして実行: `cmake --build build && ./build/main`
2. **F1キー**: BGM1を再生（2トラック: メロディー + ベース）
3. **F2キー**: BGM2を再生（3トラック: メロディー + 和音1 + 和音2）
4. **F3キー**: BGM3を再生（2トラック: リズミカル）
5. **F5キー**: 現在のBGMを停止
6. **F6キー**: 現在のBGMを一時停止
7. **F7キー**: 一時停止したBGMを再開
8. **[ / ]キー**: BGMマスターボリュームを調整

## 技術的な詳細

### マルチトラックの同期

すべてのトラックは同じBPMで初期化され、`play()`で同時に開始されるため、自然に同期される。各シーケンサーは独立したタイマーで動作するが、BPMが同じため音楽的に整合する。

### BGM切り替え時の動作

`BGMManager::play()`は新しいBGMを再生する前に、現在再生中のBGMを自動的に停止する。これにより、複数のBGMが同時に再生されることを防ぐ。

### メモリ管理

- `std::unique_ptr`で所有権を明確化
- `std::unordered_map`でID管理
- BGMManager破棄時に全BGMも自動的に破棄される

### スレッドセーフティ

各シーケンサーはSDL_AddTimerで独立したタイマーから呼ばれるが、SimpleSynthesizerがスレッドセーフに設計されているため問題なし。

## 今後の拡張可能性

- フェードイン・フェードアウト機能
- クロスフェードでのBGM切り替え
- トラックごとの個別ボリューム調整
- BGMのループ区間指定（イントロ + ループ部分）
- BGMの動的な追加・削除
- BGM再生状態のシリアライズ（セーブデータ用）
