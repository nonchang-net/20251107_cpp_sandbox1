# 作業レポート - 2025/11/09 11:48

## 変更内容の概要

- KeyboardInputコンポーネントを削除しました
- キーボード入力処理をTestImpl3（ゲーム実装側）に集約しました
- handlePlayerInput()メソッドを追加し、プレイヤーの移動制御をゲームロジックとして実装しました

## 変更理由

- **関心の分離**: 入力処理はゲーム固有のロジックであり、汎用的なコンポーネントシステムよりもゲーム実装側で管理する方が適切
- **入力処理の集約**: handleSdlEvent()やupdate()といったゲーム実装のメソッドで入力を一元管理できる
- **拡張性の向上**: ゲーム固有の複雑な入力処理（攻撃、ジャンプ、アイテム使用など）に対応しやすくなる

## 技術的な実装詳細

### 1. KeyboardInputコンポーネントの削除

**削除したファイル:**
- component.h: KeyboardInputクラス定義を削除
- entity_manager.h: KeyboardInput::update()実装を削除

**削除前のKeyboardInput:**
```cpp
class KeyboardInput : public Component {
 public:
  explicit KeyboardInput(float speed = 100.0f) : speed_(speed) {}
  void update(Entity* entity, Uint64 delta_time) override;
 private:
  float speed_;
};
```

**問題点:**
- コンポーネントとして汎用化しすぎている
- ゲーム固有のロジック（攻撃、ジャンプなど）を追加しづらい
- 入力処理が複数のエンティティに分散してしまう

### 2. TestImpl3での入力処理実装

**メンバ変数の追加 (test_impl_3.h):**
```cpp
class TestImpl3 final : public GameImpl {
 private:
  SDL_Renderer* renderer_ = nullptr;
  SDL_Texture* texture_ = nullptr;
  EntityManager entity_manager_;
  Uint64 last_time_;
  Uint64 spawn_timer_;
  Entity* player_ = nullptr;  // プレイヤーエンティティへの参照
```

**プレイヤーへの参照を保存:**
- initializeEntities()でプレイヤー作成後、EntityManagerに追加する前に`player_ = player.get()`で保存
- Rキーリセット時は`player_ = nullptr`で初期化

### 3. handlePlayerInput()メソッドの実装

**入力処理メソッド (test_impl_3.h):**
```cpp
void handlePlayerInput() {
  if (!player_) return;

  // VelocityMoveコンポーネントを取得
  auto* velocity = player_->getComponent<VelocityMove>();
  if (!velocity) return;

  // キーボード状態を取得
  const bool* keys = SDL_GetKeyboardState(nullptr);

  // 移動速度（ピクセル/秒）
  const float speed = 100.0f;

  // 移動方向を計算
  float vx = 0.0f;
  float vy = 0.0f;

  if (keys[SDL_SCANCODE_UP] || keys[SDL_SCANCODE_W]) {
    vy -= speed;
  }
  if (keys[SDL_SCANCODE_DOWN] || keys[SDL_SCANCODE_S]) {
    vy += speed;
  }
  if (keys[SDL_SCANCODE_LEFT] || keys[SDL_SCANCODE_A]) {
    vx -= speed;
  }
  if (keys[SDL_SCANCODE_RIGHT] || keys[SDL_SCANCODE_D]) {
    vx += speed;
  }

  // 速度を設定
  velocity->setVelocity(vx, vy);
}
```

**呼び出し箇所 (test_impl_3.h):**
```cpp
SDL_AppResult update() override {
  Uint64 current_time = SDL_GetTicks();
  Uint64 delta_time = current_time - last_time_;
  last_time_ = current_time;

  // プレイヤー入力処理
  handlePlayerInput();

  // エンティティの更新
  entity_manager_.updateAll(delta_time);

  // ... 以下続く
}
```

**処理の流れ:**
1. update()の最初にhandlePlayerInput()を呼び出し
2. player_がnullptrでないことを確認
3. プレイヤーのVelocityMoveコンポーネントを取得
4. SDL_GetKeyboardState()でキーボード状態を取得
5. カーソルキー（WASD）の押下状態から速度ベクトルを計算
6. VelocityMoveの速度を設定
7. entity_manager_.updateAll()でVelocityMoveが実際に座標を更新

### 4. プレイヤー作成部分の修正

**変更前:**
```cpp
// 移動・入力
player->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));
player->addComponent(std::make_unique<KeyboardInput>(100.0f));  // 100px/秒

entity_manager_.addEntity(std::move(player));
```

**変更後:**
```cpp
// 移動（入力処理はhandlePlayerInput()で行う）
player->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));

// プレイヤーへの参照を保存してからEntityManagerに追加
player_ = player.get();
entity_manager_.addEntity(std::move(player));
```

**重要なポイント:**
- `player.get()`で生ポインタを取得して`player_`に保存
- その後`std::move(player)`でEntityManagerに所有権を移譲
- `player_`はEntityManagerが保持するエンティティへの「観察ポインタ」として機能

### 5. リセット処理の修正

**Rキーでのリセット処理 (test_impl_3.h):**
```cpp
case SDL_SCANCODE_R:
  // Rキーでリセット
  player_ = nullptr;  // プレイヤー参照をクリア
  entity_manager_.clear();
  initializeEntities();
  break;
```

**理由:**
- entity_manager_.clear()で全エンティティが削除される
- `player_`が指していたエンティティも削除されるため、ダングリングポインタを防ぐ
- initializeEntities()で新しいプレイヤーが作成され、`player_`が再設定される

## アーキテクチャの改善

### 変更前: コンポーネントベースの入力処理

```
KeyboardInputコンポーネント
  ↓ update()
SDL_GetKeyboardState()
  ↓
VelocityMoveコンポーネント
```

**問題点:**
- 入力処理がコンポーネントに分散
- ゲーム固有のロジックを追加しづらい
- 複数のエンティティに入力処理が必要な場合、管理が煩雑

### 変更後: ゲーム実装側での入力処理

```
TestImpl3::handlePlayerInput()
  ↓
SDL_GetKeyboardState()
  ↓
player_->getComponent<VelocityMove>()
```

**利点:**
- 入力処理がゲーム実装側に集約
- ゲーム固有のロジック（状態管理、アニメーション切り替えなど）を追加しやすい
- プレイヤーエンティティへの直接アクセスで処理が明確

## 設計思想

### コンポーネントシステムとゲームロジックの分離

**コンポーネントシステムの責任:**
- 汎用的な機能の提供（座標、速度、描画など）
- データとロジックの組み合わせによる柔軟性

**ゲーム実装側の責任:**
- ゲーム固有のロジック（入力処理、AI、状態管理など）
- エンティティ間の相互作用
- ゲーム全体の制御フロー

### 入力処理の適切な配置

**汎用コンポーネントとして適切でない理由:**
1. ゲームごとに入力マッピングが異なる
2. 状態（ジャンプ中、攻撃中など）による入力の無効化が必要
3. 複雑な入力コンボやシーケンスが必要になる

**ゲーム実装側に配置する利点:**
1. ゲーム固有の状態管理と統合しやすい
2. 入力処理を一箇所で管理できる
3. デバッグやテストがしやすい

## ビルド結果

✅ ビルド成功
✅ KeyboardInputコンポーネント削除
✅ TestImpl3で入力処理を実装
✅ プレイヤー移動機能が正常動作

## 今後の拡張例

このアーキテクチャにより、以下の拡張が容易になりました：

### 1. 状態による入力制御

```cpp
void handlePlayerInput() {
  if (!player_ || player_state_ == PlayerState::Attacking) return;
  // ... 入力処理
}
```

### 2. アニメーション方向の切り替え

```cpp
void handlePlayerInput() {
  // ... 速度計算

  // 移動方向に応じてアニメーションを切り替え
  auto* animator = player_->getComponent<SpriteAnimator>();
  if (vx < 0) {
    animator->setFrames(walk_left_frames);
  } else if (vx > 0) {
    animator->setFrames(walk_right_frames);
  }

  velocity->setVelocity(vx, vy);
}
```

### 3. 攻撃・ジャンプなどのアクション

```cpp
void handlePlayerInput() {
  if (!player_) return;

  const bool* keys = SDL_GetKeyboardState(nullptr);

  // スペースキーで攻撃
  if (keys[SDL_SCANCODE_SPACE] && !is_attacking_) {
    startAttack();
  }

  // Shiftキーでダッシュ
  float speed = keys[SDL_SCANCODE_LSHIFT] ? 200.0f : 100.0f;

  // ... 移動処理
}
```

## まとめ

キーボード入力処理をKeyboardInputコンポーネントからTestImpl3（ゲーム実装側）に移動することで、以下の改善が達成されました：

1. **関心の分離**: 汎用的なコンポーネントとゲーム固有のロジックを明確に分離
2. **拡張性の向上**: ゲーム固有の複雑な入力処理に対応しやすい設計
3. **保守性の向上**: 入力処理が一箇所に集約され、デバッグやテストが容易

コンポーネントシステムは「データと汎用的な機能」を提供し、ゲーム実装側は「ゲーム固有のロジックと制御フロー」を担当する、という明確な責任分担が実現されました。
