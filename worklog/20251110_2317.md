# 20251110_2317 - ボリュームモジュレーション（トレモロ）エフェクトとAudioEffect基底クラスの実装

## 変更内容の概要

- AudioEffect基底クラスを作成し、全エフェクトの統一インターフェースを定義（sound/effect/audio_effect.h）
- VolumeModulation（トレモロ効果）を実装（sound/effect/volume_modulation.h/.cc）
- SimpleSynthesizerにオプショナルなボリュームモジュレーション機能を追加（デフォルトはオフ）
- エフェクトチェーン（複数エフェクトの直列接続）への拡張を考慮した設計

## 変更理由

BiquadFilterに続き、トレモロ効果（ボリュームの周期的な変調）を実装する必要があった。今後も様々なエフェクト（リバーブ、ディレイ、歪みなど）を追加する予定のため、エフェクトの一般化を見据えた設計を採用した。AudioEffectという共通の基底クラスを定義することで、将来的にエフェクトチェーンやエフェクトスロットなどの高度な機能を実現しやすくなる。

## 作成したファイル

### 1. sound/effect/audio_effect.h

**概要**: 全エフェクトの基底クラス（純粋仮想クラス）

```cpp
namespace MySound {

/**
 * @brief オーディオエフェクトの基底クラス
 *
 * 全てのエフェクト（フィルター、モジュレーション、リバーブなど）が
 * 継承する共通インターフェース。
 */
class AudioEffect {
 public:
  virtual ~AudioEffect() = default;

  /**
   * @brief サンプルを処理（純粋仮想関数）
   */
  virtual float process(float input) = 0;

  /**
   * @brief エフェクト状態をリセット（純粋仮想関数）
   */
  virtual void reset() = 0;
};

}  // namespace MySound
```

**設計のポイント**:
- **純粋仮想関数**: `process()`と`reset()`を純粋仮想関数として定義
- **統一インターフェース**: 全エフェクトが同じインターフェースを持つ
- **エフェクトチェーン**: 将来的に`std::vector<std::unique_ptr<AudioEffect>>`でチェーン実装可能
- **ポリモーフィズム**: 基底クラスのポインタ/参照で様々なエフェクトを扱える

**将来の拡張可能性**:
```cpp
// エフェクトチェーンの例（将来的に実装可能）
class EffectChain {
  std::vector<std::unique_ptr<AudioEffect>> effects_;

  float process(float input) {
    float output = input;
    for (auto& effect : effects_) {
      output = effect->process(output);
    }
    return output;
  }
};
```

### 2. sound/effect/volume_modulation.h

**概要**: ボリュームモジュレーション（トレモロ効果）のヘッダファイル

```cpp
namespace MySound {

/**
 * @brief ボリュームモジュレーション（トレモロ効果）
 *
 * LFO（Low Frequency Oscillator）を使用してボリュームを周期的に変調します。
 */
class VolumeModulation : public AudioEffect {
 public:
  explicit VolumeModulation(int sample_rate);

  // パラメータ設定
  void setRate(float rate);        // モジュレーション周波数（0.1Hz〜20.0Hz）
  void setDepth(float depth);      // 効果量（0.0〜1.0）
  void setWaveType(WaveType wave_type);  // LFO波形タイプ

  // パラメータ取得
  float getRate() const;
  float getDepth() const;
  WaveType getWaveType() const;

  // AudioEffectインターフェース実装
  float process(float input) override;
  void reset() override;

 private:
  int sample_rate_;
  float rate_;                     // モジュレーション周波数（Hz）
  float depth_;                    // 効果量（0.0〜1.0）
  std::unique_ptr<Oscillator> lfo_; // LFO（Low Frequency Oscillator）
  Uint64 current_sample_;
};

}  // namespace MySound
```

**特徴**:
- **AudioEffect継承**: 基底クラスのインターフェースを実装
- **LFO使用**: 既存のOscillatorクラスを再利用してLFO（低周波発振器）を実現
- **柔軟なパラメータ**: 周波数、深さ、波形タイプを自由に調整可能

### 3. sound/effect/volume_modulation.cc

**概要**: ボリュームモジュレーションの実装ファイル

**コンストラクタ**:
```cpp
VolumeModulation::VolumeModulation(int sample_rate)
    : sample_rate_(sample_rate),
      rate_(5.0f),  // デフォルト: 5Hz（1秒間に5回）
      depth_(0.5f), // デフォルト: 50%の深さ
      lfo_(std::make_unique<Oscillator>(WaveType::Sine, 5.0f)),
      current_sample_(0) {
}
```

**process()メソッド（トレモロ効果の核心）**:
```cpp
float VolumeModulation::process(float input) {
  // 1. LFOの位相を計算（0.0〜1.0）
  float phase = SDL_fmodf(
      static_cast<float>(current_sample_) * rate_ / sample_rate_, 1.0f);

  // 2. LFOの波形を生成（-1.0〜1.0）
  float lfo = lfo_->generate(phase);

  // 3. LFOを0.0〜1.0の範囲にマップ（ユニポーラ変換）
  float lfo_unipolar = (lfo + 1.0f) / 2.0f;

  // 4. モジュレーション量を計算
  // depth=0.0: ボリューム変化なし（modulation=1.0）
  // depth=1.0: LFOの波形に完全に従う（modulation=0.0〜1.0）
  float modulation = 1.0f - depth_ + depth_ * lfo_unipolar;

  current_sample_++;

  return input * modulation;
}
```

**処理の流れ**:
1. LFOの位相を計算（時間経過に応じて0.0〜1.0で循環）
2. Oscillatorで波形を生成（サイン波、矩形波など）
3. バイポーラ（-1.0〜1.0）からユニポーラ（0.0〜1.0）に変換
4. depth（効果量）に応じてモジュレーション量を計算
5. 入力サンプルに乗算して出力

**モジュレーション量の計算式**:
```
modulation = 1.0 - depth + depth * lfo_unipolar

depth = 0.0 の場合: modulation = 1.0 （エフェクトなし）
depth = 1.0 の場合: modulation = lfo_unipolar （0.0〜1.0で変化）
depth = 0.5 の場合: modulation = 0.5 + 0.5 * lfo_unipolar （0.5〜1.0で変化）
```

### 4. sound/core/synthesizer.h の変更

SimpleSynthesizerにボリュームモジュレーション機能を追加：

```cpp
#include "../effect/volume_modulation.h"

// 前方宣言
class VolumeModulation;

class SimpleSynthesizer {
 public:
  // ... 既存のメソッド ...

  // ボリュームモジュレーション関連メソッド
  void enableVolumeModulation();           // 有効化
  void disableVolumeModulation();          // 無効化
  bool isVolumeModulationEnabled() const;  // 有効かどうか
  VolumeModulation* getVolumeModulation(); // 取得（パラメータ調整用）

 private:
  std::unique_ptr<VolumeModulation> volume_mod_;  // ボリュームモジュレーション（nullptrなら無効）
  // ... 既存のメンバー変数 ...
};
```

### 5. sound/core/synthesizer.cc の変更

**初期化リスト**:
```cpp
SimpleSynthesizer::SimpleSynthesizer(int sample_rate)
    : oscillator_(std::make_unique<Oscillator>(WaveType::Sine, DEFAULT_FREQUENCY)),
      envelope_(std::make_unique<Envelope>()),
      filter_(nullptr),      // フィルターはデフォルトで無効
      volume_mod_(nullptr),  // ボリュームモジュレーションもデフォルトで無効
      // ... その他の初期化 ...
```

**enableVolumeModulation()メソッド**:
```cpp
void SimpleSynthesizer::enableVolumeModulation() {
  if (!volume_mod_) {
    volume_mod_ = std::make_unique<VolumeModulation>(sample_rate_);
    // デフォルト設定: 5Hz, 50% depth, Sine wave
    volume_mod_->setRate(5.0f);
    volume_mod_->setDepth(0.5f);
    volume_mod_->setWaveType(WaveType::Sine);
  }
}
```

**disableVolumeModulation()メソッド**:
```cpp
void SimpleSynthesizer::disableVolumeModulation() {
  if (volume_mod_) {
    volume_mod_.reset();  // unique_ptrをリセット（メモリ解放）
  }
}
```

**generateSamples()での処理順序**:
```cpp
// 1. 波形生成
float wave = oscillator_->generate(phase);

// 2. エンベロープとボリュームを適用
samples[i] = wave * envelope_value * note_volume_ * master_volume_;

// 3. フィルター適用（有効な場合のみ）
if (filter_) {
  samples[i] = filter_->process(samples[i]);
}

// 4. ボリュームモジュレーション適用（有効な場合のみ）
if (volume_mod_) {
  samples[i] = volume_mod_->process(samples[i]);
}

// 5. クリッピング防止
if (samples[i] > 1.0f) samples[i] = 1.0f;
if (samples[i] < -1.0f) samples[i] = -1.0f;
```

**処理順序の意図**:
- **フィルター → ボリュームモジュレーション**: 音色を整えてから音量を変調
- フィルターで高周波をカットした後、トレモロをかけることで自然な効果
- 順序を逆にすると、音量変化の後にフィルターがかかり、やや不自然になる可能性

### 6. sound/sound.h の更新

```cpp
// エフェクト
#include "effect/audio_effect.h"        // 基底クラス
#include "effect/biquad_filter.h"       // フィルター
#include "effect/volume_modulation.h"   // トレモロ
```

### 7. CMakeLists.txt の更新

```cmake
set(SOUND_SOURCES
    sound/core/oscillator.cc
    sound/core/envelope.cc
    sound/core/synthesizer.cc
    sound/sequencer/sequencer.cc
    sound/sequencer/multi_track_sequencer.cc
    sound/sequencer/bgm_manager.cc
    sound/effect/biquad_filter.cc
    sound/effect/volume_modulation.cc  # 追加
)
```

## ビルド結果

```
[ 94%] Building CXX object CMakeFiles/sound.dir/sound/effect/volume_modulation.cc.o
[ 95%] Linking CXX static library libsound.a
[ 97%] Built target sound
...
[100%] Built target main
```

**成功！** VolumeModulationが正常にコンパイルされ、libsound.aに組み込まれた。

## 使用例

### 基本的な使い方

```cpp
#include "sound/sound.h"

using namespace MySound;

// シンセサイザーを作成
auto synth = std::make_unique<SimpleSynthesizer>(44100);

// トレモロを有効化（デフォルト: 5Hz, 50% depth, Sine）
synth->enableVolumeModulation();

// パラメータを調整
auto* tremolo = synth->getVolumeModulation();
if (tremolo) {
  tremolo->setRate(8.0f);              // 8Hz（速いトレモロ）
  tremolo->setDepth(0.7f);             // 70%の深さ
  tremolo->setWaveType(WaveType::Sine); // サイン波（滑らかな変化）
}

// 音を鳴らす（トレモロ適用）
synth->noteOn(440.0f, 3.0f);  // A4を3秒間

// トレモロを無効化
synth->disableVolumeModulation();

// トレモロ無効時は従来通りの音
synth->noteOn(440.0f, 1.0f);
```

### 遅いトレモロ（ゆったりとした音量変化）

```cpp
synth->enableVolumeModulation();

auto* tremolo = synth->getVolumeModulation();
tremolo->setRate(2.0f);   // 2Hz（ゆっくり）
tremolo->setDepth(0.8f);  // 80%の深さ
tremolo->setWaveType(WaveType::Sine);

synth->noteOn(440.0f, 5.0f);  // ゆったりとしたトレモロ
```

### 速いトレモロ（ヘリコプター効果）

```cpp
synth->enableVolumeModulation();

auto* tremolo = synth->getVolumeModulation();
tremolo->setRate(15.0f);  // 15Hz（速い）
tremolo->setDepth(1.0f);  // 100%の深さ
tremolo->setWaveType(WaveType::Square);  // 矩形波（急激な変化）

synth->noteOn(220.0f, 2.0f);  // ヘリコプター風の効果音
```

### フィルターと組み合わせる

```cpp
// ノイズ + ローパスフィルター + トレモロ
synth->getOscillator().setWaveType(WaveType::Noise);

// ローパスフィルター
synth->enableFilter();
auto* filter = synth->getFilter();
filter->setType(BiquadFilterType::Lowpass);
filter->setFrequency(2000.0f);
filter->setQ(1.0f);

// トレモロ
synth->enableVolumeModulation();
auto* tremolo = synth->getVolumeModulation();
tremolo->setRate(6.0f);
tremolo->setDepth(0.6f);

synth->noteOn(440.0f, 3.0f);  // フィルタリング + トレモロのノイズ
```

### 異なるLFO波形の効果

```cpp
synth->enableVolumeModulation();
auto* tremolo = synth->getVolumeModulation();
tremolo->setRate(5.0f);
tremolo->setDepth(0.7f);

// 1. サイン波（滑らかな変化）
tremolo->setWaveType(WaveType::Sine);
synth->noteOn(440.0f, 2.0f);

// 2. 矩形波（急激なオン/オフ）
tremolo->setWaveType(WaveType::Square);
synth->noteOn(440.0f, 2.0f);

// 3. ノコギリ波（直線的な上昇/急降下）
tremolo->setWaveType(WaveType::Sawtooth);
synth->noteOn(440.0f, 2.0f);

// 4. ノイズ（ランダムな音量変化）
tremolo->setWaveType(WaveType::Noise);
synth->noteOn(440.0f, 2.0f);
```

## LFO波形タイプによる効果の違い

### Sine（サイン波）
- **特徴**: 最も滑らかで自然な音量変化
- **用途**: 古典的なトレモロ、ビブラート風の効果
- **音色**: 柔らかく、音楽的

### Square（矩形波）
- **特徴**: 急激なオン/オフ
- **用途**: ゲート効果、ヘリコプター音、テクノ系
- **音色**: 機械的、リズミック

### Sawtooth（ノコギリ波）
- **特徴**: 直線的に上昇して急降下（または逆）
- **用途**: サイレン風、実験的な効果
- **音色**: 工業的、非対称な変化

### Noise（ノイズ）
- **特徴**: ランダムな音量変化
- **用途**: 実験的な効果、グリッチ音
- **音色**: 不規則、予測不可能

## パフォーマンス考察

### ボリュームモジュレーション無効時のコスト

```cpp
if (volume_mod_) {
  samples[i] = volume_mod_->process(samples[i]);
}
```

`volume_mod_`がnullptrの場合、ポインタチェック（1命令）のみ。
BiquadFilterと同様、ほぼコストゼロ。

### ボリュームモジュレーション有効時のコスト

process()メソッドは以下の演算を実行：
- fmod: 1回（位相計算）
- Oscillator::generate(): 1回（波形生成、sin/cos等）
- 加算/減算: 3回
- 乗算: 3回
- 代入: 1回

合計約10命令程度。BiquadFilterより軽量。

### エフェクトチェーンのコスト

```
フィルター: 13命令
ボリュームモジュレーション: 10命令
合計: 23命令/サンプル
```

サンプリングレート44100Hzの場合、秒間約100万命令。
現代のCPU（数GHz）では無視できるレベル。

## 設計の考慮点と将来の拡張

### 1. AudioEffect基底クラスの利点

**統一インターフェース**:
```cpp
std::unique_ptr<AudioEffect> effect1 = std::make_unique<BiquadFilter>(44100);
std::unique_ptr<AudioEffect> effect2 = std::make_unique<VolumeModulation>(44100);

// 同じインターフェースで処理
float output1 = effect1->process(input);
float output2 = effect2->process(input);
```

**エフェクトチェーン（将来実装可能）**:
```cpp
class EffectChain : public AudioEffect {
  std::vector<std::unique_ptr<AudioEffect>> effects_;

  void addEffect(std::unique_ptr<AudioEffect> effect) {
    effects_.push_back(std::move(effect));
  }

  float process(float input) override {
    float output = input;
    for (auto& effect : effects_) {
      output = effect->process(output);
    }
    return output;
  }

  void reset() override {
    for (auto& effect : effects_) {
      effect->reset();
    }
  }
};
```

**エフェクトスロット（将来実装可能）**:
```cpp
class SimpleSynthesizer {
  std::array<std::unique_ptr<AudioEffect>, 4> effect_slots_;  // 4つのスロット

  void setEffect(int slot, std::unique_ptr<AudioEffect> effect) {
    if (slot >= 0 && slot < 4) {
      effect_slots_[slot] = std::move(effect);
    }
  }

  // generateSamples()で全スロットを順番に処理
};
```

### 2. BiquadFilterもAudioEffectを継承すべきか？

**現状**: BiquadFilterはAudioEffectを継承していない

**検討**:
- **継承する利点**: エフェクトチェーンで統一的に扱える
- **継承しない利点**: 既存コードへの影響が少ない、独立性が高い

**将来の方針**:
Phase 4として、BiquadFilterもAudioEffectを継承するようリファクタリングする。

### 3. 処理順序の柔軟性

**現状の固定順序**:
```
波形生成 → エンベロープ × ボリューム → フィルター → ボリュームモジュレーション → クリッピング
```

**将来的な柔軟な順序**:
```cpp
class SimpleSynthesizer {
  EffectChain effect_chain_;

  void setupEffects() {
    effect_chain_.addEffect(std::make_unique<BiquadFilter>(sample_rate_));
    effect_chain_.addEffect(std::make_unique<VolumeModulation>(sample_rate_));
    // 順序を自由に変更可能
  }
};
```

### 4. 他のエフェクトの追加予定

**空間系エフェクト**:
- **Delay**: ディレイ（エコー）
- **Reverb**: リバーブ（残響）

**ダイナミクス系エフェクト**:
- **Compressor**: コンプレッサー（音量差を圧縮）
- **Limiter**: リミッター（最大音量を制限）

**歪み系エフェクト**:
- **Distortion**: ディストーション（歪み）
- **Overdrive**: オーバードライブ（柔らかい歪み）

**モジュレーション系エフェクト**:
- **Chorus**: コーラス（音を重ねる）
- **Flanger**: フランジャー（音を揺らす）
- **Phaser**: フェイザー（位相を変化させる）

これら全てがAudioEffectを継承することで、統一的に扱える。

## ディレクトリ構造（更新後）

```
sound/
├── effect/
│   ├── audio_effect.h          ← 新規（基底クラス）
│   ├── biquad_filter.h/.cc     ← 既存
│   └── volume_modulation.h/.cc ← 新規（トレモロ）
├── core/（oscillator, envelope, synthesizer）
├── mml/（mml_parser.h）
├── sequencer/（sequencer, multi_track_sequencer, bgm_manager）
└── その他...
```

## メリット

1. **統一インターフェース**: AudioEffectにより全エフェクトが同じインターフェース
2. **拡張性**: 新しいエフェクトの追加が容易
3. **エフェクトチェーン**: 将来的に複数エフェクトの直列接続が可能
4. **低コスト**: オフ時はほぼゼロ、オン時も軽量
5. **既存Oscillatorの再利用**: LFOとして既存のOscillatorを活用
6. **柔軟なパラメータ**: 周波数、深さ、波形タイプを自由に調整

## 今後の拡張計画

### Phase 4: BiquadFilterのAudioEffect継承
```cpp
class BiquadFilter : public AudioEffect {
  // 既存のメソッドはそのまま
  // AudioEffectインターフェースを追加実装
};
```

### Phase 5: エフェクトチェーンの実装
```cpp
class EffectChain : public AudioEffect {
  std::vector<std::unique_ptr<AudioEffect>> effects_;
  // 複数エフェクトを順番に処理
};
```

### Phase 6: エフェクトスロットの実装
```cpp
class SimpleSynthesizer {
  std::array<std::unique_ptr<AudioEffect>, 4> effect_slots_;
  // 4つのスロットで自由にエフェクトを組み合わせ
};
```

### Phase 7: 空間系エフェクト（Delay, Reverb）
```cpp
class Delay : public AudioEffect { ... };
class Reverb : public AudioEffect { ... };
```

## まとめ

AudioEffect基底クラスとVolumeModulation（トレモロ）を実装し、SimpleSynthesizerにオプショナルな機能として統合しました。AudioEffectという統一インターフェースにより、将来的なエフェクトチェーンやエフェクトスロットなどの高度な機能を実現しやすくなりました。BiquadFilterに続く2つ目のエフェクトとして、Oscillatorを再利用したLFOベースのトレモロを実装し、柔軟な音作りを可能にしました。
