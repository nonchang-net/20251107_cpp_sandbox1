# 作業レポート - 2025/11/09 19:00

## 変更内容の概要

- 再利用可能なFpsCounterクラスを実装しました
- 移動平均を使用した安定したFPS計測機能を実現しました
- TestImpl3でFpsCounterを使用し、正確なFPS表示と平均フレーム時間を表示するようにしました

## 変更理由

- **正確なFPS計測**: 簡易的な計算では瞬間的な値で不安定なため、移動平均による安定した計測が必要
- **再利用性**: 他のゲーム実装でも使える汎用的なFPS計測クラスとして設計
- **詳細な情報**: FPS値だけでなく平均フレーム時間も表示することで、パフォーマンス分析に役立つ

## 技術的な実装詳細

### 1. FpsCounterクラスの設計 (game_manager/utilities/fps_counter.h)

**クラス定義:**
```cpp
class FpsCounter {
 public:
  explicit FpsCounter(size_t sample_count = 60);
  void update();
  float getFps() const;
  float getAverageFrameTime() const;
  float getLastFrameTime() const;
  void reset();

 private:
  size_t sample_count_;          // サンプル数
  std::deque<Uint64> frame_times_;  // フレーム時間の履歴
  Uint64 last_time_;             // 前回のupdate()時刻
};
```

**特徴:**
- 移動平均方式を採用
- デフォルトで60フレーム分のサンプルを保持
- std::dequeで履歴を管理（古いデータを効率的に削除）

### 2. update()メソッドの実装

```cpp
void update() {
  Uint64 current_time = SDL_GetTicks();
  Uint64 delta_time = current_time - last_time_;
  last_time_ = current_time;

  // フレーム時間を記録
  frame_times_.push_back(delta_time);

  // サンプル数を超えたら古いデータを削除
  if (frame_times_.size() > sample_count_) {
    frame_times_.pop_front();
  }
}
```

**処理の流れ:**
1. 現在時刻を取得
2. 前回のupdate()からの経過時間（delta_time）を計算
3. delta_timeを履歴に追加
4. サンプル数を超えたら最も古いデータを削除

**移動平均の利点:**
- 瞬間的なフレーム時間の変動を平滑化
- 安定した値を表示できる
- 一定期間の平均的なパフォーマンスを把握できる

### 3. getFps()メソッドの実装

```cpp
float getFps() const {
  if (frame_times_.empty()) {
    return 0.0f;
  }

  // 平均フレーム時間を計算
  Uint64 total = 0;
  for (Uint64 time : frame_times_) {
    total += time;
  }
  float avg_frame_time = static_cast<float>(total) / frame_times_.size();

  // FPSを計算（ミリ秒なので1000で割る）
  if (avg_frame_time <= 0.0f) {
    return 0.0f;
  }
  return 1000.0f / avg_frame_time;
}
```

**計算方法:**
1. 履歴の全フレーム時間を合計
2. サンプル数で割って平均フレーム時間を算出
3. `FPS = 1000 / 平均フレーム時間(ms)`で計算

**例:**
- 平均フレーム時間が16.67ms → FPS = 1000 / 16.67 ≒ 60.0
- 平均フレーム時間が33.33ms → FPS = 1000 / 33.33 ≒ 30.0

### 4. getAverageFrameTime()メソッドの実装

```cpp
float getAverageFrameTime() const {
  if (frame_times_.empty()) {
    return 0.0f;
  }

  Uint64 total = 0;
  for (Uint64 time : frame_times_) {
    total += time;
  }
  return static_cast<float>(total) / frame_times_.size();
}
```

**用途:**
- パフォーマンス分析
- ボトルネックの特定
- フレーム時間の変動を確認

### 5. TestImpl3での使用

**メンバ変数の追加:**
```cpp
class TestImpl3 final : public GameImpl {
 private:
  SDL_Renderer* renderer_ = nullptr;
  SDL_Texture* texture_ = nullptr;
  EntityManager entity_manager_;
  Uint64 last_time_;
  Uint64 spawn_timer_;
  Entity* player_ = nullptr;
  Utilities::FpsCounter fps_counter_;  // FPS計測
```

**update()での計測:**
```cpp
SDL_AppResult update() override {
  Uint64 current_time = SDL_GetTicks();
  Uint64 delta_time = current_time - last_time_;
  last_time_ = current_time;

  // FPS計測
  fps_counter_.update();

  // プレイヤー入力処理
  handlePlayerInput();

  // エンティティの更新
  entity_manager_.updateAll(delta_time);

  // ...
}
```

**FPS表示テキストの修正:**
```cpp
// 動的テキスト（FPS表示、UI要素として左上にアンカー）
static const UIAnchor top_left = UIAnchor::TopLeft;
auto fps_text = createTextEntity(
    10, 10, 30,
    [this]() {
      static char buffer[64];
      SDL_snprintf(buffer, sizeof(buffer), "FPS: %.1f (%.2fms)",
                   fps_counter_.getFps(),
                   fps_counter_.getAverageFrameTime());
      return std::string(buffer);
    },
    SDL_Color{255, 255, 255, 255}, &top_left);
```

**表示形式:**
- `FPS: 60.0 (16.67ms)` - FPS値と平均フレーム時間を両方表示
- 小数点1桁のFPS、小数点2桁のフレーム時間

### 6. 簡易的な計算との比較

**修正前（簡易計算）:**
```cpp
SDL_snprintf(buffer, sizeof(buffer), "FPS: ~%.0f",
             1000.0f / SDL_max(1, SDL_GetTicks() - last_time_));
```

**問題点:**
- 瞬間的な値のため表示が不安定
- 毎フレーム大きく変動する
- 正確な平均パフォーマンスが分からない

**修正後（移動平均）:**
```cpp
SDL_snprintf(buffer, sizeof(buffer), "FPS: %.1f (%.2fms)",
             fps_counter_.getFps(),
             fps_counter_.getAverageFrameTime());
```

**改善点:**
- 60フレーム分の平均で安定した表示
- 小数点表示で正確な値
- フレーム時間も表示してパフォーマンス分析が可能

## 移動平均のしくみ

### サンプル数60の場合

```
時間経過 →

フレーム:  1   2   3   ...  59  60  61  62
時間(ms): 16  17  16  ...  16  17  16  17
         ↓   ↓   ↓       ↓   ↓
         [---- 60フレーム ----]
                          ↓
                      平均を計算
```

61フレーム目では、1フレーム目を削除して61フレーム目を追加：

```
フレーム:  2   3   4   ...  60  61
時間(ms): 17  16  17  ...  17  16
         [---- 60フレーム ----]
                          ↓
                      平均を計算
```

**メリット:**
- 常に最新60フレームの平均を計算
- 古いデータは自動的に削除される
- 瞬間的な変動の影響を抑えられる

## std::dequeの使用理由

**std::deque（両端キュー）の特徴:**
- 先頭と末尾の追加・削除が高速（O(1)）
- ランダムアクセス可能
- メモリの連続性は保証されない

**FpsCounterでの使用:**
```cpp
frame_times_.push_back(delta_time);  // 末尾に追加 O(1)
frame_times_.pop_front();             // 先頭から削除 O(1)
```

**他のコンテナとの比較:**

| コンテナ | push_back | pop_front | 用途 |
|---------|-----------|-----------|------|
| std::vector | O(1) | O(n) | 先頭削除が遅い |
| std::deque | O(1) | O(1) | ✅ 移動平均に最適 |
| std::list | O(1) | O(1) | ランダムアクセスが遅い |

## パフォーマンス分析への活用

### FPS値から分かること

- **60 FPS**: 16.67ms/frame - 理想的なパフォーマンス
- **30 FPS**: 33.33ms/frame - 処理が重い
- **15 FPS**: 66.67ms/frame - パフォーマンス問題あり

### 平均フレーム時間から分かること

```
FPS: 58.5 (17.09ms)  ← 若干60FPSを下回っている
FPS: 30.2 (33.11ms)  ← 30FPS付近で安定
FPS: 25.8 (38.76ms)  ← 処理が重く、30FPSも維持できない
```

## 再利用性

このFpsCounterクラスは他のゲーム実装でも簡単に使えます：

### 使用例1: snake.h

```cpp
#include "../game_manager/utilities/fps_counter.h"

class Snake final : public GameImpl {
 private:
  Utilities::FpsCounter fps_counter_;

 public:
  SDL_AppResult update() override {
    fps_counter_.update();

    // FPS値を取得
    float fps = fps_counter_.getFps();

    // ... ゲームロジック
  }
};
```

### 使用例2: パフォーマンス監視

```cpp
void update() {
  fps_counter_.update();

  // 30FPS未満の場合は警告
  if (fps_counter_.getFps() < 30.0f) {
    SDL_Log("Warning: Low FPS: %.1f", fps_counter_.getFps());
  }
}
```

### 使用例3: サンプル数のカスタマイズ

```cpp
// より短い期間の平均（30フレーム）
Utilities::FpsCounter fps_counter_short(30);

// より長い期間の平均（120フレーム）
Utilities::FpsCounter fps_counter_long(120);
```

## ビルド結果

✅ ビルド成功
✅ FpsCounterクラス実装
✅ 安定したFPS表示
✅ 平均フレーム時間表示

## 表示例

実行すると、左上に以下のように表示されます：

```
FPS: 60.0 (16.67ms)  ← 60FPSで安定
```

または：

```
FPS: 59.8 (16.72ms)  ← ほぼ60FPS
```

処理が重い場合：

```
FPS: 30.2 (33.11ms)  ← 30FPS付近
```

## まとめ

FpsCounterクラスの実装により、以下が実現されました：

1. **正確なFPS計測**: 移動平均による安定した値
2. **再利用性**: 他のゲーム実装でも使える汎用クラス
3. **詳細な情報**: FPS値とフレーム時間の両方を表示
4. **パフォーマンス分析**: ゲームの重さを数値で把握できる

この機能は今後のゲーム開発やデバッグで非常に役立ちます。
