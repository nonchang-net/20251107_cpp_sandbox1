# 作業レポート - 2025/11/09 20:30

## 変更内容の概要

- プレイヤーキャラクターに向き情報を持たせ、向きに応じたスプライトアニメーションを実装しました
- 左右反転機能を実装し、左向きスプライトが未定義の場合は右向きを左右反転して表示できるようにしました
- 4方向（上下左右）のスプライトアニメーションを自動切り替えできるDirectionalSpriteAnimatorコンポーネントを追加しました

## 変更理由

- **向きの表現**: プレイヤーキャラクターの移動方向に応じて適切なスプライトを表示することで、より自然なゲーム表現が可能になる
- **再利用性**: 向きを持つコンポーネントとして実装することで、プレイヤー以外のNPCやエネミーにも適用できる
- **柔軟性**: 左向きスプライトが用意されていない場合でも、右向きを左右反転させることで対応できる設計

## 技術的な実装詳細

### 1. Direction enum と DirectionComponent の追加

**Direction enum (component.h:498-503):**

```cpp
enum class Direction {
  Down = 0,   // 下向き
  Up = 1,     // 上向き
  Right = 2,  // 右向き
  Left = 3    // 左向き
};
```

**DirectionComponent (component.h:511-534):**

```cpp
class DirectionComponent : public Component {
 public:
  explicit DirectionComponent(Direction direction = Direction::Down)
      : direction_(direction) {}

  void setDirection(Direction direction) { direction_ = direction; }
  Direction getDirection() const { return direction_; }

 private:
  Direction direction_;
};
```

**設計のポイント:**
- 向きを持たないエンティティにはコンポーネントを追加しない
- 初期値は下向き（Direction::Down）
- シンプルなgetter/setterで向きを管理

### 2. SpriteRenderer に左右反転機能を追加

**メンバ変数の追加 (component.h:603):**

```cpp
bool flip_horizontal_;  // 左右反転フラグ
```

**コンストラクタの変更 (component.h:552-555):**

```cpp
SpriteRenderer(SDL_Texture* texture, int tile_size, int tile_x = 0,
               int tile_y = 0, bool flip_horizontal = false)
    : texture_(texture), tile_size_(tile_size), tile_x_(tile_x),
      tile_y_(tile_y), flip_horizontal_(flip_horizontal) {}
```

**getter/setter (component.h:587-597):**

```cpp
void setFlipHorizontal(bool flip) { flip_horizontal_ = flip; }
bool isFlipHorizontal() const { return flip_horizontal_; }
```

**描画処理の変更 (entity_manager.h:957-965):**

```cpp
// テクスチャを描画（左右反転対応）
if (flip_horizontal_) {
  // 左右反転する場合、SDL_RenderTextureRotatedでSDL_FLIP_HORIZONTALを使用
  SDL_RenderTextureRotated(renderer, texture_, &src_rect, &dst_rect,
                            0.0, nullptr, SDL_FLIP_HORIZONTAL);
} else {
  SDL_RenderTexture(renderer, texture_, &src_rect, &dst_rect);
}
```

**SDL3での左右反転:**
- SDL3では`SDL_RenderTextureRotated()`を使用
- 第5引数: 回転角度（0.0 = 回転なし）
- 第6引数: 回転の中心点（nullptr = デフォルト）
- 第7引数: SDL_FLIP_HORIZONTAL（左右反転フラグ）

### 3. DirectionalSpriteAnimator コンポーネントの追加

**クラス定義 (component.h:612-654):**

```cpp
class DirectionalSpriteAnimator : public Component {
 public:
  DirectionalSpriteAnimator(
      const std::vector<std::pair<int, int>>& down_frames,
      const std::vector<std::pair<int, int>>& up_frames,
      const std::vector<std::pair<int, int>>& right_frames,
      const std::vector<std::pair<int, int>>& left_frames = {})
      : down_frames_(down_frames), up_frames_(up_frames),
        right_frames_(right_frames), left_frames_(left_frames),
        current_direction_(Direction::Down) {}

  void update(Entity* entity, Uint64 delta_time) override;

 private:
  std::vector<std::pair<int, int>> down_frames_;   // 下向きフレーム
  std::vector<std::pair<int, int>> up_frames_;     // 上向きフレーム
  std::vector<std::pair<int, int>> right_frames_;  // 右向きフレーム
  std::vector<std::pair<int, int>> left_frames_;   // 左向きフレーム（空なら右向きを反転）
  Direction current_direction_;  // 前回の向き（変化検出用）
};
```

**update()の実装 (entity_manager.h:970-1022):**

```cpp
inline void DirectionalSpriteAnimator::update(Entity* entity, Uint64 delta_time) {
  // DirectionComponentを取得
  auto* direction_comp = entity->getComponent<DirectionComponent>();
  if (!direction_comp) return;

  Direction new_direction = direction_comp->getDirection();

  // 向きが変わった場合のみ、フレームを切り替える
  if (new_direction != current_direction_) {
    current_direction_ = new_direction;

    auto* animator = entity->getComponent<SpriteAnimator>();
    auto* sprite_renderer = entity->getComponent<SpriteRenderer>();
    if (!animator) return;

    // 向きに応じてフレームを設定
    switch (new_direction) {
      case Direction::Down:
        animator->setFrames(down_frames_);
        if (sprite_renderer) {
          sprite_renderer->setFlipHorizontal(false);
        }
        break;
      case Direction::Up:
        animator->setFrames(up_frames_);
        if (sprite_renderer) {
          sprite_renderer->setFlipHorizontal(false);
        }
        break;
      case Direction::Right:
        animator->setFrames(right_frames_);
        if (sprite_renderer) {
          sprite_renderer->setFlipHorizontal(false);
        }
        break;
      case Direction::Left:
        if (left_frames_.empty()) {
          // 左向きフレームが未定義の場合、右向きを左右反転
          animator->setFrames(right_frames_);
          if (sprite_renderer) {
            sprite_renderer->setFlipHorizontal(true);
          }
        } else {
          // 左向きフレームが定義されている場合
          animator->setFrames(left_frames_);
          if (sprite_renderer) {
            sprite_renderer->setFlipHorizontal(false);
          }
        }
        break;
    }
  }
}
```

**処理の流れ:**

1. DirectionComponentから現在の向きを取得
2. 前回の向きと比較し、変化があった場合のみ処理
3. 向きに応じてSpriteAnimatorのフレームリストを切り替え
4. 左向きの場合：
   - left_frames_が空 → right_frames_を使用してflip_horizontal=true
   - left_frames_が定義済み → left_frames_を使用してflip_horizontal=false

**最適化ポイント:**
- 向きが変化したときのみフレームを切り替える（毎フレーム更新しない）
- current_direction_で前回の向きを記憶

### 4. プレイヤー入力処理の拡張

**handlePlayerInput()の修正 (test_impl_3.h:257-307):**

```cpp
void handlePlayerInput() {
  if (!player_) {
    SDL_Log("player not found.");
    return;
  }
  // VelocityMoveコンポーネントとDirectionコンポーネントを取得
  auto* velocity = player_->getComponent<VelocityMove>();
  auto* direction = player_->getComponent<DirectionComponent>();
  if (!velocity) return;

  // ポーズ中は入力を無効化
  if (current_timescale_ == 0.0f) {
    velocity->setVelocity(0.0f, 0.0f);
    return;
  }

  // キーボード状態を取得
  const bool* keys = SDL_GetKeyboardState(nullptr);

  // 移動速度（ピクセル/秒）
  const float speed = 180.0f;  // 60FPSで3ピクセル/フレーム相当

  // 移動方向を計算
  float vx = 0.0f;
  float vy = 0.0f;
  bool is_moving = false;

  if (keys[SDL_SCANCODE_UP] || keys[SDL_SCANCODE_W]) {
    vy -= speed;
    is_moving = true;
    if (direction) direction->setDirection(Direction::Up);
  }
  if (keys[SDL_SCANCODE_DOWN] || keys[SDL_SCANCODE_S]) {
    vy += speed;
    is_moving = true;
    if (direction) direction->setDirection(Direction::Down);
  }
  if (keys[SDL_SCANCODE_LEFT] || keys[SDL_SCANCODE_A]) {
    vx -= speed;
    is_moving = true;
    if (direction) direction->setDirection(Direction::Left);
  }
  if (keys[SDL_SCANCODE_RIGHT] || keys[SDL_SCANCODE_D]) {
    vx += speed;
    is_moving = true;
    if (direction) direction->setDirection(Direction::Right);
  }

  // 速度を設定
  velocity->setVelocity(vx, vy);
}
```

**変更点:**
- DirectionComponentを取得
- 各キー入力時に対応する向きを設定
- is_movingフラグを追加（将来的に停止時アニメーション制御に使用可能）

**注意点:**
- 複数キーが同時押しされた場合、最後に押されたキーの向きになる
- 斜め移動時の向きは、上下優先→左右の順で決定される

### 5. プレイヤーエンティティの初期化

**initializeEntities()の修正 (test_impl_3.h:408-439):**

```cpp
// レイヤー5: プレイヤーキャラクター
if (texture_) {
  auto player = std::make_unique<Entity>(5);
  player->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);

  // 座標・スケール
  player->addComponent(std::make_unique<Locator>(320.0f, 240.0f));
  player->addComponent(std::make_unique<Scaler>(4.0f, 4.0f));  // 8x8を32x32に拡大

  // 移動（入力処理はhandlePlayerInput()で行う）
  player->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));

  // 向き（初期は下向き）
  player->addComponent(std::make_unique<DirectionComponent>(Direction::Down));

  // スプライト描画（初期タイル: x=0, y=1）
  player->addComponent(std::make_unique<SpriteRenderer>(texture_, 8, 0, 1));

  // 向きごとのスプライトアニメーション
  std::vector<std::pair<int, int>> down_frames = {{0, 1}, {1, 1}};   // 下向き
  std::vector<std::pair<int, int>> up_frames = {{2, 1}, {3, 1}};     // 上向き
  std::vector<std::pair<int, int>> right_frames = {{4, 1}, {5, 1}};  // 右向き
  // 左向きは空（右向きを左右反転）

  player->addComponent(std::make_unique<SpriteAnimator>(down_frames, 500));
  player->addComponent(std::make_unique<DirectionalSpriteAnimator>(
      down_frames, up_frames, right_frames));

  // プレイヤーへの参照を保存してからEntityManagerに追加
  player_ = player.get();
  entity_manager_.addEntity(std::move(player));
}
```

**スプライトフレーム定義:**

| 向き | スプライト座標 | 説明 |
|------|--------------|------|
| 下向き | {{0,1}, {1,1}} | 2フレームアニメーション |
| 上向き | {{2,1}, {3,1}} | 2フレームアニメーション |
| 右向き | {{4,1}, {5,1}} | 2フレームアニメーション |
| 左向き | （空） | 右向きを左右反転 |

**コンポーネント構成:**
1. Locator: 座標管理
2. Scaler: 8x8ドットを32x32に拡大
3. VelocityMove: 移動速度
4. DirectionComponent: 向き管理
5. SpriteRenderer: スプライト描画（左右反転対応）
6. SpriteAnimator: フレームアニメーション
7. DirectionalSpriteAnimator: 向きごとのフレーム切り替え

### 6. コンポーネント更新順序

**Entity::updateWithChildren()での更新順 (entity_manager.h:353-368):**

```cpp
void updateWithChildren(Uint64 delta_time) {
  if (active_) {
    // 従来のupdate()を呼ぶ（後方互換性）
    update(delta_time);

    // 全コンポーネントのupdate()を呼ぶ
    for (auto& [type, component] : components_) {
      component->update(this, delta_time);
    }

    // 子エンティティも更新
    for (auto& child : children_) {
      child->updateWithChildren(delta_time);
    }
  }
}
```

**更新順序:**
1. VelocityMove::update() - 座標更新
2. DirectionalSpriteAnimator::update() - 向きに応じたフレーム切り替え
3. SpriteAnimator::update() - アニメーションフレーム進行

**注意点:**
- std::unordered_mapの順序は不定
- ただし、DirectionalSpriteAnimatorとSpriteAnimatorは独立しているため、順序に依存しない設計

### 7. 動作フロー

**プレイヤーが右に移動する場合:**

```
1. handlePlayerInput()
   - keys[SDL_SCANCODE_RIGHT]を検出
   - direction->setDirection(Direction::Right)
   - velocity->setVelocity(180.0f, 0.0f)

2. Entity::updateWithChildren()
   - VelocityMove::update()
     → 座標を更新

   - DirectionalSpriteAnimator::update()
     → Direction::Rightを検出
     → animator->setFrames(right_frames_) // {{4,1}, {5,1}}
     → sprite_renderer->setFlipHorizontal(false)
     → current_direction_ = Direction::Right

   - SpriteAnimator::update()
     → タイマー更新
     → 500msごとにフレーム切り替え
     → sprite_renderer->setTile(4, 1) or setTile(5, 1)

3. 描画
   - SpriteRenderer::render()
     → flip_horizontal_ = false
     → SDL_RenderTexture()で通常描画
```

**プレイヤーが左に移動する場合:**

```
1. handlePlayerInput()
   - keys[SDL_SCANCODE_LEFT]を検出
   - direction->setDirection(Direction::Left)
   - velocity->setVelocity(-180.0f, 0.0f)

2. Entity::updateWithChildren()
   - VelocityMove::update()
     → 座標を更新

   - DirectionalSpriteAnimator::update()
     → Direction::Leftを検出
     → left_frames_.empty() == true
     → animator->setFrames(right_frames_) // {{4,1}, {5,1}}（右向きと同じ）
     → sprite_renderer->setFlipHorizontal(true)  // 左右反転ON
     → current_direction_ = Direction::Left

   - SpriteAnimator::update()
     → タイマー更新
     → 500msごとにフレーム切り替え
     → sprite_renderer->setTile(4, 1) or setTile(5, 1)

3. 描画
   - SpriteRenderer::render()
     → flip_horizontal_ = true
     → SDL_RenderTextureRotated()で左右反転描画
```

## 設計のポイント

### 1. コンポーネントの責任分離

**DirectionComponent:**
- 向きの保持のみ
- ゲームロジック側で向きを設定

**DirectionalSpriteAnimator:**
- 向きに応じたフレーム切り替え
- 左右反転の制御

**SpriteAnimator:**
- フレームアニメーションの進行
- 向きには関与しない

**SpriteRenderer:**
- スプライトの描画
- 左右反転フラグに基づいて描画方法を変更

### 2. 左向きスプライトの柔軟な対応

**未定義の場合（今回）:**
- left_frames_を空のまま
- 右向きスプライトを左右反転

**定義済みの場合:**
- left_frames_にスプライト座標を設定
- 左右反転せずに描画

**利点:**
- スプライトが少ない場合でも対応可能
- 将来的に左向き専用スプライトを追加しても、コード変更不要

### 3. 向き変更の検出

```cpp
if (new_direction != current_direction_) {
  current_direction_ = new_direction;
  // フレーム切り替え処理
}
```

**最適化:**
- 向きが変わったときのみフレームを切り替える
- 毎フレーム無駄な処理をしない

## ビルド結果

✅ ビルド成功
✅ Directionコンポーネント実装
✅ DirectionalSpriteAnimator実装
✅ 左右反転機能実装
✅ プレイヤーの向き制御実装

## 動作確認

**期待される動作:**

1. **下向き（初期状態）:**
   - スプライト座標: {{0,1}, {1,1}}
   - 左右反転: なし

2. **上向き（↑キーまたはWキー）:**
   - スプライト座標: {{2,1}, {3,1}}
   - 左右反転: なし

3. **右向き（→キーまたはDキー）:**
   - スプライト座標: {{4,1}, {5,1}}
   - 左右反転: なし

4. **左向き（←キーまたはAキー）:**
   - スプライト座標: {{4,1}, {5,1}}（右向きと同じ）
   - 左右反転: **あり**

5. **アニメーション:**
   - 各向きで2フレームのアニメーション
   - 500msごとにフレームが切り替わる

## まとめ

向きごとのスプライトアニメーション機能の実装により、以下が実現されました：

1. **自然な移動表現**: プレイヤーの移動方向に応じた適切なスプライト表示
2. **柔軟な設計**: 左向きスプライトがなくても、右向きを反転して対応可能
3. **再利用性**: DirectionComponentとDirectionalSpriteAnimatorは、NPCやエネミーにも適用可能
4. **最適化**: 向きが変化したときのみフレームを切り替え、無駄な処理を削減

この機能は、今後のキャラクター実装の基礎となります。
