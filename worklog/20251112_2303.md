# 作業ログ: 2025-11-12 23:03

## 変更内容の概要

再現性の低いSegmentation Fault（終了時に発生）の原因を調査し、AudioMixerとBGMManagerのデストラクタにおける競合状態の問題を修正しました。BGMManagerに明示的なデストラクタを追加し、オーディオストリームを先に破棄してからBGMを破棄する順序に修正することで、オーディオコールバック実行中のダングリングポインタアクセスを防止しました。

## 変更理由

ユーザーがQキーで終了した際に稀にSegmentation Faultが発生する問題が報告されました。再現性が低いことから、タイミング依存の競合状態（オブジェクト破棄順序とマルチスレッド処理の競合）が疑われました。

SDL3のオーディオシステムは、オーディオコールバックを別スレッドで実行します。アプリケーション終了時、メインスレッドがオブジェクトを破棄している最中にオーディオスレッドがコールバックを実行すると、以下の問題が発生する可能性がありました：

1. **BGMManagerの破棄順序問題**: デフォルトデストラクタでは、メンバー変数が宣言と逆順に破棄されるため、`SDL_AudioStream*`が破棄される前に`bgm_map_`（MultiTrackSequencerを含む）が破棄される可能性がある
2. **ダングリングポインタ**: `fade_in_.bgm`と`fade_out_.bgm`は`bgm_map_`内のオブジェクトへの生ポインタであり、`bgm_map_`が破棄された後もコールバックがこれらにアクセスする可能性がある

## 主な変更ファイル

### 1. sound/sequencer/bgm_manager.h

**追加内容**: デストラクタ宣言

```cpp
/**
 * @brief デストラクタ
 *
 * オーディオストリームを停止してからBGMを破棄することで、
 * コールバック実行中のダングリングポインタアクセスを防ぎます。
 */
~BGMManager();
```

### 2. sound/sequencer/bgm_manager.cc

**追加内容**: デストラクタ実装

```cpp
BGMManager::~BGMManager() {
  // オーディオコールバックを停止するため、まずストリームを破棄
  if (stream_) {
    SDL_DestroyAudioStream(stream_);
    stream_ = nullptr;
  }

  // フェード状態の生ポインタをクリア（安全のため）
  fade_in_.bgm = nullptr;
  fade_out_.bgm = nullptr;

  // この後、デフォルトのデストラクタでbgm_map_が破棄される
}
```

**破棄順序の改善**:
1. `SDL_DestroyAudioStream(stream_)` → **オーディオコールバックを停止**
2. `fade_in_.bgm = nullptr` → ダングリングポインタ防止
3. `fade_out_.bgm = nullptr` → ダングリングポインタ防止
4. デフォルトのデストラクタで`bgm_map_`が破棄される → **安全に破棄**

### 3. sound/mixer/audio_mixer.cc

**改善内容**: デストラクタにポインタクリア処理を追加

```cpp
AudioMixer::~AudioMixer() {
  // オーディオコールバックを停止するため、まずストリームを破棄
  if (stream_) {
    SDL_DestroyAudioStream(stream_);
    stream_ = nullptr;
  }

  // シンセサイザーへの生ポインタをクリア（安全のため）
  synthesizers_.clear();
}
```

## 問題の詳細分析

### BGMManagerの破棄順序問題

**メンバー変数の宣言順（bgm_manager.h:130-140）**:
```cpp
std::unordered_map<std::string, std::unique_ptr<MultiTrackSequencer>> bgm_map_;
SDL_AudioStream* stream_;
std::string current_bgm_id_;
float master_volume_;
int sample_rate_;
FadeState fade_in_;   // bgm_map_へのポインタを持つ
FadeState fade_out_;  // bgm_map_へのポインタを持つ
```

**デフォルトデストラクタの破棄順序（宣言の逆順）**:
1. `fade_out_` → `fade_out_.bgm`（生ポインタ）がダングリングになる直前
2. `fade_in_` → `fade_in_.bgm`（生ポインタ）がダングリングになる直前
3. その他のメンバー
4. `stream_` → **ここでコールバックが停止**
5. `bgm_map_` → MultiTrackSequencerが削除される

**問題**: `stream_`が破棄される前に、コールバック（別スレッド）が`fade_in_.bgm`や`fade_out_.bgm`にアクセスする可能性があり、これらは既に無効なポインタになっている可能性がある。

### 競合状態のシナリオ

```
メインスレッド（破棄中）         オーディオスレッド（コールバック実行中）
------------------------         --------------------------------
fade_out_破棄開始
                                 audioCallback()実行
                                 ↓
                                 mixSamples()呼び出し
                                 ↓
fade_in_破棄完了                  if (fade_in_.is_fading && fade_in_.bgm) {
（fade_in_.bgmは未初期化値）          fade_in_.bgm->generateSamples(...);  ← ダングリングポインタアクセス！
                                 }
                                 ↓
stream_破棄開始                   クラッシュ（Segmentation Fault）
```

### 修正後の動作

```
メインスレッド（破棄中）         オーディオスレッド
------------------------         --------------------------------
stream_破棄開始                   コールバック停止（SDL内部で処理）
↓
stream_破棄完了
↓
fade_in_.bgm = nullptr
fade_out_.bgm = nullptr
↓
bgm_map_破棄開始
↓
bgm_map_破棄完了
                                 コールバックは実行されない
```

## MultiTrackSequencerの破棄順序（参考情報）

MultiTrackSequencerのメンバー変数宣言順：
```cpp
std::vector<std::unique_ptr<SimpleSynthesizer>> synthesizers_;  // 宣言順: 6
std::vector<std::unique_ptr<Sequencer>> sequencers_;           // 宣言順: 7
std::unique_ptr<AudioMixer> mixer_;                            // 宣言順: 8
```

**破棄順序（宣言の逆順）**:
1. `mixer_` → `SDL_AudioStream`破棄、コールバック停止
2. `sequencers_` → Sequencerが持つ`synthesizers_`への生ポインタが無効化
3. `synthesizers_` → SimpleSynthesizerが削除される

この順序は**安全**です。`mixer_`が先に破棄され、コールバックが停止した後に`synthesizers_`が破棄されるため、ダングリングポインタアクセスは発生しません。

もし`synthesizers_`が先に破棄されると、`mixer_`のコールバックが`synthesizers_`にアクセスしようとしてSegmentation Faultが発生する可能性がありますが、現在の宣言順序では問題ありません。

## その他の確認事項

### GameManagerの所有権管理
- `GameManager`は`std::unique_ptr`で適切に管理されている
- `AppState`のデストラクタで明示的に破棄されている
- 問題なし

### Sequencerの生ポインタ
- `Sequencer`は`SimpleSynthesizer*`の生ポインタを保持
- `MultiTrackSequencer`で所有権が管理されており、破棄順序が適切
- 問題なし

### game.ccのコメント誤り（軽微）
```cpp
// game.cc:124
// note: placement newで構築したので明示的にデストラクタを呼ぶ
as->~AppState();
```

**問題**: コメントが誤っている。`SDL_calloc`で構築しているため、placement newではない。
**影響**: コメントのみの誤りで、実装は正しい。デストラクタの明示的呼び出しは適切。

## 教訓

### 1. マルチスレッド環境でのデストラクタ設計
- オーディオコールバックは別スレッドで実行されるため、デストラクタでは必ずストリームを先に破棄してコールバックを停止する
- 破棄順序が重要な場合は、デフォルトデストラクタに頼らず明示的なデストラクタを実装する

### 2. 生ポインタの危険性
- 生ポインタはダングリングポインタになる可能性があるため、所有権が明確でない場合は使用を避ける
- やむを得ず使用する場合は、デストラクタでnullptrを設定して安全性を高める

### 3. メンバー変数の宣言順序
- C++のデストラクタはメンバー変数を宣言と逆順に破棄する
- 依存関係がある場合、宣言順序を考慮する（依存される側を先に宣言）
- 複雑な依存関係がある場合は、明示的なデストラクタで順序を制御する

### 4. 再現性の低いバグのデバッグ
- タイミング依存の問題は、競合状態を疑う
- スレッド間の相互作用を図示して理解する
- 破棄順序とオブジェクトのライフサイクルを明確にする

## ビルド結果

```bash
cmake --build build
```

**結果**: ✅ ビルド成功（エラー・警告なし）

## テスト結果

アプリケーションを複数回起動・終了してテストしましたが、Segmentation Faultは発生しませんでした。ただし、再現性が低い問題のため、完全に解決したかは継続的なテストが必要です。

## まとめ

BGMManagerとAudioMixerのデストラクタを改善し、オーディオコールバック実行中のダングリングポインタアクセスを防止しました。この修正により、アプリケーション終了時の競合状態が解消され、Segmentation Faultの発生リスクが大幅に低減されました。

**主な成果**:
1. **BGMManagerのデストラクタ追加**: ストリームを先に破棄してコールバックを停止
2. **ダングリングポインタ防止**: 生ポインタをnullptrに設定
3. **AudioMixerのデストラクタ改善**: シンセサイザーポインタをクリア
4. **破棄順序の明確化**: デストラクタでの明示的な順序制御

**補足**:
- SDL側の問題の可能性も完全には排除できないが、現時点で発見された問題はすべて修正済み
- 今回の精査により、コードベース全体の安全性が向上
