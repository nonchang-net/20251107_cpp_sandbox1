# 20251111_0200 - AudioMixer実装とマルチトラックシーケンサーのミキサー統合

## 変更内容の概要

- SimpleSynthesizerにストリームなしモード（サンプル生成のみ）を追加し、ミキサー経由での使用を可能に
- AudioMixerクラスを新規作成し、複数のシンセサイザーをミックスしてエフェクトを適用する機能を実装
- MultiTrackSequencerをAudioMixer使用に変更し、全トラックのサブミックス後にマスターエフェクトを適用できるように改修

## 変更理由

従来のMultiTrackSequencerは、各トラックのSynthesizerが個別にSDL_AudioStreamを持っていたため、複数のオーディオストリームが並列に動作する設計でした。この設計では、全トラックをミックスした後にマスターエフェクト（リバーブ、コンプレッサーなど）を適用することができませんでした。

今回、ミキサーの概念を導入し、以下のような処理フローを実現しました：
1. 各トラックのSynthesizerはストリームなしモードでサンプル生成のみを行う
2. AudioMixerが各Synthesizerからサンプルを取得してミックス（サブミックス）
3. ミックス後のサンプルにマスターエフェクトチェーンを適用
4. AudioMixerが持つ単一のSDL_AudioStreamから最終的な音声を出力

これにより、マスタリング処理やミックス全体に対するエフェクト処理が可能になりました。

## 修正・作成したファイル

### 1. sound/core/synthesizer.h

**変更内容**: ストリームなしモードのサポート

```cpp
// コンストラクタにenable_streamパラメータを追加
explicit SimpleSynthesizer(int sample_rate = DEFAULT_SAMPLE_RATE, bool enable_stream = true);

// generateSamplesメソッドをpublicに移動（ミキサーから呼び出すため）
/**
 * @brief サンプルを生成（ミキサー用）
 *
 * この関数は主にAudioMixerから呼ばれることを想定しています。
 * ストリームなしモードで作成されたSynthesizerの場合、
 * この関数を明示的に呼び出してサンプルを取得します。
 */
void generateSamples(float* samples, int num_samples);
```

**設計のポイント**:
- `enable_stream=true` (デフォルト): 従来通り単体で動作（SDL_AudioStream所有）
- `enable_stream=false`: サンプル生成のみ（ミキサー経由での使用を想定）
- 既存コードとの互換性を維持（デフォルト引数）

### 2. sound/core/synthesizer.cc

**変更内容**: ストリームなしモード時の初期化処理

```cpp
SimpleSynthesizer::SimpleSynthesizer(int sample_rate, bool enable_stream)
    : /* ... */ {

  // ストリームありモードの場合のみオーディオストリームを初期化
  if (enable_stream) {
    // SDL_AudioStreamの初期化処理
    // ...
  } else {
    SYNTH_LOG("SimpleSynthesizer created in stream-less mode (sample generation only)");
  }
}
```

**動作モード**:
- ストリームありモード: 独立したオーディオ出力を持つ（従来の動作）
- ストリームなしモード: サンプル生成のみ、AudioMixerが出力を管理

### 3. sound/mixer/audio_mixer.h (新規作成)

**概要**: 複数のシンセサイザーをミックスしてエフェクトを適用するクラス

```cpp
namespace MySound {

/**
 * @brief オーディオミキサー
 *
 * 複数のSimpleSynthesizerからサンプルを取得してミックスし、
 * エフェクトチェーンを適用してからオーディオデバイスに出力します。
 */
class AudioMixer {
 public:
  explicit AudioMixer(int sample_rate = DEFAULT_SAMPLE_RATE);
  ~AudioMixer();

  // シンセサイザー管理
  void addSynthesizer(SimpleSynthesizer* synth);
  void clearSynthesizers();
  size_t getSynthesizerCount() const;

  // エフェクト管理（SimpleSynthesizerと同様のAPI）
  void addEffect(std::unique_ptr<AudioEffect> effect);
  void clearEffects();
  size_t getEffectCount() const;

  // ボリューム管理
  void setVolume(float volume);
  float getVolume() const;

  int getSampleRate() const;

 private:
  static void SDLCALL audioCallback(void* userdata, SDL_AudioStream* stream,
                                    int additional_amount, int total_amount);
  void mixSamples(float* output, int num_samples);

  std::vector<SimpleSynthesizer*> synthesizers_;       // 参照のみ（所有権なし）
  std::vector<std::unique_ptr<AudioEffect>> effects_;  // エフェクトチェーン
  SDL_AudioStream* stream_;                            // 唯一のオーディオストリーム
  int sample_rate_;
  float master_volume_;
};

}  // namespace MySound
```

**設計のポイント**:
- **シンセサイザー管理**: ポインタのみ保持（所有権は外部）
- **エフェクト管理**: SimpleSynthesizerと同様のAPI（統一性）
- **単一ストリーム**: AudioMixerのみがSDL_AudioStreamを所有
- **ミキシング処理**: 各Synthesizerからサンプルを取得して加算合成

### 4. sound/mixer/audio_mixer.cc (新規作成)

**主要メソッドの実装**:

**mixSamples()** - ミキシングとエフェクト適用
```cpp
void AudioMixer::mixSamples(float* output, int num_samples) {
  // 1. 出力バッファを初期化（無音）
  SDL_memset(output, 0, num_samples * sizeof(float));

  // 2. 各シンセサイザーからサンプルを取得してミックス
  float* temp_buffer = new float[num_samples];
  for (auto* synth : synthesizers_) {
    if (synth) {
      synth->generateSamples(temp_buffer, num_samples);

      // 加算ミックス
      for (int i = 0; i < num_samples; ++i) {
        output[i] += temp_buffer[i];
      }
    }
  }
  delete[] temp_buffer;

  // 3. マスターボリュームとエフェクトチェーンを適用
  for (int i = 0; i < num_samples; ++i) {
    output[i] *= master_volume_;

    // エフェクトチェーン（追加順に処理）
    for (auto& effect : effects_) {
      output[i] = effect->process(output[i]);
    }

    // クリッピング防止
    if (output[i] > 1.0f) output[i] = 1.0f;
    if (output[i] < -1.0f) output[i] = -1.0f;
  }
}
```

**処理フロー**:
1. 各Synthesizerからサンプルを生成
2. サンプルを加算ミックス（サブミックス）
3. マスターボリューム適用
4. エフェクトチェーン適用
5. クリッピング防止

### 5. sound/sequencer/multi_track_sequencer.h

**変更内容**: AudioMixerの統合とマスターエフェクトAPI追加

```cpp
#include "../mixer/audio_mixer.h"
#include "../effect/audio_effect.h"

class MultiTrackSequencer {
 public:
  // ... 既存メソッド ...

  // マスターエフェクト管理（新規追加）
  void addMasterEffect(std::unique_ptr<AudioEffect> effect);
  void clearMasterEffects();
  size_t getMasterEffectCount() const;
  AudioMixer* getMixer();

 private:
  // ... 既存メンバー ...
  std::unique_ptr<AudioMixer> mixer_;  // AudioMixerを追加
};
```

**API設計**:
- `addMasterEffect()`: マスターエフェクトを追加（AudioMixerに委譲）
- `clearMasterEffects()`: 全マスターエフェクトを削除
- `getMixer()`: AudioMixerへの直接アクセス（高度な設定用）

### 6. sound/sequencer/multi_track_sequencer.cc

**変更内容**: コンストラクタとボリューム設定の修正

**コンストラクタ**:
```cpp
MultiTrackSequencer::MultiTrackSequencer(size_t track_count, int sample_rate, float bpm)
    : track_count_(track_count),
      bpm_(bpm),
      master_volume_(1.0f),
      is_paused_(false),
      mixer_(std::make_unique<AudioMixer>(sample_rate)) {  // ミキサー作成

  for (size_t i = 0; i < track_count; ++i) {
    // ストリームなしモードで作成（enable_stream=false）
    auto synth = std::make_unique<SimpleSynthesizer>(sample_rate, false);
    auto seq = std::make_unique<Sequencer>(synth.get(), bpm);

    // ミキサーにシンセサイザーを登録
    mixer_->addSynthesizer(synth.get());

    synthesizers_.push_back(std::move(synth));
    sequencers_.push_back(std::move(seq));
  }

  mixer_->setVolume(master_volume_);
}
```

**変更前との違い**:
- 変更前: `SimpleSynthesizer(sample_rate)` - 各トラックが独立したストリーム
- 変更後: `SimpleSynthesizer(sample_rate, false)` - ストリームなし、ミキサー経由

**マスターボリューム設定**:
```cpp
// 変更前
void MultiTrackSequencer::setMasterVolume(float volume) {
  master_volume_ = SDL_clamp(volume, 0.0f, 1.0f);
  for (auto& synth : synthesizers_) {
    synth->setVolume(master_volume_);  // 各Synthesizerに個別設定
  }
}

// 変更後
void MultiTrackSequencer::setMasterVolume(float volume) {
  master_volume_ = SDL_clamp(volume, 0.0f, 1.0f);
  mixer_->setVolume(master_volume_);  // ミキサーに一括設定
}
```

**エフェクト関連メソッド**:
```cpp
void MultiTrackSequencer::addMasterEffect(std::unique_ptr<AudioEffect> effect) {
  mixer_->addEffect(std::move(effect));
}

void MultiTrackSequencer::clearMasterEffects() {
  mixer_->clearEffects();
}

size_t MultiTrackSequencer::getMasterEffectCount() const {
  return mixer_->getEffectCount();
}

AudioMixer* MultiTrackSequencer::getMixer() {
  return mixer_.get();
}
```

### 7. CMakeLists.txt

**変更内容**: audio_mixer.ccの追加

```cmake
# sound library (Phase 2: core classes + sequencer + effect + mixer)
set(SOUND_SOURCES
    sound/core/oscillator.cc
    sound/core/envelope.cc
    sound/core/synthesizer.cc
    sound/sequencer/sequencer.cc
    sound/sequencer/multi_track_sequencer.cc
    sound/sequencer/bgm_manager.cc
    sound/effect/biquad_filter.cc
    sound/effect/volume_modulation.cc
    sound/mixer/audio_mixer.cc  # 追加
)
```

### 8. sound/sound.h

**変更内容**: audio_mixer.hのインクルード追加

```cpp
// ミキサー
#include "mixer/audio_mixer.h"
```

## 使用例

### 基本的な使い方（MultiTrackSequencerでマスターエフェクトを使用）

```cpp
#include "sound/sound.h"

using namespace MySound;

// マルチトラックシーケンサーを作成（3トラック）
auto multi_track = std::make_unique<MultiTrackSequencer>(3, 44100, 120.0f);

// 各トラックにシーケンスを設定
multi_track->setTrackSequence(0, melody_notes);
multi_track->setTrackSequence(1, bass_notes);
multi_track->setTrackSequence(2, drum_notes);

// マスターエフェクトを追加（全トラックのミックス後に適用）
auto master_filter = std::make_unique<BiquadFilter>(44100);
master_filter->setType(BiquadFilterType::Lowpass);
master_filter->setFrequency(8000.0f);
multi_track->addMasterEffect(std::move(master_filter));

auto master_tremolo = std::make_unique<VolumeModulation>(44100);
master_tremolo->setRate(2.0f);
master_tremolo->setDepth(0.3f);
multi_track->addMasterEffect(std::move(master_tremolo));

// 再生開始
multi_track->play();
```

### AudioMixerを直接使用する場合

```cpp
// ストリームなしモードでシンセサイザーを作成
auto synth1 = std::make_unique<SimpleSynthesizer>(44100, false);
auto synth2 = std::make_unique<SimpleSynthesizer>(44100, false);
auto synth3 = std::make_unique<SimpleSynthesizer>(44100, false);

// 各シンセサイザーの設定
synth1->getOscillator().setWaveType(WaveType::Sine);
synth2->getOscillator().setWaveType(WaveType::Square);
synth3->getOscillator().setWaveType(WaveType::Sawtooth);

// ミキサーを作成
auto mixer = std::make_unique<AudioMixer>(44100);

// シンセサイザーを登録
mixer->addSynthesizer(synth1.get());
mixer->addSynthesizer(synth2.get());
mixer->addSynthesizer(synth3.get());

// マスターエフェクトを追加
auto reverb = std::make_unique<ReverbEffect>(44100);
mixer->addEffect(std::move(reverb));

// 各シンセサイザーで音を鳴らす
synth1->noteOn(440.0f, 1.0f);  // A4
synth2->noteOn(554.37f, 1.0f); // C#5
synth3->noteOn(659.25f, 1.0f); // E5

// ミキサーが自動的にミックスして出力
```

## アーキテクチャの変更

### 変更前: 各トラックが独立したオーディオストリーム

```
Track 1: Synthesizer → SDL_AudioStream → Audio Device
Track 2: Synthesizer → SDL_AudioStream → Audio Device
Track 3: Synthesizer → SDL_AudioStream → Audio Device
```

**問題点**:
- 複数のオーディオストリームが並列動作
- トラック間のミックスを制御できない
- 全体に対するマスターエフェクトを適用できない

### 変更後: AudioMixerによる統合ミキシング

```
Track 1: Synthesizer (stream-less) ┐
Track 2: Synthesizer (stream-less) ├→ AudioMixer → Effects → SDL_AudioStream → Audio Device
Track 3: Synthesizer (stream-less) ┘     (Sub-Mix)   (Master)
```

**利点**:
- 単一のオーディオストリームで効率的
- サブミックス後にマスターエフェクトを適用可能
- ミックスバランスの制御が容易
- リソース使用量の削減

## 処理フローの詳細

### AudioMixerのオーディオコールバック処理

1. **コールバック開始**
   - SDL_AudioStreamから要求されたサンプル数を受信

2. **サンプル生成とミキシング** (`mixSamples()`)
   - 出力バッファを初期化（無音）
   - 各Synthesizerに対して:
     - `generateSamples()`を呼び出してサンプル生成
     - 生成されたサンプルを出力バッファに加算
   - 結果: 全トラックがミックスされたサブミックス

3. **マスター処理**
   - マスターボリューム適用
   - エフェクトチェーン適用（追加順に直列処理）
   - クリッピング防止（-1.0〜1.0に制限）

4. **出力**
   - 処理済みサンプルをSDL_AudioStreamに送信
   - オーディオデバイスへ出力

## 将来の拡張可能性

### Phase 1（今回の実装）: 基本的なミキシングとマスターエフェクト
- ✅ 複数トラックのサブミックス
- ✅ マスターエフェクトチェーン
- ✅ マスターボリューム制御

### Phase 2（将来の拡張）: 高度なミキシング機能

**トラック別ボリューム・パン**:
```cpp
class AudioMixer {
  struct TrackSettings {
    SimpleSynthesizer* synth;
    float volume;  // 0.0〜1.0
    float pan;     // -1.0(左) 〜 0.0(中央) 〜 1.0(右)
  };
  std::vector<TrackSettings> tracks_;
};
```

**センド/リターン（Send/Return）エフェクト**:
```cpp
// ドライ音とウェット音のミックス比率を調整
auto send = mixer->createSendEffect(reverb, 0.3f);  // 30%のリバーブ
```

**マルチチャンネル対応**:
```cpp
// ステレオ出力
AudioMixer(sample_rate, 2);  // 2チャンネル
```

**サイドチェイン**:
```cpp
// トラック1の音量に応じてトラック2の音量を調整（コンプレッサーのサイドチェイン）
mixer->setSidechain(1, 2, compressor);
```

## パフォーマンスへの影響

### メモリ使用量
- **変更前**: トラック数 × SDL_AudioStream（各数KB）
- **変更後**: 1つのSDL_AudioStream + 一時バッファ（数KB）
- **影響**: メモリ使用量が削減

### CPU使用量
- **ミキシング処理**: 各トラックからサンプル生成 + 加算処理
- **影響**: トラック数に比例して増加するが、許容範囲内

### レイテンシ
- **変更なし**: 単一のオーディオストリームで処理されるため、レイテンシは変わらず

## ビルド結果

```bash
cmake --build build
```

**結果**: ✅ ビルド成功（エラーなし）

## まとめ

MultiTrackSequencerにミキサーの概念を導入し、以下を実現しました：

1. **SimpleSynthesizer**: ストリームなしモード追加により、ミキサー経由での使用が可能に
2. **AudioMixer**: 複数のシンセサイザーをミックスしてエフェクトを適用する統合ミキサーを実装
3. **MultiTrackSequencer**: AudioMixer使用により、サブミックス→マスターエフェクト適用の流れを実現

これにより、マスタリング処理やミックス全体に対するエフェクト処理が可能になり、より本格的な音楽制作・ゲームオーディオ処理が実現できるようになりました。
