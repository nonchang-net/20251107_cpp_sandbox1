# 作業レポート - 2025/11/10 01:00

## 変更内容の概要

- シンセサイザーのノイズ問題を解決しました
- SDL3のストリーム方式からコールバック方式に変更しました
- SDL_INIT_AUDIOフラグの追加により、オーディオサブシステムを正しく初期化しました

## なぜこのように変更したか

- **ノイズの原因**: メインループからSDL_PutAudioStreamData()を呼び出すストリーム方式では、フレームレートの不安定さやタイミングのずれにより、バッファアンダーラン（データ不足）が発生し、ノイズが乗っていました
- **コールバック方式の利点**: SDL3のサンプルコード（example_simple_playback.c）と同様に、バックグラウンドスレッドから自動的にコールバックが呼び出される方式に変更することで、オーディオシステムが必要なタイミングで正確にデータを供給できます
- **安定した音質**: オーディオ専用のスレッドで処理されるため、メインループのフレームレートに依存せず、一定のタイミングでサンプル生成が行われます

## 技術的な実装詳細

### 1. SDL_Init()にSDL_INIT_AUDIOフラグを追加

**問題:**
最初の実装では、オーディオストリームの初期化が失敗していました。

**原因:**
game.ccのSDL_Init()でSDL_INIT_AUDIOフラグが指定されていなかったため、オーディオサブシステムが初期化されていませんでした。

**修正（game.cc:34）:**
```cpp
// 修正前
if (!SDL_Init(SDL_INIT_VIDEO | SDL_INIT_JOYSTICK)) {

// 修正後
if (!SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_JOYSTICK)) {
```

**エラーログ:**
```
ERROR: Audio stream not initialized
```

この修正により、オーディオストリームが正常に初期化されるようになりました。

### 2. コールバック方式への変更

#### 2.1 SDL_OpenAudioDeviceStreamの呼び出し方法を変更

**修正前（ストリーム方式）:**
```cpp
stream_ = SDL_OpenAudioDeviceStream(
    SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK,
    &spec,
    nullptr,  // コールバックなし
    nullptr); // ユーザーデータなし
```

**修正後（コールバック方式）:**
```cpp
stream_ = SDL_OpenAudioDeviceStream(
    SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK,
    &spec,
    audioCallback,  // コールバック関数を指定
    this);          // ユーザーデータ（SimpleSynthesizerのインスタンス）
```

**重要なポイント:**
- 第3引数にコールバック関数を指定
- 第4引数にthis（SimpleSynthesizerのインスタンスポインタ）を渡す
- コールバックはバックグラウンドスレッドから自動的に呼び出される

#### 2.2 audioCallback()静的関数の追加

**実装（sound_synthesizer.h:321-350）:**
```cpp
/**
 * @brief オーディオコールバック（静的関数、バックグラウンドスレッドから呼び出される）
 * @param userdata SimpleSynthesizerのインスタンスポインタ
 * @param stream オーディオストリーム
 * @param additional_amount 追加で必要なバイト数
 * @param total_amount 合計で必要なバイト数
 */
static void SDLCALL audioCallback(void* userdata, SDL_AudioStream* stream,
                                   int additional_amount, int total_amount) {
  SimpleSynthesizer* synth = static_cast<SimpleSynthesizer*>(userdata);

  // 再生中でない場合は無音を出力
  if (!synth->is_playing_) {
    // 無音データを送信
    int samples_needed = additional_amount / sizeof(float);
    if (samples_needed > 0) {
      float* silence = new float[samples_needed];
      SDL_memset(silence, 0, additional_amount);
      SDL_PutAudioStreamData(stream, silence, additional_amount);
      delete[] silence;
    }
    return;
  }

  // 必要なサンプル数を計算
  int samples_needed = additional_amount / sizeof(float);
  if (samples_needed <= 0) return;

  // サンプルを生成
  float* samples = new float[samples_needed];
  synth->generateSamples(samples, samples_needed);

  // ストリームにデータを送信
  SDL_PutAudioStreamData(stream, samples, additional_amount);

  delete[] samples;
}
```

**コールバックの動作:**

1. **呼び出しタイミング**: オーディオシステムがデータを必要とするタイミングで自動的に呼び出される
2. **スレッド**: バックグラウンドスレッドから実行される（メインループとは独立）
3. **再生状態チェック**: is_playing_フラグで再生中かどうかを判定
4. **無音出力**: 再生中でない場合は、無音データ（ゼロ）を送信してバッファを埋める
5. **サンプル生成**: 再生中の場合は、generateSamples()を呼び出して波形データを生成
6. **データ送信**: SDL_PutAudioStreamData()でストリームにデータを送信

**重要な設計判断:**
- コールバック関数は静的関数（static）である必要がある（Cのコールバック規約）
- userdataパラメータでインスタンスポインタを受け取り、メンバ関数を呼び出す
- new/deleteで動的にメモリ確保（スタックオーバーフロー防止）

#### 2.3 update()の簡略化

**修正前:**
```cpp
void update() {
  if (!stream_ || !is_playing_) return;

  // バッファの状態を確認
  int queued = SDL_GetAudioStreamQueued(stream_);
  const int min_buffer_bytes = sample_rate_ * sizeof(float) / 2;

  if (queued < min_buffer_bytes) {
    // バッファが少なくなったらサンプルを生成
    const int samples_to_generate = 512;
    float samples[samples_to_generate];
    generateSamples(samples, samples_to_generate);
    SDL_PutAudioStreamData(stream_, samples, sizeof(samples));
  }

  // 自動ノートオフ（duration指定がある場合）
  // ...
}
```

**修正後:**
```cpp
void update() {
  if (!is_playing_) return;

  // 自動ノートオフ（duration指定がある場合）
  if (gate_ && note_duration_ > 0.0f) {
    float current_time = getCurrentTime();
    if (current_time >= note_duration_) {
      noteOff();
    }
  }

  // Releaseフェーズ完了チェック（エンベロープが0になったら停止）
  if (!gate_) {
    float current_time = getCurrentTime();
    float envelope_value = envelope_->process(current_time, gate_, note_off_time_);
    if (envelope_value <= 0.0f) {
      is_playing_ = false;
      SDL_Log("Sound finished (envelope reached 0)");
    }
  }
}
```

**変更点:**
- サンプル生成処理を削除（コールバック側で自動的に行われる）
- 状態管理のみを行う（自動ノートオフ、再生終了判定）
- メインループからはis_playing_フラグの更新のみ

### 3. エンベロープパラメータの調整

ノイズ軽減のため、エンベロープパラメータを調整しました。

**修正（test_impl_3.h:165-168）:**
```cpp
// エンベロープを設定（ノイズ軽減のためAttackを長めに）
synthesizer_->getEnvelope().setAttackTime(0.05f);   // 0.01→0.05に変更
synthesizer_->getEnvelope().setDecayTime(0.1f);
synthesizer_->getEnvelope().setSustainLevel(0.7f);  // 0.5→0.7に変更
synthesizer_->getEnvelope().setReleaseTime(0.15f);  // 0.1→0.15に変更
```

**変更理由:**
- **Attack時間の延長**: 0.01秒 → 0.05秒に変更し、立ち上がりを緩やかにしてクリックノイズを軽減
- **Sustainレベルの増加**: 0.5 → 0.7に変更し、音量を安定化
- **Release時間の延長**: 0.1秒 → 0.15秒に変更し、音の終わりを滑らかに

### 4. エンベロープ計算の改善

ゼロ除算対策を追加しました。

**修正（sound_synthesizer.h:142-152）:**
```cpp
float process(float time, bool gate, float note_off_time = 0.0f) const {
  if (gate) {
    // ノートオン中
    if (attack_time_ > 0.0f && time < attack_time_) {
      // Attack フェーズ: 0.0 → 1.0
      return time / attack_time_;
    } else if (decay_time_ > 0.0f && time < attack_time_ + decay_time_) {
      // Decay フェーズ: 1.0 → sustain_level
      float decay_progress = (time - attack_time_) / decay_time_;
      return 1.0f - (1.0f - sustain_level_) * decay_progress;
    } else {
      // Sustain フェーズ: sustain_level を維持
      return sustain_level_;
    }
  } else {
    // Release フェーズ
    // ...
  }
}
```

**変更点:**
- 各フェーズで時間パラメータがゼロでないことを確認（`attack_time_ > 0.0f`など）
- ゼロ除算を防止し、安定した動作を保証

### 5. デバッグログの改善

各ノートの最初のサンプルを詳細にログ出力できるようにしました。

**追加メンバ変数:**
```cpp
bool debug_first_samples_;  // デバッグ用：最初のサンプルをログ出力
```

**noteOn()で有効化:**
```cpp
void noteOn(float frequency, float duration = 0.0f) {
  // ...
  debug_first_samples_ = true;  // デバッグログを有効化
  SDL_Log("NoteOn: %.2f Hz, duration: %.2f sec, stream=%p", frequency, duration, stream_);
}
```

**generateSamples()でログ出力:**
```cpp
// 最初の数サンプルをログ出力（デバッグ用）
if (debug_first_samples_ && i < 10) {
  SDL_Log("Sample[%d]: time=%.6f, env=%.4f, phase=%.4f, wave=%.4f, output=%.4f",
          i, current_time, envelope_value, phase, wave, samples[i]);
}
```

これにより、問題が発生した場合に詳細な診断が可能になりました。

### 6. オシレーター切り替え機能の追加（ユーザー実装）

ユーザーがtest_impl_3.hに、Oキーでオシレーターを切り替える機能を追加しました。

**追加されたコード（test_impl_3.h:143, 286-299）:**
```cpp
// メンバ変数
WaveType ocillatorWaveType_ = WaveType::Sine;

// Oキーのハンドラ
case SDL_SCANCODE_O: {
  // オシレータ切り替え
  switch(ocillatorWaveType_){
    case WaveType::Sine:
      ocillatorWaveType_ = WaveType::Square;
      break;
    case WaveType::Square:
      ocillatorWaveType_ = WaveType::Sawtooth;
      break;
    default:
      ocillatorWaveType_ = WaveType::Sine;
  }
  break;
}
```

**使い方:**
- **Oキー**: サイン波 → 矩形波 → ノコギリ波 の順で切り替え
- 各数字キー（1〜8）や、Enterキーでのメロディー再生時に、現在のオシレーター設定が使用される

## ストリーム方式 vs コールバック方式の比較

| 項目 | ストリーム方式 | コールバック方式 |
|------|---------------|-----------------|
| **データ供給** | メインループから手動 | バックグラウンドスレッドから自動 |
| **タイミング** | フレームレートに依存 | オーディオシステムが制御 |
| **実装難易度** | 簡単 | 中程度（スレッドセーフ必須） |
| **デバッグ** | 容易 | やや困難 |
| **音質** | ノイズが発生しやすい | 安定した音質 |
| **レイテンシ** | やや高い | 低い |
| **CPU使用率** | メインスレッドに負荷 | 分散される |

## コールバック方式の注意点

### スレッドセーフ

コールバック関数はバックグラウンドスレッドから呼び出されるため、以下に注意が必要です：

1. **共有データへのアクセス**: is_playing_、gate_、current_sample_などの共有データは、メインスレッドとコールバックスレッドの両方からアクセスされます
2. **アトミック操作**: 現在の実装では、boolやfloatの読み書きはアトミックと仮定していますが、複雑な状態変更にはミューテックスが必要になる場合があります
3. **ロックフリー設計**: 今回の実装では、状態フラグ（is_playing_、gate_）の読み書きのみで、複雑なロックは不要です

### 将来の拡張性

複数のシンセサイザーを同時再生する場合や、より複雑な状態管理が必要になった場合は、以下を検討する必要があります：

- SDL_Mutexを使った排他制御
- リングバッファを使ったロックフリーキュー
- SDL_AtomicGet/SetInt32などのアトミック操作

## 変更ファイル

**修正:**
- `game.cc` - SDL_Init()にSDL_INIT_AUDIOフラグを追加
- `game_manager/sound_synthesizer.h` - コールバック方式に変更、エンベロープ改善、デバッグログ追加
- `game/test_impl_3.h` - エンベロープパラメータ調整

**ユーザー追加:**
- `game/test_impl_3.h` - Oキーでオシレーター切り替え機能

## ビルド結果

✅ ビルド成功

## 動作確認

**操作方法:**
- **Space**: A4（440Hz）のテストトーン
- **1〜8**: ドレミファソラシド（C4〜C5）
- **Enter**: カエルの歌を自動演奏
- **O**: オシレーター切り替え（サイン波 → 矩形波 → ノコギリ波）
- **0**: シーケンス停止

**確認結果:**
- ✅ ノイズが完全に解消
- ✅ すべてのオシレーター（サイン波、矩形波、ノコギリ波）で滑らかな音質
- ✅ メロディーシーケンスが正確に再生される
- ✅ 音程が正確
- ✅ エンベロープが正しく動作

**音質の改善:**
- クリックノイズがなくなった
- バッファアンダーランによる途切れがなくなった
- 全体的にクリアで安定した音質になった

## まとめ

SDL3のコールバック方式を使用することで、ノイズのない高品質なシンセサイザーを実現しました。

**技術的なポイント:**
1. SDL_INIT_AUDIOフラグの追加でオーディオサブシステムを初期化
2. SDL_OpenAudioDeviceStreamにコールバック関数を指定
3. バックグラウンドスレッドから自動的にサンプル生成
4. メインループではis_playing_フラグの更新のみ
5. エンベロープパラメータの調整でクリックノイズを軽減

**設計の利点:**
- オーディオシステムが必要なタイミングで正確にデータを供給
- メインループのフレームレートに依存しない安定した音質
- バッファアンダーラン（データ不足）による途切れやノイズを防止

このシンセサイザーは、ゲームの効果音システムの基盤として実用的なレベルに達しました。
