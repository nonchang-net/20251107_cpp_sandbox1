# 作業レポート - 2025/11/09 11:17

## 変更内容の概要

- texture_loader.hのload_texture関数をC++ベストプラクティスに沿って全面的に改修しました
- RAII原則に基づいたリソース管理を導入し、メモリリークとリソースリークを防止しました
- エラーハンドリングを改善し、詳細な日本語ドキュメントコメントを追加しました

## 変更理由

- **メモリリーク防止**: 元の実装ではエラー時にSDL_freeが呼ばれず、メモリリークが発生する可能性がありました
- **リソースリーク防止**: サーフェスの解放が不完全で、例外安全性もありませんでした
- **C++らしい実装**: C言語スタイルの生ポインタ管理からC++のスマートポインタを活用した実装に改善しました
- **保守性向上**: ヘッダーガードの追加、詳細なドキュメントコメントにより保守性を向上させました

## 技術的な実装詳細

### 1. 元の実装の問題点

**問題1: ヘッダーガードがない**
```cpp
// ヘッダーガードなし
#include <SDL3/SDL.h>
```
→ 多重インクルード時にコンパイルエラーやリンクエラーの危険性

**問題2: メモリリーク**
```cpp
char* png_path = NULL;
SDL_asprintf(&png_path, "%s%s", SDL_GetBasePath(), filename);
SDL_Surface* surface = NULL;
surface = SDL_LoadPNG(png_path);
if (!surface) {
  SDL_Log("Couldn't load bitmap: %s", SDL_GetError());
  return {nullptr, 0, 0};  // ← png_pathが解放されない！
}
SDL_free(png_path);  // 正常パスでのみ解放
```

**問題3: リソースリーク**
```cpp
SDL_Texture* texture = SDL_CreateTextureFromSurface(renderer, surface);
if (!texture) {
  SDL_Log("Couldn't create static texture: %s", SDL_GetError());
  return {nullptr, 0, 0};  // ← surfaceが解放されない！
}

SDL_DestroySurface(surface);  // 正常パスでのみ解放
```

**問題4: C言語スタイル**
- `NULL`の使用（C++では`nullptr`を使うべき）
- 生ポインタの直接管理（RAII原則違反）
- エラーチェックが不完全

**問題5: ドキュメント不足**
- 関数の目的、引数、戻り値の説明がない
- 使用例がない
- 所有権の扱いが不明確

### 2. 修正版の実装

**改善1: ヘッダーガードの追加**
```cpp
#pragma once

#include <SDL3/SDL.h>
#include <memory>
#include <tuple>
```

**改善2: カスタムデリータの定義**
```cpp
/**
 * @brief SDLリソース用のカスタムデリータ
 */
struct SDLSurfaceDeleter {
  void operator()(SDL_Surface* surface) const {
    if (surface) SDL_DestroySurface(surface);
  }
};

struct SDLStringDeleter {
  void operator()(char* str) const {
    if (str) SDL_free(str);
  }
};
```

**特徴:**
- `std::unique_ptr`で自動的にリソースを解放
- エラー発生時も自動的にクリーンアップ
- 例外が発生しても安全

**改善3: RAIIによるリソース管理**
```cpp
// パス文字列を自動管理
char* png_path_raw = nullptr;
SDL_asprintf(&png_path_raw, "%s%s", SDL_GetBasePath(), filename);
std::unique_ptr<char, SDLStringDeleter> png_path(png_path_raw);

if (!png_path) {
  SDL_Log("Failed to allocate path string");
  return {nullptr, 0, 0};  // png_pathは自動的に解放される
}

// サーフェスを読み込み（自動管理）
std::unique_ptr<SDL_Surface, SDLSurfaceDeleter> surface(
    SDL_LoadPNG(png_path.get()));

if (!surface) {
  SDL_Log("Failed to load PNG '%s': %s", filename, SDL_GetError());
  return {nullptr, 0, 0};  // surfaceとpng_pathが自動的に解放される
}
```

**メリット:**
- スコープを抜ける時に自動的にリソースが解放される
- エラーパスでもリークしない
- 例外が発生しても安全（例外安全性）

**改善4: 入力検証の追加**
```cpp
if (!renderer || !filename) {
  SDL_Log("Invalid parameters: renderer or filename is null");
  return {nullptr, 0, 0};
}
```

**改善5: エラーメッセージの改善**
```cpp
// 元:
SDL_Log("Couldn't load bitmap: %s", SDL_GetError());

// 改善後:
SDL_Log("Failed to load PNG '%s': %s", filename, SDL_GetError());
```

どのファイルで失敗したかが明確になります。

**改善6: 詳細なドキュメントコメント**
```cpp
/**
 * @brief テクスチャをファイルから読み込む
 *
 * 指定されたPNGファイルからSDL_Textureを作成します。
 * SDL_GetBasePath()を基準に相対パスで指定できます。
 *
 * @param renderer SDLレンダラー
 * @param filename 読み込むファイル名（SDL_GetBasePath()からの相対パス）
 * @return {テクスチャ（失敗時nullptr）, 幅, 高さ} のタプル
 *
 * @note 戻り値のSDL_Texture*は呼び出し側が所有権を持ち、
 *       使用後にSDL_DestroyTexture()で解放する必要があります。
 *
 * 使用例:
 * @code
 * auto [texture, width, height] = Utilities::load_texture(renderer, "images/sprite.png");
 * if (texture) {
 *   // テクスチャを使用
 *   SDL_DestroyTexture(texture);  // 使用後に解放
 * }
 * @endcode
 */
```

**ドキュメントの内容:**
- 関数の目的
- 引数の説明
- 戻り値の説明
- 所有権に関する重要な注意（@note）
- 具体的な使用例（@code）

### 3. 実装の流れ

**修正前:**
```
1. SDL_asprintfでパス文字列を確保
2. SDL_LoadPNGでサーフェスを読み込み
   ↓ エラー → png_pathがリーク！
3. SDL_freeでパス文字列を解放
4. SDL_CreateTextureFromSurfaceでテクスチャ作成
   ↓ エラー → surfaceがリーク！
5. SDL_DestroySurfaceでサーフェスを解放
6. テクスチャを返す
```

**修正後:**
```
1. 入力パラメータを検証 → 早期リターン
2. std::unique_ptr<char>でパス文字列を確保（自動管理）
   ↓ エラー → 自動的に解放される
3. std::unique_ptr<SDL_Surface>でサーフェスを読み込み（自動管理）
   ↓ エラー → 自動的に解放される（png_pathも）
4. SDL_CreateTextureFromSurfaceでテクスチャ作成
   ↓ エラー → 自動的に解放される（surfaceとpng_pathも）
5. サーフェスは自動的に解放される
6. テクスチャを返す（所有権は呼び出し側へ）
```

### 4. RAII（Resource Acquisition Is Initialization）の利点

**RAII原則:**
- リソースの確保と初期化を同時に行う
- リソースの解放はデストラクタで自動的に行う
- スコープを抜ける時に確実にクリーンアップされる

**コード例:**
```cpp
{
  std::unique_ptr<SDL_Surface, SDLSurfaceDeleter> surface(SDL_LoadPNG(path));

  if (!surface) {
    return {nullptr, 0, 0};
    // ここでsurfaceのデストラクタが呼ばれ、自動的に解放される
  }

  // 処理...

  // スコープを抜ける時にsurfaceが自動的に解放される
}
```

**従来の方法との比較:**
```cpp
// 従来: 手動管理（エラーが起きやすい）
SDL_Surface* surface = SDL_LoadPNG(path);
if (!surface) {
  return {nullptr, 0, 0};  // 解放忘れの危険性
}
// 処理...
SDL_DestroySurface(surface);  // 解放忘れの危険性

// RAII: 自動管理（安全）
std::unique_ptr<SDL_Surface, SDLSurfaceDeleter> surface(SDL_LoadPNG(path));
// スコープを抜ける時に自動的に解放される
```

### 5. スマートポインタのカスタムデリータ

**std::unique_ptrの基本:**
```cpp
std::unique_ptr<T, Deleter> ptr;
```

**SDLリソース用のカスタムデリータ:**
```cpp
struct SDLSurfaceDeleter {
  void operator()(SDL_Surface* surface) const {
    if (surface) SDL_DestroySurface(surface);
  }
};

// 使用
std::unique_ptr<SDL_Surface, SDLSurfaceDeleter> surface(SDL_LoadPNG(path));
```

**なぜカスタムデリータが必要か:**
- デフォルトの`delete`ではなく、SDL専用の`SDL_DestroySurface`を呼ぶ必要がある
- SDL_Surfaceはnewで確保されていない
- SDLの内部メモリ管理に従う必要がある

## 変更前後の比較

| 項目 | 変更前 | 変更後 |
|------|--------|--------|
| ヘッダーガード | なし | #pragma once |
| メモリリーク | エラー時にリーク | RAIIで自動解放 |
| リソースリーク | エラー時にリーク | RAIIで自動解放 |
| 例外安全性 | なし | std::unique_ptrで安全 |
| エラーメッセージ | 簡素 | ファイル名を含む詳細 |
| 入力検証 | なし | nullptr検証あり |
| ドキュメント | なし | 詳細なコメント |
| 使用例 | なし | コード例あり |
| 所有権の扱い | 不明確 | @noteで明記 |
| コードスタイル | C言語スタイル | C++スタイル |

## メモリ安全性の向上

**修正前（危険）:**
```cpp
char* png_path = NULL;
SDL_asprintf(&png_path, "%s%s", SDL_GetBasePath(), filename);
SDL_Surface* surface = NULL;
surface = SDL_LoadPNG(png_path);
if (!surface) {
  // png_pathがリーク！
  return {nullptr, 0, 0};
}
SDL_free(png_path);  // ここまで到達しない
```

**修正後（安全）:**
```cpp
std::unique_ptr<char, SDLStringDeleter> png_path(png_path_raw);
std::unique_ptr<SDL_Surface, SDLSurfaceDeleter> surface(SDL_LoadPNG(png_path.get()));
if (!surface) {
  // スコープを抜ける時に自動的に解放される
  return {nullptr, 0, 0};
}
// スコープを抜ける時に自動的に解放される
```

## ビルド結果

ビルドが正常に完了し、修正版が問題なく動作することを確認しました。

## C++ベストプラクティスへの適合

この修正により、以下のC++ベストプラクティスに適合しました：

1. **RAII原則**: リソースはコンストラクタで確保、デストラクタで解放
2. **スマートポインタ**: 生ポインタの代わりにstd::unique_ptrを使用
3. **例外安全性**: スコープを抜ける時に確実にリソースが解放される
4. **nullptrの使用**: NULLではなくnullptrを使用
5. **詳細なドキュメント**: Doxygenスタイルのコメント
6. **入力検証**: 関数の最初でパラメータを検証
7. **明確なエラーメッセージ**: どのファイルで失敗したかを明示

これにより、保守性が高く、バグが発生しにくい、C++らしい実装になりました。
