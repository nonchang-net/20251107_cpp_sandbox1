# 20251111_0300 - BGMクロスフェード機能と二段階ミキシングシステムの実装

## 変更内容の概要

- MultiTrackSequencerにストリームなしモードとgenerateSamples()メソッドを追加し、BGMManager経由での使用を可能に
- BGMManagerにSDL_AudioStreamベースのミキシング機能を実装し、複数のMultiTrackSequencerを同時再生・ミックス可能に
- BGMManagerにクロスフェード機能を実装し、BGM切り替え時にスムーズな遷移を実現
- test_impl_3.hのBGM切り替え処理をplayWithCrossfade()を使用するように更新

## 変更理由

従来のBGMManagerは、各BGMを個別に管理し、切り替え時には古いBGMを停止して新しいBGMを再生するだけでした。このため、BGM間の切り替えが突然で、ゲーム体験を損なう可能性がありました。

今回、以下の機能を実現するために、二段階のミキシングシステムを導入しました：

**第1段階**: MultiTrackSequencer内のAudioMixer
- 各トラックのSynthesizerをミックス
- トラック単位のマスターエフェクト適用

**第2段階**: BGMManager内のミキシング
- 複数のMultiTrackSequencer（複数のBGM）を同時にミックス
- クロスフェード時のボリューム制御
- フェードイン/フェードアウトの管理

これにより、以下が可能になりました：
1. 2つのBGMを同時に再生し、ボリュームを調整してクロスフェード
2. フェードイン/フェードアウトの時間を指定
3. スムーズなBGM遷移によるゲーム体験の向上

## 修正・作成したファイル

### 1. sound/sequencer/multi_track_sequencer.h

**変更内容**: ストリームなしモードとgenerateSamples()メソッドの追加

```cpp
// コンストラクタにenable_streamパラメータを追加
explicit MultiTrackSequencer(size_t track_count, int sample_rate = 44100,
                             float bpm = 120.0f, bool enable_stream = true);

// サンプル生成メソッド（BGMManager用）
void generateSamples(float* samples, int num_samples);

// サンプリングレート取得
int getSampleRate() const;

// メンバー変数
int sample_rate_;  // 追加
std::unique_ptr<AudioMixer> mixer_;  // enable_stream=falseの場合はnullptr
```

**動作モード**:
- `enable_stream=true` (デフォルト): 内部でAudioMixerを持ち、独立して音声出力
- `enable_stream=false`: AudioMixerを持たず、サンプル生成のみ（BGMManager経由での使用）

### 2. sound/sequencer/multi_track_sequencer.cc

**コンストラクタの変更**:
```cpp
MultiTrackSequencer::MultiTrackSequencer(size_t track_count, int sample_rate, float bpm, bool enable_stream)
    : track_count_(track_count),
      sample_rate_(sample_rate),
      bpm_(bpm),
      master_volume_(1.0f),
      is_paused_(false),
      mixer_(enable_stream ? std::make_unique<AudioMixer>(sample_rate) : nullptr) {

  for (size_t i = 0; i < track_count; ++i) {
    auto synth = std::make_unique<SimpleSynthesizer>(sample_rate, false);  // 常にストリームなし
    auto seq = std::make_unique<Sequencer>(synth.get(), bpm);

    // ストリームありモードの場合のみミキサーに登録
    if (mixer_) {
      mixer_->addSynthesizer(synth.get());
    }

    synthesizers_.push_back(std::move(synth));
    sequencers_.push_back(std::move(seq));
  }

  if (mixer_) {
    mixer_->setVolume(master_volume_);
  }
}
```

**generateSamples()の実装**:
```cpp
void MultiTrackSequencer::generateSamples(float* samples, int num_samples) {
  // 出力バッファを初期化（無音）
  SDL_memset(samples, 0, num_samples * sizeof(float));

  // 各シンセサイザーからサンプルを取得してミックス
  float* temp_buffer = new float[num_samples];

  for (auto& synth : synthesizers_) {
    if (synth) {
      synth->generateSamples(temp_buffer, num_samples);

      // ミックス（加算）
      for (int i = 0; i < num_samples; ++i) {
        samples[i] += temp_buffer[i];
      }
    }
  }

  delete[] temp_buffer;

  // マスターボリュームを適用
  for (int i = 0; i < num_samples; ++i) {
    samples[i] *= master_volume_;

    // クリッピング防止
    if (samples[i] > 1.0f) samples[i] = 1.0f;
    if (samples[i] < -1.0f) samples[i] = -1.0f;
  }
}
```

### 3. sound/sequencer/bgm_manager.h

**主な変更**:

**コンストラクタ**:
```cpp
explicit BGMManager(int sample_rate = 44100);
```

**クロスフェード機能**:
```cpp
// BGMをクロスフェードで再生
bool playWithCrossfade(const std::string& id, float fade_duration = 2.0f);
```

**フェード状態管理**:
```cpp
struct FadeState {
  MultiTrackSequencer* bgm = nullptr;  // フェード中のBGM
  std::string bgm_id;                   // BGM ID
  float current_volume = 0.0f;          // 現在のボリューム
  float target_volume = 0.0f;           // 目標ボリューム
  float fade_duration = 0.0f;           // フェード時間（秒）
  float elapsed_time = 0.0f;            // 経過時間（秒）
  bool is_fading = false;               // フェード中フラグ
};

FadeState fade_in_;   // フェードイン中のBGM
FadeState fade_out_;  // フェードアウト中のBGM
```

**メンバー変数**:
```cpp
SDL_AudioStream* stream_;  // オーディオストリーム
int sample_rate_;
Uint64 last_update_time_;  // 前回の更新時刻（デルタタイム計算用）
```

### 4. sound/sequencer/bgm_manager.cc

**コンストラクタの実装**:
```cpp
BGMManager::BGMManager(int sample_rate)
    : stream_(nullptr),
      sample_rate_(sample_rate),
      last_update_time_(SDL_GetTicks()) {

  // オーディオストリームを初期化（コールバック方式）
  SDL_AudioSpec spec;
  spec.channels = 1;
  spec.format = SDL_AUDIO_F32;
  spec.freq = sample_rate_;

  stream_ = SDL_OpenAudioDeviceStream(
      SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK,
      &spec,
      audioCallback,
      this);

  if (!stream_) {
    SDL_LogError(SDL_LOG_CATEGORY_AUDIO, "BGMManager: Failed to open audio device: %s", SDL_GetError());
    return;
  }

  if (!SDL_ResumeAudioStreamDevice(stream_)) {
    SDL_LogError(SDL_LOG_CATEGORY_AUDIO, "BGMManager: Failed to resume audio device: %s", SDL_GetError());
  }
}
```

**playWithCrossfade()の実装**:
```cpp
bool BGMManager::playWithCrossfade(const std::string& id, float fade_duration) {
  auto* new_bgm = getBGM(id);
  if (!new_bgm) return false;

  // 同じBGMの場合は何もしない
  if (current_bgm_id_ == id) {
    return true;
  }

  // フェードアウト設定（現在のBGM）
  if (!current_bgm_id_.empty()) {
    auto* current_bgm = getBGM(current_bgm_id_);
    if (current_bgm) {
      fade_out_.bgm = current_bgm;
      fade_out_.bgm_id = current_bgm_id_;
      fade_out_.current_volume = master_volume_;
      fade_out_.target_volume = 0.0f;
      fade_out_.fade_duration = fade_duration;
      fade_out_.elapsed_time = 0.0f;
      fade_out_.is_fading = true;
    }
  }

  // フェードイン設定（新しいBGM）
  fade_in_.bgm = new_bgm;
  fade_in_.bgm_id = id;
  fade_in_.current_volume = 0.0f;
  fade_in_.target_volume = master_volume_;
  fade_in_.fade_duration = fade_duration;
  fade_in_.elapsed_time = 0.0f;
  fade_in_.is_fading = true;

  // 新しいBGMを再生開始
  new_bgm->setMasterVolume(0.0f);  // 初期ボリュームは0
  new_bgm->play();

  current_bgm_id_ = id;

  return true;
}
```

**update()の実装**:
```cpp
void BGMManager::update() {
  // デルタタイムを計算（秒）
  Uint64 current_time = SDL_GetTicks();
  float delta_time = (current_time - last_update_time_) / 1000.0f;
  last_update_time_ = current_time;

  // フェード処理を更新
  updateFade(fade_in_, delta_time);
  updateFade(fade_out_, delta_time);

  // 全てのBGMを更新
  for (auto& [id, bgm] : bgm_map_) {
    bgm->update();
  }
}
```

**updateFade()の実装**:
```cpp
void BGMManager::updateFade(FadeState& state, float delta_time) {
  if (!state.is_fading || !state.bgm) return;

  state.elapsed_time += delta_time;

  // フェード進行度を計算（0.0〜1.0）
  float progress = SDL_clamp(state.elapsed_time / state.fade_duration, 0.0f, 1.0f);

  // 現在のボリュームを計算（線形補間）
  float start_volume = (state.target_volume == 0.0f) ? master_volume_ : 0.0f;
  float target_volume = state.target_volume;
  state.current_volume = start_volume + (target_volume - start_volume) * progress;

  // BGMのボリュームを設定
  state.bgm->setMasterVolume(state.current_volume);

  // フェード完了チェック
  if (progress >= 1.0f) {
    state.is_fading = false;

    // フェードアウト完了時は停止
    if (state.target_volume == 0.0f) {
      state.bgm->stop();
      state.bgm = nullptr;
    }
  }
}
```

**audioCallback()とmixSamples()の実装**:
```cpp
void SDLCALL BGMManager::audioCallback(void* userdata, SDL_AudioStream* stream,
                                        int additional_amount, int total_amount) {
  BGMManager* manager = static_cast<BGMManager*>(userdata);

  int samples_needed = additional_amount / sizeof(float);
  if (samples_needed <= 0) return;

  float* samples = new float[samples_needed];
  manager->mixSamples(samples, samples_needed);

  SDL_PutAudioStreamData(stream, samples, additional_amount);

  delete[] samples;
}

void BGMManager::mixSamples(float* output, int num_samples) {
  SDL_memset(output, 0, num_samples * sizeof(float));

  float* temp_buffer = new float[num_samples];

  // フェードイン中のBGMをミックス
  if (fade_in_.is_fading && fade_in_.bgm) {
    fade_in_.bgm->generateSamples(temp_buffer, num_samples);
    for (int i = 0; i < num_samples; ++i) {
      output[i] += temp_buffer[i];
    }
  }

  // フェードアウト中のBGMをミックス
  if (fade_out_.is_fading && fade_out_.bgm) {
    fade_out_.bgm->generateSamples(temp_buffer, num_samples);
    for (int i = 0; i < num_samples; ++i) {
      output[i] += temp_buffer[i];
    }
  }

  // フェード中でない現在のBGMをミックス
  if (!current_bgm_id_.empty() && !fade_in_.is_fading && !fade_out_.is_fading) {
    auto* bgm = getBGM(current_bgm_id_);
    if (bgm) {
      bgm->generateSamples(temp_buffer, num_samples);
      for (int i = 0; i < num_samples; ++i) {
        output[i] += temp_buffer[i];
      }
    }
  }

  delete[] temp_buffer;

  // クリッピング防止
  for (int i = 0; i < num_samples; ++i) {
    if (output[i] > 1.0f) output[i] = 1.0f;
    if (output[i] < -1.0f) output[i] = -1.0f;
  }
}
```

### 5. game/test_impl_3.h

**BGM作成の変更**:
```cpp
// 変更前
auto bgm = std::make_unique<MultiTrackSequencer>(4);

// 変更後
auto bgm = std::make_unique<MultiTrackSequencer>(4, 44100, 120.0f, false);  // ストリームなしモード
```

**BGM切り替えの変更**:
```cpp
// 変更前
case SDL_SCANCODE_1: {
  bgm_manager_.play("bgm1");
  break;
}

// 変更後
case SDL_SCANCODE_1: {
  bgm_manager_.playWithCrossfade("bgm1", 2.0f);  // 2秒でクロスフェード
  break;
}
```

## アーキテクチャの変更

### 二段階ミキシングシステム

**第1段階: MultiTrackSequencer内のミキシング**
```
Track 1: Synthesizer (stream-less) ┐
Track 2: Synthesizer (stream-less) ├→ MultiTrackSequencer::generateSamples() → ミックス済みサンプル
Track 3: Synthesizer (stream-less) ┘
```

**第2段階: BGMManager内のミキシング**
```
BGM 1: MultiTrackSequencer (stream-less) → フェードイン  ┐
BGM 2: MultiTrackSequencer (stream-less) → フェードアウト├→ BGMManager::mixSamples() → SDL_AudioStream → Audio Device
BGM 3: MultiTrackSequencer (stream-less) → 停止中      ┘
```

### クロスフェード処理フロー

1. **ユーザーが新しいBGMを選択**
   - `playWithCrossfade("bgm2", 2.0f)` を呼び出し

2. **フェード状態の設定**
   - fade_out_: 現在のBGM（BGM1）を2秒かけてボリューム1.0→0.0
   - fade_in_: 新しいBGM（BGM2）を2秒かけてボリューム0.0→1.0

3. **オーディオコールバック（並列処理）**
   - BGM1とBGM2の両方からサンプルを生成
   - 各BGMのサンプルを加算ミックス
   - 最終出力

4. **update()での時間管理**
   - 毎フレーム、経過時間を計算
   - フェード進行度に応じてボリュームを更新
   - フェード完了時、フェードアウトしたBGMを停止

## 使用例

### 基本的なクロスフェード

```cpp
// BGMマネージャーを作成
BGMManager bgm_manager(44100);

// BGMを登録（ストリームなしモードで作成）
auto bgm1 = std::make_unique<MultiTrackSequencer>(4, 44100, 120.0f, false);
// ... BGM1の設定 ...
bgm_manager.registerBGM("bgm1", std::move(bgm1));

auto bgm2 = std::make_unique<MultiTrackSequencer>(3, 44100, 80.0f, false);
// ... BGM2の設定 ...
bgm_manager.registerBGM("bgm2", std::move(bgm2));

// BGM1を再生
bgm_manager.play("bgm1");

// 2秒かけてBGM2にクロスフェード
bgm_manager.playWithCrossfade("bgm2", 2.0f);

// 毎フレーム更新（フェード処理）
bgm_manager.update();
```

### キーボードでのBGM切り替え

```cpp
case SDL_SCANCODE_1: {
  bgm_manager_.playWithCrossfade("bgm1", 2.0f);
  break;
}
case SDL_SCANCODE_2: {
  bgm_manager_.playWithCrossfade("bgm2", 2.0f);
  break;
}
case SDL_SCANCODE_3: {
  bgm_manager_.playWithCrossfade("bgm3", 2.0f);
  break;
}
```

## フェード処理の詳細

### 線形補間によるボリューム変化

```
フェードイン（0.0 → 1.0）:
  progress = elapsed_time / fade_duration
  current_volume = 0.0 + (1.0 - 0.0) * progress

フェードアウト（1.0 → 0.0）:
  progress = elapsed_time / fade_duration
  current_volume = 1.0 + (0.0 - 1.0) * progress
```

### タイムライン例（2秒クロスフェード）

```
時刻    BGM1ボリューム  BGM2ボリューム  状態
0.0秒   1.0            0.0            BGM1のみ再生
0.5秒   0.75           0.25           クロスフェード中
1.0秒   0.5            0.5            両方同じボリューム
1.5秒   0.25           0.75           クロスフェード中
2.0秒   0.0 (停止)     1.0            BGM2のみ再生
```

## 将来の拡張可能性

### Phase 1（今回の実装）:
- ✅ 二段階ミキシングシステム
- ✅ クロスフェード機能
- ✅ 線形補間によるボリューム変化

### Phase 2（将来の拡張）:
- **イージング関数**: 線形補間だけでなく、イーズイン/アウト/インアウトをサポート
  ```cpp
  enum class FadeEasing {
    Linear,
    EaseIn,
    EaseOut,
    EaseInOut
  };
  ```

- **BGM固有のボリューム**: マスターボリュームとは別に、BGM個別のボリューム設定
  ```cpp
  bgm->setVolume(0.8f);  // BGM固有のボリューム
  bgm_manager.setMasterVolume(0.5f);  // 全体のマスターボリューム
  ```

- **クロスフェード完了コールバック**: フェード完了時の通知
  ```cpp
  bgm_manager.playWithCrossfade("bgm2", 2.0f, [](const std::string& id) {
    SDL_Log("Crossfade to %s completed", id.c_str());
  });
  ```

- **複数BGMの同時再生**: クロスフェード以外でも複数BGMを同時再生
  ```cpp
  bgm_manager.playParallel("ambient", 0.3f);  // アンビエント音を重ねる
  ```

## パフォーマンスへの影響

### メモリ使用量
- クロスフェード中: 2つのMultiTrackSequencerが同時に動作
- 通常再生中: 1つのMultiTrackSequencerのみ
- 一時バッファ: サンプル生成用に数KB

### CPU使用量
- クロスフェード中: 2つのBGMを同時に生成してミックス（2倍の処理）
- 通常再生中: 1つのBGMのみ
- フェード処理: 毎フレーム、ボリューム計算（軽量）

### 結論
クロスフェード中はCPU使用量が増加しますが、短時間（数秒）のみであり、許容範囲内です。

## ビルド結果

```bash
cmake --build build
```

**結果**: ✅ ビルド成功（エラーなし）

## まとめ

BGMManagerにクロスフェード機能と二段階ミキシングシステムを実装しました。これにより、以下が実現できるようになりました：

1. **スムーズなBGM遷移**: クロスフェードにより、BGM切り替えが自然に
2. **二段階ミキシング**: MultiTrackSequencer（トラック→BGM）→ BGMManager（BGM→最終出力）
3. **柔軟なフェード時間**: フェード時間を指定可能（デフォルト2秒）
4. **複数BGMの同時再生**: クロスフェード中は2つのBGMが同時に再生

これにより、ゲームのBGM管理がより洗練され、プレイヤー体験が向上します。
