# 20251110_2206 - サウンドライブラリの分離とリファクタリング (Phase 2)

## 変更内容の概要

- MMLParser、Sequencer、MultiTrackSequencer、BGMManagerをgame_manager/sound_synthesizer.hから独立したsound/ライブラリに分離
- MMLParserはsound/mml/に、Sequencer関連はsound/sequencer/に配置し、ヘッダと実装ファイルに分割
- sound/sound.hにMMLとSequencer関連のインクルードを追加し、CMakeLists.txtのSOUND_SOURCESに3つの.ccファイルを追加してビルドシステムに統合

## 変更理由

Phase 1で基盤クラス（Oscillator、Envelope、SimpleSynthesizer）の分離が完了したため、Phase 2としてシーケンサー機能を分離する段階に進んだ。MMLParserはコンパイル時評価が必要なのでヘッダオンリー、Sequencer系は実行時処理が中心なのでヘッダと実装に分割する方針を採用した。既存コード（game_manager/sound_synthesizer.h）は互換性のため残したまま、段階的に新しいライブラリ構造に移行できるようにした。

## 作成したファイル

### 1. sound/mml/mml_parser.h

**概要**: MML（Music Macro Language）パーサー（constexpr対応、ヘッダオンリー）

```cpp
namespace MySound {
  class MMLParser {
   public:
    static constexpr FixedNoteSequence parse(const std::string& mml);
   private:
    static constexpr char constexpr_tolower(char c);
    static constexpr bool constexpr_isspace(char c);
    static constexpr bool constexpr_isdigit(char c);
    static constexpr Note charToNote(char c);
    static constexpr int parseNumber(const std::string& str, size_t& pos);
  };

  // ユーザー定義リテラル
  constexpr FixedNoteSequence operator""_mml(const char* str, size_t len);
}
```

**特徴**:
- 完全にconstexpr対応、コンパイル時にMML文字列を解析可能
- サポートするMML記法: c-g（音符）、+/-（シャープ/フラット）、r（休符）、o（オクターブ）、l（音符長）、t（テンポ）、@（音色）、v（ボリューム）、.（付点）、<>（オクターブシフト）
- ユーザー定義リテラル `"t120 o4 cdefgab"_mml` でコンパイル時評価

### 2. sound/sequencer/sequencer.h / .cc

**概要**: 音符シーケンスを再生するシーケンサー

**ヘッダ**:
```cpp
namespace MySound {
  class Sequencer {
   public:
    Sequencer(SimpleSynthesizer* synthesizer, float bpm = 120.0f);
    ~Sequencer();

    void setUpdateIntervalNS(Uint64 interval_ns);
    void setUpdateInterval(Uint32 interval_ms);
    Uint64 getUpdateIntervalNS() const;
    Uint32 getUpdateInterval() const;

    void setBPM(float bpm);
    float getBPM() const;
    void setVolume(float volume);
    float getVolume() const;
    void setLoop(bool enabled, int count = -1);
    bool isLoopEnabled() const;
    int getCurrentLoop() const;

    void clear();
    void addNote(Note note, int octave, int note_division, bool dotted = false,
                 WaveType wave_type = WaveType::Sine, float volume = 1.0f);
    void addRest(int note_division, bool dotted = false);

    void setSequence(std::vector<NoteData>&& notes);
    void setSequence(const std::vector<NoteData>& notes);
    void setSequence(const FixedNoteSequence& notes);
    void setSequence(std::span<const NoteData> notes);

    void play();
    void stop();
    bool isPlaying() const;
    void update();

   private:
    static Uint64 SDLCALL timerCallback(void* userdata, SDL_TimerID timerID, Uint64 interval);
    void startTimer();
    void stopTimer();
    void internalUpdate();
    void handleSequenceEnd();
    void playCurrentNote();

    SimpleSynthesizer* synthesizer_;
    float bpm_;
    float volume_;
    std::vector<NoteData> sequence_;
    size_t current_note_index_;
    bool is_playing_;
    float sequence_time_;
    Uint64 last_update_time_;
    bool loop_enabled_;
    int loop_count_;
    int current_loop_;
    SDL_TimerID timer_id_;
    Uint64 update_interval_ns_;
  };
}
```

**実装のポイント**:
- SDL_AddTimerNS()を使った高精度タイマーで音符の進行を制御
- デフォルト更新間隔: 15ms（DEFAULT_SEQUENCER_UPDATE_INTERVAL_NS = 15,000,000ns）
- ループ機能: 無限ループ（count=-1）または回数指定ループ（count>=0）
- 4つのsetSequence()オーバーロードで様々なコンテナに対応（std::vector, FixedNoteSequence, std::span）
- ボリュームは3段階（master × sequencer × note）で制御

### 3. sound/sequencer/multi_track_sequencer.h / .cc

**概要**: 複数トラック（パート）を管理するマルチトラックシーケンサー

**ヘッダ**:
```cpp
namespace MySound {
  class MultiTrackSequencer {
   public:
    explicit MultiTrackSequencer(size_t track_count, int sample_rate = 44100, float bpm = 120.0f);

    size_t getTrackCount() const;
    SimpleSynthesizer* getSynthesizer(size_t track_index);
    Sequencer* getSequencer(size_t track_index);

    void setTrackSequence(size_t track_index, const FixedNoteSequence& notes);
    void setTrackSequence(size_t track_index, const std::vector<NoteData>& notes);

    void setMasterVolume(float volume);
    float getMasterVolume() const;
    void setLoop(bool enabled, int count = -1);
    void setUpdateIntervalNS(Uint64 interval_ns);
    void setUpdateInterval(Uint32 interval_ms);

    void play();
    void stop();
    void pause();
    void resume();
    bool isPlaying() const;
    bool isPaused() const;
    void update();

   private:
    size_t track_count_;
    float bpm_;
    float master_volume_;
    bool is_paused_;
    std::vector<std::unique_ptr<SimpleSynthesizer>> synthesizers_;
    std::vector<std::unique_ptr<Sequencer>> sequencers_;
  };
}
```

**実装のポイント**:
- トラック数分のSimpleSynthesizerとSequencerをstd::unique_ptrで管理
- setMasterVolume(), setLoop(), setUpdateInterval()で全トラックに一括設定
- play(), stop(), pause(), resume()で全トラックを同時制御
- isPlaying()は少なくとも1トラックが再生中ならtrueを返す

### 4. sound/sequencer/bgm_manager.h / .cc

**概要**: 複数の楽曲（MultiTrackSequencer）を管理し、切り替えるBGMマネージャー

**ヘッダ**:
```cpp
namespace MySound {
  class BGMManager {
   public:
    void registerBGM(const std::string& id, std::unique_ptr<MultiTrackSequencer> bgm);
    MultiTrackSequencer* getBGM(const std::string& id);
    bool play(const std::string& id);
    void stop();
    void pause();
    void resume();
    void setMasterVolume(float volume);
    float getMasterVolume() const;
    const std::string& getCurrentBGMId() const;
    bool isPlaying() const;
    void update();

   private:
    std::unordered_map<std::string, std::unique_ptr<MultiTrackSequencer>> bgm_map_;
    std::string current_bgm_id_;
    float master_volume_ = 1.0f;
  };
}
```

**実装のポイント**:
- std::unordered_mapで楽曲IDから楽曲へのマッピングを管理
- play(id)時に現在再生中のBGMを自動的に停止
- setMasterVolume()で登録済みの全BGMにボリューム設定を適用
- current_bgm_id_で現在再生中の楽曲を追跡

### 5. sound/sound.h の更新

**変更内容**:
```cpp
// MML
#include "mml/mml_parser.h"

// シーケンサー
#include "sequencer/sequencer.h"
#include "sequencer/multi_track_sequencer.h"
#include "sequencer/bgm_manager.h"
```

Phase 1のコメント「未実装」から実装済みに変更。

### 6. CMakeLists.txt の更新

**変更内容**:
```cmake
# sound library (Phase 2: core classes + sequencer)
set(SOUND_SOURCES
    sound/core/oscillator.cc
    sound/core/envelope.cc
    sound/core/synthesizer.cc
    sound/sequencer/sequencer.cc
    sound/sequencer/multi_track_sequencer.cc
    sound/sequencer/bgm_manager.cc
)
```

Sequencer関連の3つの.ccファイルを追加。MMLParserはヘッダオンリーなので不要。

## ディレクトリ構造（Phase 2完了時点）

```
sound/
├── sound_constants.h           # 定数定義
├── sound.h                     # 統合ヘッダ
├── types/
│   ├── wave_type.h            # WaveType enum
│   └── note.h                 # Note enum, NoteData struct
├── core/
│   ├── oscillator.h/.cc       # Oscillator（波形生成）
│   ├── envelope.h/.cc         # Envelope（ADSR）
│   └── synthesizer.h/.cc      # SimpleSynthesizer
├── utilities/
│   ├── music_utilities.h      # MusicUtil（constexpr音楽計算）
│   └── fixed_note_sequence.h # FixedNoteSequence（constexpr配列）
├── mml/
│   └── mml_parser.h           # MMLParser（constexpr、ヘッダオンリー）
└── sequencer/
    ├── sequencer.h/.cc        # Sequencer（音符シーケンス再生）
    ├── multi_track_sequencer.h/.cc  # MultiTrackSequencer（マルチトラック管理）
    └── bgm_manager.h/.cc      # BGMManager（楽曲管理）
```

## ビルド結果

```
[ 93%] Building CXX object CMakeFiles/sound.dir/sound/sequencer/sequencer.cc.o
[ 94%] Building CXX object CMakeFiles/sound.dir/sound/sequencer/multi_track_sequencer.cc.o
[ 94%] Building CXX object CMakeFiles/sound.dir/sound/sequencer/bgm_manager.cc.o
[ 95%] Linking CXX static library libsound.a
[ 96%] Built target sound
...
[100%] Built target main
```

**成功！** 全てのファイルが正常にコンパイルされ、`libsound.a`が生成された。

## Phase 2 で完了したこと

1. **MMLParser分離**: constexpr対応のヘッダオンリーライブラリとして分離
2. **Sequencer分離**: 高精度タイマー（SDL_AddTimerNS）を使った音符シーケンス再生機能を分離
3. **MultiTrackSequencer分離**: 複数トラックを管理する機能を分離
4. **BGMManager分離**: 複数楽曲を管理・切り替える機能を分離
5. **統合ヘッダ更新**: sound.hにMMLとSequencer関連を追加
6. **ビルドシステム統合**: CMakeLists.txtにSequencer関連の.ccファイルを追加

## Phase 1 と Phase 2 の比較

| Phase 1 | Phase 2 |
|---------|---------|
| 基盤クラス（Oscillator, Envelope, SimpleSynthesizer） | シーケンサー機能（Sequencer, MultiTrackSequencer, BGMManager, MMLParser） |
| 3つの.ccファイル | 6つの.ccファイル（+3） |
| 波形生成とエンベロープ | 音符シーケンス再生、マルチトラック、楽曲管理 |

## 既存コードへの影響

Phase 2でも既存コード（game_manager/sound_synthesizer.h）はそのまま残しているため、**既存の機能は全て動作します**。Phase 3以降で段階的に移行します。

## Phase 3 の計画（次回）

次の段階では以下を実施予定:
1. game/test_impl_3.h など既存コードを新しいsound/ライブラリを使うように移行
2. game_manager/sound_synthesizer.h の参照を sound/sound.h に置き換え
3. game_manager/sound_synthesizer.h を削除（または deprecated マーク）
4. 既存コードの動作確認

## メリット

1. **モジュール性向上**: MML、Sequencer、BGM管理が独立したモジュールに分離
2. **constexpr活用**: MMLParserがコンパイル時評価可能で、定数データとして埋め込み可能
3. **再利用性**: SDL3のみに依存する独立ライブラリとして他プロジェクトでも使用可能
4. **拡張性**: 今後のエフェクト追加や高機能シンセサイザーの追加が容易
5. **ビルド時間**: 変更箇所のみ再コンパイル可能

## 技術的な詳細

### constexpr対応の分離基準

- **ヘッダオンリー**: MMLParser（コンパイル時評価が必要）
- **ヘッダ+実装**: Sequencer系（実行時処理が中心）

この基準により、MMLパーサーはコンパイル時に楽曲データを生成でき、ROM化やデータセクションへの配置が可能。

### SDL_AddTimerNS の活用

Sequencerクラスは SDL_AddTimerNS() を使用し、ナノ秒精度のタイマーで音符の進行を制御。デフォルト15ms間隔（32分音符相当の精度）で、より正確なタイミングで音符を再生可能。

### ボリューム3段階制御

最終ボリューム = マスターボリューム × シーケンサーボリューム × ノートボリューム

この3段階制御により、楽曲全体（マスター）、トラック単位（シーケンサー）、音符単位（ノート）でボリューム調整が可能。

## まとめ

Phase 2として、MMLParserとSequencer関連クラス（Sequencer, MultiTrackSequencer, BGMManager）をMySound名前空間の下に独立したライブラリとして分離し、ビルドシステムに統合しました。既存の機能は保持したまま、今後の拡張に向けたシーケンサー基盤が完成しました。
