# 作業レポート - 2025/11/09 08:02

## 変更内容の概要

- TextEntityをコンポーネントシステムで完全に代替し、text_entity.hを削除しました
- UIアンカーシステムを導入し、UI要素を画面上の特定位置（左上、右上、左下、右下、中央）にアンカーできるようにしました
- TextRendererコンポーネントを作成し、静的・動的テキストの両方をサポートしました

## 変更理由

- **UI要素の汎用化**: UI要素を画面座標で固定配置できるアンカーシステムを導入し、カメラの影響を受けないUI表示を実現しました
- **ゲーム要素とUIの分離**: UIAnchorComponentの有無で、ゲーム要素（カメラ影響あり）とUI要素（カメラ影響なし）を明確に区別できるようにしました
- **将来的な拡張性**: 左上、右上、左下、右下、中央の5つのアンカー位置を定義し、様々なUIレイアウトに対応できる基盤を作りました

## 技術的な実装詳細

### 1. UIAnchor列挙型 (component.h)

```cpp
/**
 * @brief UIアンカーの基準点
 */
enum class UIAnchor {
  TopLeft,      // 左上
  TopRight,     // 右上
  BottomLeft,   // 左下
  BottomRight,  // 右下
  Center        // 中央
};
```

**5つのアンカー位置:**
- TopLeft: 画面左上（0, 0）
- TopRight: 画面右上（width, 0）
- BottomLeft: 画面左下（0, height）
- BottomRight: 画面右下（width, height）
- Center: 画面中央（width/2, height/2）

### 2. UIAnchorComponentコンポーネント (component.h)

```cpp
/**
 * @brief UIアンカーコンポーネント
 *
 * UI要素を画面上の特定位置にアンカーします。
 * このコンポーネントがある場合、Locatorの座標はアンカーからのオフセットとして扱われます。
 * カメラの影響を受けず、常に画面座標で描画されます。
 */
class UIAnchorComponent : public Component {
 public:
  explicit UIAnchorComponent(UIAnchor anchor = UIAnchor::TopLeft)
      : anchor_(anchor) {}

  void setAnchor(UIAnchor anchor) { anchor_ = anchor; }
  UIAnchor getAnchor() const { return anchor_; }

  /**
   * @brief アンカー座標を計算
   * @param viewport_width ビューポート幅
   * @param viewport_height ビューポート高さ
   * @return アンカーの画面座標 {x, y}
   */
  std::pair<float, float> calculateAnchorPosition(
      float viewport_width, float viewport_height) const {
    switch (anchor_) {
      case UIAnchor::TopLeft:
        return {0.0f, 0.0f};
      case UIAnchor::TopRight:
        return {viewport_width, 0.0f};
      case UIAnchor::BottomLeft:
        return {0.0f, viewport_height};
      case UIAnchor::BottomRight:
        return {viewport_width, viewport_height};
      case UIAnchor::Center:
        return {viewport_width / 2.0f, viewport_height / 2.0f};
      default:
        return {0.0f, 0.0f};
    }
  }

 private:
  UIAnchor anchor_;
};
```

**特徴:**
- アンカー位置を指定し、画面座標を計算
- ビューポートサイズに基づいて正確な座標を算出
- 将来的なリサイズ対応も可能

### 3. TextRendererコンポーネント (component.h)

```cpp
/**
 * @brief テキストを描画するコンポーネント
 *
 * 静的テキストと動的テキスト（関数）の両方をサポートします。
 * UIAnchorComponentと組み合わせることで、UI要素として使用できます。
 */
class TextRenderer : public Component {
 public:
  // 静的テキスト用コンストラクタ
  TextRenderer(const std::string& text, SDL_Color color = {255, 255, 255, 255})
      : text_(text), color_(color), text_provider_(nullptr) {}

  // 動的テキスト用コンストラクタ
  TextRenderer(std::function<std::string()> text_provider,
               SDL_Color color = {255, 255, 255, 255})
      : color_(color), text_provider_(text_provider) {}

  void update(Entity* entity, Uint64 delta_time) override;
  void render(Entity* entity, SDL_Renderer* renderer) override;

  void setText(const std::string& text);
  const std::string& getText() const;
  void setColor(SDL_Color color);
  SDL_Color getColor() const;
  void setTextProvider(std::function<std::string()> provider);

 private:
  std::string text_;                           // テキスト内容
  SDL_Color color_;                            // 色
  std::function<std::string()> text_provider_; // 動的テキスト生成関数
};
```

**機能:**
- 静的テキスト：固定文字列を表示
- 動的テキスト：関数を渡して毎フレーム更新

### 4. TextRendererの実装 (entity_manager.h)

**update()の実装:**
```cpp
inline void TextRenderer::update(Entity* entity, Uint64 delta_time) {
  // 動的テキストの場合、毎フレーム更新
  if (text_provider_) {
    text_ = text_provider_();
  }
}
```

**render()の実装（UIアンカー対応）:**
```cpp
inline void TextRenderer::render(Entity* entity, SDL_Renderer* renderer) {
  float screen_x, screen_y;

  // UIAnchorコンポーネントがあるかチェック
  if (auto* ui_anchor = entity->getComponent<UIAnchorComponent>()) {
    // UI要素として扱う：カメラの影響を受けず、画面座標で描画
    auto* camera = entity->getRenderCamera();
    float viewport_width = 640.0f;   // デフォルト値
    float viewport_height = 480.0f;  // デフォルト値

    // アンカー座標を計算
    auto [anchor_x, anchor_y] = ui_anchor->calculateAnchorPosition(
        viewport_width, viewport_height);

    // Locatorのオフセットを取得
    auto [offset_x, offset_y] = entity->getLocalPosition();

    // 画面座標 = アンカー座標 + オフセット
    screen_x = anchor_x + offset_x;
    screen_y = anchor_y + offset_y;
  } else {
    // ゲーム要素として扱う：ワールド座標 + カメラ変換
    auto [world_x, world_y] = entity->getWorldPosition();

    if (auto* camera = entity->getRenderCamera()) {
      auto [sx, sy] = camera->worldToScreen(world_x, world_y);
      screen_x = sx;
      screen_y = sy;
    } else {
      screen_x = world_x;
      screen_y = world_y;
    }
  }

  // テキストを描画
  SDL_SetRenderDrawColor(renderer, color_.r, color_.g, color_.b, color_.a);
  SDL_RenderDebugText(renderer, screen_x, screen_y, text_.c_str());
}
```

**座標計算の分岐:**
1. **UIAnchorComponentがある場合（UI要素）:**
   - アンカー座標を計算
   - Locatorの座標をオフセットとして扱う
   - 画面座標 = アンカー座標 + オフセット
   - カメラの影響を受けない

2. **UIAnchorComponentがない場合（ゲーム要素）:**
   - ワールド座標を取得
   - カメラで画面座標に変換
   - カメラの影響を受ける

### 5. createTextEntity()ヘルパー関数 (entity_manager.h)

**静的テキスト用:**
```cpp
inline std::unique_ptr<Entity> createTextEntity(
    int layer, float x, float y, const std::string& text,
    SDL_Color color = {255, 255, 255, 255},
    const UIAnchor* anchor = nullptr) {
  auto entity = std::make_unique<Entity>(layer);
  entity->addComponent(std::make_unique<Locator>(x, y));
  entity->addComponent(std::make_unique<TextRenderer>(text, color));

  // UIアンカーが指定されている場合は追加
  if (anchor) {
    entity->addComponent(std::make_unique<UIAnchorComponent>(*anchor));
  }

  return entity;
}
```

**動的テキスト用:**
```cpp
inline std::unique_ptr<Entity> createTextEntity(
    int layer, float x, float y, std::function<std::string()> text_provider,
    SDL_Color color = {255, 255, 255, 255},
    const UIAnchor* anchor = nullptr) {
  auto entity = std::make_unique<Entity>(layer);
  entity->addComponent(std::make_unique<Locator>(x, y));
  entity->addComponent(std::make_unique<TextRenderer>(text_provider, color));

  if (anchor) {
    entity->addComponent(std::make_unique<UIAnchorComponent>(*anchor));
  }

  return entity;
}
```

**TextEntityの完全な代替:**
- Locator: 座標管理（UI要素の場合はオフセット）
- TextRenderer: テキスト描画（静的・動的）
- UIAnchorComponent: UI要素のアンカー（オプション）

### 6. test_impl_3.hでの使用例

**変更前（TextEntity使用）:**
```cpp
auto ui_text = std::make_unique<Entities::TextEntity>(
    10, 200, 240, "Entity Demo");
ui_text->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
entity_manager_.addEntity(std::move(ui_text));

auto fps_text = std::make_unique<Entities::TextEntity>(
    10, 10, 30,
    [this]() { /* FPS計算 */ });
fps_text->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
entity_manager_.addEntity(std::move(fps_text));
```

**変更後（コンポーネント使用）:**
```cpp
// 静的テキスト（ワールド座標、カメラの影響を受ける）
auto ui_text = createTextEntity(10, 200, 240, "Entity Demo");
ui_text->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
entity_manager_.addEntity(std::move(ui_text));

// 動的テキスト（FPS表示、UI要素として左上にアンカー）
static const UIAnchor top_left = UIAnchor::TopLeft;
auto fps_text = createTextEntity(
    10, 10, 30,
    [this]() {
      static char buffer[64];
      SDL_snprintf(
          buffer, sizeof(buffer), "FPS: ~%.0f",
          1000.0f / SDL_max(1, SDL_GetTicks() - last_time_));
      return std::string(buffer);
    },
    SDL_Color{255, 255, 255, 255},
    &top_left);
fps_text->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
entity_manager_.addEntity(std::move(fps_text));
```

**違い:**
- FPS表示にはUIAnchor::TopLeftを指定
- (10, 30)は画面左上からのオフセットとして扱われる
- カメラを移動してもFPS表示は画面左上に固定される

### 7. 削除されたファイル

- **game_manager/entities/text_entity.h**: コンポーネント組み合わせで完全に代替されたため削除

## UIアンカーシステムの使用例

### 左上にアンカー（FPS表示など）

```cpp
static const UIAnchor top_left = UIAnchor::TopLeft;
auto fps = createTextEntity(10, 10, 10, "FPS: 60", {255, 255, 255, 255}, &top_left);
// 画面左上から(10, 10)の位置に表示
```

### 右上にアンカー（スコア表示など）

```cpp
static const UIAnchor top_right = UIAnchor::TopRight;
auto score = createTextEntity(10, -100, 10, "Score: 1000", {255, 255, 255, 255}, &top_right);
// 画面右上から(-100, 10)の位置に表示（右端から100px左）
```

### 中央にアンカー（タイトルなど）

```cpp
static const UIAnchor center = UIAnchor::Center;
auto title = createTextEntity(10, 0, -50, "Game Title", {255, 255, 255, 255}, &center);
// 画面中央から(0, -50)の位置に表示（中央より少し上）
```

### ゲーム要素として表示（カメラ影響あり）

```cpp
auto world_text = createTextEntity(5, 100, 100, "Checkpoint!");
// アンカーなし：ワールド座標(100, 100)に表示、カメラの影響を受ける
```

## メリット

| 項目 | TextEntity（継承） | コンポーネント |
|------|-------------------|---------------|
| 静的テキスト | サポート | サポート |
| 動的テキスト | サポート | サポート |
| UI要素としての配置 | 不可 | UIAnchorで可能 |
| カメラの影響 | 常に受ける | UIAnchor有無で制御 |
| アンカー位置 | なし | 左上、右上、左下、右下、中央 |
| 座標の意味 | ワールド座標のみ | UIAnchor有:オフセット、無:ワールド座標 |

## UIアンカーシステムの設計思想

### ゲーム要素とUI要素の明確な分離

**ゲーム要素:**
- UIAnchorComponentなし
- ワールド座標で配置
- カメラの影響を受ける
- ゲーム世界の一部

**UI要素:**
- UIAnchorComponentあり
- 画面座標で配置（アンカー + オフセット）
- カメラの影響を受けない
- 常に画面上の固定位置に表示

### 将来的な拡張

このUIアンカーシステムにより、以下の機能が実装可能になりました：

1. **レスポンシブUI**: ビューポートサイズに応じてアンカー座標が自動調整される
2. **複雑なUIレイアウト**: 複数のアンカー位置を組み合わせてUIを構築
3. **UI要素の配置パターン**:
   - HUD（ヘッドアップディスプレイ）: 左上、右上にアンカー
   - メニュー: 中央にアンカー
   - ステータスバー: 上下にアンカー

## ビルド結果

ビルドが正常に完了し、text_entity.hなしで動作することを確認しました。

これで、RectEntity、RotateRectEntity、TextEntityの全てがコンポーネントシステムで代替され、継承ベースのエンティティクラスファイルを全て削除することができました。

さらに、UIアンカーシステムの導入により、ゲーム要素とUI要素を明確に分離し、UI要素を画面上の特定位置に固定配置できる汎用的な仕組みが整いました。
