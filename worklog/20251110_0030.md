# 作業レポート - 2025/11/10 00:30

## 変更内容の概要

- SDL3のオーディオAPIを使用したシンプルなシンセサイザーを実装しました
- オシレーター（サイン波、矩形波、ノコギリ波）、ADSRエンベロープ、シンセサイザー、シーケンサーを実装しました
- 音階定義とBPMベースの音符長計算機能を実装しました

## なぜこのように実装したか

- **効果音システムの基盤**: ゲームに効果音を追加するための基本的なサウンドシステムが必要でした
- **プロシージャルサウンド**: データファイルを使わず、プログラムで音を生成することで、柔軟な効果音を実現できます
- **学習と実験**: SDL3のオーディオAPIの理解と、音声合成の基礎を学ぶことができます

## 技術的な実装詳細

### 1. ファイル構成

**新規作成ファイル:**
- `game_manager/sound_synthesizer.h` - すべてのサウンド関連クラスを含むヘッダーファイル

### 2. 実装したクラス

#### 2.1 Oscillator クラス（オシレーター）

**役割:**
指定された周波数で波形を生成します。

**波形の種類:**
- **サイン波（Sine）**: 滑らかで純粋な音色
- **矩形波（Square）**: ファミコン風のチップチューンサウンド
- **ノコギリ波（Sawtooth）**: 明るく鋭い音色

**実装例（サイン波）:**
```cpp
float generate(float phase) const {
  switch (wave_type_) {
    case WaveType::Sine:
      return SDL_sinf(2.0f * SDL_PI_F * phase);
    case WaveType::Square:
      return (phase < 0.5f) ? 1.0f : -1.0f;
    case WaveType::Sawtooth:
      return 2.0f * phase - 1.0f;
    // ...
  }
}
```

**位相（phase）:**
- 0.0〜1.0の範囲で波形の位置を表す
- 0.0が波形の開始、1.0が1周期の終了

#### 2.2 Envelope クラス（ADSRエンベロープ）

**役割:**
音の時間的な変化を制御します。

**ADSRパラメータ:**
- **Attack（アタック）**: 音が立ち上がる時間
- **Decay（ディケイ）**: アタック後、サステインレベルまで減衰する時間
- **Sustain（サステイン）**: ノートオン中に維持される音量レベル
- **Release（リリース）**: ノートオフ後、音が消えるまでの時間

**ADSRの動作フロー:**
```
音量
  1.0 ┃ /\
      ┃/  \___________
  0.7 ┃     S          \
      ┃                 \
  0.0 ┗━━━━━━━━━━━━━━━━━━━━━━━━
      A  D    S          R
      ↑  ↑    ↑          ↑
     ノート  サステイン  ノート
     オン              オフ
```

**実装:**
```cpp
float process(float time, bool gate, float note_off_time) const {
  if (gate) {
    // ノートオン中
    if (time < attack_time_) {
      // Attack: 0.0 → 1.0
      return time / attack_time_;
    } else if (time < attack_time_ + decay_time_) {
      // Decay: 1.0 → sustain_level
      float decay_progress = (time - attack_time_) / decay_time_;
      return 1.0f - (1.0f - sustain_level_) * decay_progress;
    } else {
      // Sustain: sustain_levelを維持
      return sustain_level_;
    }
  } else {
    // Release: note_off時の値 → 0.0
    float release_time = time - note_off_time;
    if (release_time < release_time_) {
      float release_start_level = process(note_off_time, true);
      float release_progress = release_time / release_time_;
      return release_start_level * (1.0f - release_progress);
    } else {
      return 0.0f;
    }
  }
}
```

#### 2.3 SimpleSynthesizer クラス（シンプルなシンセサイザー）

**役割:**
1つのオシレーターと1つのエンベロープを組み合わせて音を生成し、SDL3のオーディオストリームで再生します。

**主要なメソッド:**
```cpp
// ノートオン（音を鳴らし始める）
void noteOn(float frequency, float duration = 0.0f);

// ノートオフ（音を止め始める）
void noteOff();

// 更新（メインループから毎フレーム呼び出す）
void update();
```

**SDL3オーディオストリームの使用:**
```cpp
SDL_AudioSpec spec;
spec.channels = 1;           // モノラル
spec.format = SDL_AUDIO_F32; // 32ビット浮動小数点（-1.0〜1.0）
spec.freq = 44100;           // サンプリングレート 44.1kHz

stream_ = SDL_OpenAudioDeviceStream(
    SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK, &spec, nullptr, nullptr);

SDL_ResumeAudioStreamDevice(stream_);
```

**サンプル生成:**
```cpp
void generateSamples(float* samples, int count) {
  for (int i = 0; i < count; ++i) {
    // 現在の時刻（秒）
    float current_time = getCurrentTime();

    // エンベロープの値を計算
    float envelope_value = envelope_->process(current_time - note_on_time_,
                                               gate_, note_off_time_ - note_on_time_);

    // 位相を計算（0.0〜1.0）
    float frequency = oscillator_->getFrequency();
    float phase = SDL_fmodf(
        static_cast<float>(current_sample_) * frequency / sample_rate_, 1.0f);

    // 波形を生成
    float wave = oscillator_->generate(phase);

    // エンベロープを適用
    samples[i] = wave * envelope_value;

    // クリッピング防止
    if (samples[i] > 1.0f) samples[i] = 1.0f;
    if (samples[i] < -1.0f) samples[i] = -1.0f;

    current_sample_++;
  }
}
```

**バッファリング戦略:**
```cpp
void update() {
  if (!stream_ || !is_playing_) return;

  // バッファの状態を確認
  int queued = SDL_GetAudioStreamQueued(stream_);
  const int min_buffer_bytes = sample_rate_ * sizeof(float) / 2;  // 0.5秒分

  if (queued < min_buffer_bytes) {
    // バッファが少なくなったらサンプルを生成
    const int samples_to_generate = 512;
    float samples[samples_to_generate];
    generateSamples(samples, samples_to_generate);
    SDL_PutAudioStreamData(stream_, samples, sizeof(samples));
  }
}
```

#### 2.4 MusicUtil クラス（音楽ユーティリティ）

**役割:**
音階から周波数への変換、BPMから音符の長さへの変換などを提供します。

**音階から周波数への変換:**
```cpp
static float noteToFrequency(Note note, int octave) {
  // A4 = 440Hz を基準とする
  // 半音ごとに 2^(1/12) 倍
  const float A4 = 440.0f;
  const int A4_note = static_cast<int>(Note::A);
  const int A4_octave = 4;

  // A4からの半音数を計算
  int semitones_from_A4 = (octave - A4_octave) * 12 +
                          (static_cast<int>(note) - A4_note);

  // 周波数を計算
  return A4 * SDL_powf(2.0f, semitones_from_A4 / 12.0f);
}
```

**音階の定義:**
```cpp
enum class Note {
  C = 0,   // ド
  Cs = 1,  // ド#（C#）
  D = 2,   // レ
  Ds = 3,  // レ#（D#）
  E = 4,   // ミ
  F = 5,   // ファ
  Fs = 6,  // ファ#（F#）
  G = 7,   // ソ
  Gs = 8,  // ソ#（G#）
  A = 9,   // ラ
  As = 10, // ラ#（A#）
  B = 11   // シ
};
```

**BPMから音符の長さを計算:**
```cpp
static float noteDuration(float bpm, int note_division, bool dotted = false) {
  // 4分音符を1拍とする
  float quarter_note = 60.0f / bpm;
  float duration = quarter_note * (4.0f / note_division);

  if (dotted) {
    duration *= 1.5f;  // 付点音符は1.5倍
  }

  return duration;
}
```

**音符の長さの例（BPM = 120）:**
- 全音符: 2.0秒
- 2分音符: 1.0秒
- 4分音符: 0.5秒
- 8分音符: 0.25秒
- 16分音符: 0.125秒
- ...
- 256分音符: 0.0078125秒

#### 2.5 Sequencer クラス（シーケンサー）

**役割:**
音符のシーケンスを時系列で再生します。

**主要なメソッド:**
```cpp
// 音符を追加
void addNote(Note note, int octave, int note_division, bool dotted = false);

// 休符を追加
void addRest(int note_division, bool dotted = false);

// シーケンスを再生開始
void play();

// シーケンスを停止
void stop();

// 更新（メインループから毎フレーム呼び出す）
void update();
```

**シーケンスの例（カエルの歌）:**
```cpp
sequencer->clear();
sequencer->setBPM(120.0f);

// カエルの歌: ド レ ミ ファ ミ レ ド
sequencer->addNote(Note::C, 4, 4);  // ド（4分音符）
sequencer->addNote(Note::D, 4, 4);  // レ
sequencer->addNote(Note::E, 4, 4);  // ミ
sequencer->addNote(Note::F, 4, 4);  // ファ
sequencer->addNote(Note::E, 4, 4);  // ミ
sequencer->addNote(Note::D, 4, 4);  // レ
sequencer->addNote(Note::C, 4, 4);  // ド

sequencer->play();
```

**更新処理:**
```cpp
void update() {
  if (!is_playing_ || sequence_.empty()) return;

  // 経過時間を計算
  Uint64 current_time = SDL_GetTicks();
  float delta_time = (current_time - last_update_time_) / 1000.0f;
  last_update_time_ = current_time;

  sequence_time_ += delta_time;

  // 現在の音符が終了したか確認
  if (current_note_index_ < sequence_.size()) {
    const NoteData& current_note = sequence_[current_note_index_];
    if (sequence_time_ >= current_note.duration) {
      // 次の音符へ
      sequence_time_ -= current_note.duration;
      current_note_index_++;

      if (current_note_index_ < sequence_.size()) {
        playCurrentNote();
      } else {
        // シーケンス終了
        is_playing_ = false;
      }
    }
  }
}
```

### 3. テストコードの実装（test_impl_3.h）

**追加したキー入力:**

| キー | 動作 | 説明 |
|------|------|------|
| **Space** | テストトーン | A4（440Hz）のサイン波を0.5秒再生 |
| **1** | C4（ド） | 261.63 Hz、サイン波、0.3秒 |
| **2** | D4（レ） | 293.66 Hz、サイン波、0.3秒 |
| **3** | E4（ミ） | 329.63 Hz、サイン波、0.3秒 |
| **4** | F4（ファ） | 349.23 Hz、サイン波、0.3秒 |
| **5** | G4（ソ） | 392.00 Hz、サイン波、0.3秒 |
| **6** | A4（ラ） | 440.00 Hz、サイン波、0.3秒 |
| **7** | B4（シ） | 493.88 Hz、サイン波、0.3秒 |
| **8** | C5（高いド） | 523.25 Hz、サイン波、0.3秒 |
| **Enter** | メロディー再生 | カエルの歌（矩形波） |
| **0** | シーケンス停止 | 再生中のシーケンスを停止 |

**実装例（1キー: C4）:**
```cpp
case SDL_SCANCODE_1: {
  // 1キー: C4（ド）
  float freq = MusicUtil::noteToFrequency(Note::C, 4);
  synthesizer_->getOscillator().setWaveType(WaveType::Sine);
  synthesizer_->noteOn(freq, 0.3f);
  SDL_Log("Note: C4 (%.2f Hz)", freq);
  break;
}
```

**実装例（Enterキー: メロディー再生）:**
```cpp
case SDL_SCANCODE_RETURN: {
  // Enterキー: 簡単なメロディーシーケンス（カエルの歌）
  sequencer_->clear();
  sequencer_->setBPM(120.0f);

  // カエルの歌: ド レ ミ ファ ミ レ ド
  sequencer_->addNote(Note::C, 4, 4);  // ド（4分音符）
  sequencer_->addNote(Note::D, 4, 4);  // レ
  sequencer_->addNote(Note::E, 4, 4);  // ミ
  sequencer_->addNote(Note::F, 4, 4);  // ファ
  sequencer_->addNote(Note::E, 4, 4);  // ミ
  sequencer_->addNote(Note::D, 4, 4);  // レ
  sequencer_->addNote(Note::C, 4, 4);  // ド

  synthesizer_->getOscillator().setWaveType(WaveType::Square);
  sequencer_->play();
  SDL_Log("Playing melody sequence");
  break;
}
```

**update()での更新:**
```cpp
// サウンドシンセサイザーとシーケンサーを更新
synthesizer_->update();
sequencer_->update();
```

### 4. 設計のポイント

#### 4.1 SDL3のオーディオストリーム方式

**メリット:**
- デバッグが容易（メインスレッドから制御）
- 実装がシンプル
- エラーハンドリングが簡単

**バッファリング:**
- 最小バッファレベル: 0.5秒分
- バッファが少なくなったら512サンプルずつ追加
- アンダーラン（音途切れ）を防ぐ

#### 4.2 浮動小数点サンプル（SDL_AUDIO_F32）

**メリット:**
- 計算が簡単（-1.0〜1.0の範囲）
- クリッピング検出が容易
- モダンなシステムで高速

**クリッピング防止:**
```cpp
if (samples[i] > 1.0f) samples[i] = 1.0f;
if (samples[i] < -1.0f) samples[i] = -1.0f;
```

#### 4.3 位相の計算

**整数カウンタを使用:**
```cpp
float phase = SDL_fmodf(
    static_cast<float>(current_sample_) * frequency / sample_rate_, 1.0f);
```

**理由:**
- 浮動小数点誤差の蓄積を防ぐ
- 長時間再生しても位相がずれない

#### 4.4 音階の計算（12平均律）

**半音ごとに 2^(1/12) 倍:**
```
A4 = 440Hz を基準
A#4 = 440 × 2^(1/12) ≈ 466.16 Hz
B4  = 440 × 2^(2/12) ≈ 493.88 Hz
C5  = 440 × 2^(3/12) ≈ 523.25 Hz
...
```

### 5. 今後の拡張可能性

**複数オシレーター:**
- 現在は1オシレーター + 1エンベロープ
- 将来的に複数のオシレーターをミックスして厚みのある音を作成可能

**フィルター:**
- ローパスフィルター、ハイパスフィルター
- カットオフ周波数、レゾナンスの調整

**エフェクト:**
- リバーブ（残響）
- ディレイ（遅延）
- ディストーション（歪み）

**LFO（Low Frequency Oscillator）:**
- ビブラート（ピッチの周期的な変化）
- トレモロ（音量の周期的な変化）
- フィルターのカットオフの周期的な変化

## 変更ファイル

**新規作成:**
- `game_manager/sound_synthesizer.h` - シンセサイザー関連のすべてのクラス

**変更:**
- `game/test_impl_3.h` - シンセサイザーのテストコード追加
  - インクルード追加
  - メンバ変数追加（synthesizer_, sequencer_）
  - コンストラクタでシンセサイザー初期化
  - handleSdlEventにキー入力追加
  - updateでシンセサイザー更新

## ビルド結果

✅ ビルド成功

## 動作確認

**操作方法:**
1. プログラムを起動
2. **Space**: A4（440Hz）のテストトーンを再生
3. **1〜8**: ドレミファソラシドを演奏
4. **Enter**: カエルの歌を自動演奏
5. **0**: シーケンス停止

**期待される動作:**
- サイン波、矩形波、ノコギリ波の切り替えが可能
- ADSRエンベロープで音の立ち上がりと減衰を制御
- BPM指定でメロディーを正確に演奏
- 音階から周波数への変換が正確

## まとめ

SDL3のオーディオAPIを使用したシンプルなシンセサイザーを実装しました。

**実装した機能:**
1. オシレーター（サイン波、矩形波、ノコギリ波）
2. ADSRエンベロープ
3. SimpleSynthesizer（1オシレーター + 1エンベロープ）
4. 音階定義（C〜Bの12音階）
5. BPMベースの音符長計算（全音符〜256分音符）
6. シーケンサー（音符のシーケンス再生）

**技術的なポイント:**
- SDL3のストリーム方式を使用
- 浮動小数点サンプル（SDL_AUDIO_F32）で計算が簡単
- 整数カウンタで位相管理、浮動小数点誤差を回避
- 12平均律で音階を計算

**今後の展開:**
- 複数オシレーターのミキシング
- フィルターの追加
- エフェクトの実装
- LFOによるモジュレーション

このシンセサイザーは、ゲームの効果音システムの基盤として活用できます。
