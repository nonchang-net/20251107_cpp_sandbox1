# 20251110_2228 - BiquadFilterエフェクトの実装

## 変更内容の概要

- Web Audio API BiquadFilterNodeを参考にしたBiquadFilterクラスを実装（sound/effect/biquad_filter.h/.cc）
- SimpleSynthesizerにオプショナルなフィルター機能を追加（デフォルトはオフ、オフ時は処理コストほぼゼロ）
- 8種類のフィルタータイプをサポート（Lowpass, Highpass, Bandpass, Lowshelf, Highshelf, Peaking, Notch, Allpass）

## 変更理由

ノイズ（WaveType::Noise）の聞こえ方を調節するため、エフェクト処理が必要となった。将来的にはトラック単位・楽曲単位でも指定できるよう汎用化する予定だが、まずはシンセサイザーの出力結果に対して後段でフィルター処理を設定できるように整備した。Web Audio APIを参考にすることで、使い勝手の良いAPIを提供し、将来的にWebブラウザ版への移植も容易になる。

## 作成したファイル

### 1. sound/effect/biquad_filter.h

**概要**: Biquadフィルターのヘッダファイル

```cpp
namespace MySound {

// フィルタータイプ（Web Audio API互換）
enum class BiquadFilterType {
  Lowpass,   // ローパスフィルター（低周波数を通過）
  Highpass,  // ハイパスフィルター（高周波数を通過）
  Bandpass,  // バンドパスフィルター（特定周波数帯域を通過）
  Lowshelf,  // ローシェルフフィルター（低周波数帯域をブースト/カット）
  Highshelf, // ハイシェルフフィルター（高周波数帯域をブースト/カット）
  Peaking,   // ピーキングフィルター（特定周波数帯域をブースト/カット）
  Notch,     // ノッチフィルター（特定周波数を除去）
  Allpass    // オールパスフィルター（位相特性のみ変更）
};

class BiquadFilter {
 public:
  explicit BiquadFilter(int sample_rate);

  // パラメータ設定
  void setType(BiquadFilterType type);
  void setFrequency(float frequency);  // 10Hz〜Nyquist周波数
  void setQ(float q);                  // 0.0001〜1000.0
  void setGain(float gain);            // ±40dB（Peaking/Lowshelf/Highshelfで使用）
  void setDetune(float detune);        // ±1200セント（±1オクターブ）

  // パラメータ取得
  BiquadFilterType getType() const;
  float getFrequency() const;
  float getQ() const;
  float getGain() const;
  float getDetune() const;

  // サンプル処理
  float process(float input);
  void reset();

 private:
  void updateCoefficients();
  float getDetunedFrequency() const;

  int sample_rate_;
  BiquadFilterType type_;
  float frequency_;
  float q_;
  float gain_;
  float detune_;

  // Biquadフィルター係数（Direct Form I）
  float b0_, b1_, b2_;  // フィードフォワード係数
  float a0_, a1_, a2_;  // フィードバック係数

  // フィルター状態（Direct Form I）
  float x1_, x2_;  // 入力の過去2サンプル
  float y1_, y2_;  // 出力の過去2サンプル
};

}  // namespace MySound
```

**特徴**:
- Web Audio API BiquadFilterNodeのパラメータに準拠
- Robert Bristow-Johnson "Cookbook formulae for audio EQ biquad filter coefficients"に基づく実装
- Direct Form Iによる差分方程式実装
- パラメータ変更時に自動的に係数を再計算

### 2. sound/effect/biquad_filter.cc

**概要**: Biquadフィルターの実装ファイル

**主要メソッド**:

#### コンストラクタ
```cpp
BiquadFilter::BiquadFilter(int sample_rate)
    : sample_rate_(sample_rate),
      type_(BiquadFilterType::Lowpass),
      frequency_(1000.0f),
      q_(1.0f),
      gain_(0.0f),
      detune_(0.0f),
      b0_(1.0f), b1_(0.0f), b2_(0.0f),
      a0_(1.0f), a1_(0.0f), a2_(0.0f),
      x1_(0.0f), x2_(0.0f),
      y1_(0.0f), y2_(0.0f) {
  updateCoefficients();
}
```

デフォルト: Lowpass 1000Hz Q=1.0

#### process()メソッド（Direct Form I）
```cpp
float BiquadFilter::process(float input) {
  // y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
  //                     - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]
  float output = (b0_ / a0_) * input +
                 (b1_ / a0_) * x1_ +
                 (b2_ / a0_) * x2_ -
                 (a1_ / a0_) * y1_ -
                 (a2_ / a0_) * y2_;

  // 状態を更新
  x2_ = x1_;
  x1_ = input;
  y2_ = y1_;
  y1_ = output;

  return output;
}
```

#### updateCoefficients()メソッド

各フィルタータイプに応じて係数を計算：

**Lowpass**:
```cpp
b0_ = (1.0f - cos_w0) / 2.0f;
b1_ = 1.0f - cos_w0;
b2_ = (1.0f - cos_w0) / 2.0f;
a0_ = 1.0f + alpha;
a1_ = -2.0f * cos_w0;
a2_ = 1.0f - alpha;
```

**Highpass**:
```cpp
b0_ = (1.0f + cos_w0) / 2.0f;
b1_ = -(1.0f + cos_w0);
b2_ = (1.0f + cos_w0) / 2.0f;
a0_ = 1.0f + alpha;
a1_ = -2.0f * cos_w0;
a2_ = 1.0f - alpha;
```

その他のフィルタータイプ（Bandpass, Notch, Allpass, Peaking, Lowshelf, Highshelf）も同様に実装。

### 3. sound/core/synthesizer.h の変更

SimpleSynthesizerにフィルター機能を追加：

```cpp
#include "../effect/biquad_filter.h"

class SimpleSynthesizer {
 public:
  // ... 既存のメソッド ...

  // フィルター関連メソッド
  void enableFilter();           // フィルターを有効化
  void disableFilter();          // フィルターを無効化
  bool isFilterEnabled() const;  // フィルターが有効かどうか
  BiquadFilter* getFilter();     // フィルターを取得（パラメータ調整用）

 private:
  std::unique_ptr<BiquadFilter> filter_;  // Biquadフィルター（nullptrなら無効）
  // ... 既存のメンバー変数 ...
};
```

### 4. sound/core/synthesizer.cc の変更

**初期化リスト**:
```cpp
SimpleSynthesizer::SimpleSynthesizer(int sample_rate)
    : oscillator_(std::make_unique<Oscillator>(WaveType::Sine, DEFAULT_FREQUENCY)),
      envelope_(std::make_unique<Envelope>()),
      filter_(nullptr),  // フィルターはデフォルトで無効
      stream_(nullptr),
      // ... その他の初期化 ...
```

**enableFilter()メソッド**:
```cpp
void SimpleSynthesizer::enableFilter() {
  if (!filter_) {
    filter_ = std::make_unique<BiquadFilter>(sample_rate_);
    // デフォルト設定: Lowpass 1000Hz, Q=1.0
    filter_->setType(BiquadFilterType::Lowpass);
    filter_->setFrequency(1000.0f);
    filter_->setQ(1.0f);
  }
}
```

**disableFilter()メソッド**:
```cpp
void SimpleSynthesizer::disableFilter() {
  if (filter_) {
    filter_.reset();  // unique_ptrをリセット（メモリ解放）
  }
}
```

**generateSamples()での処理**:
```cpp
// エンベロープとボリュームを適用
samples[i] = wave * envelope_value * note_volume_ * master_volume_;

// フィルター適用（有効な場合のみ）
if (filter_) {
  samples[i] = filter_->process(samples[i]);
}

// クリッピング防止
if (samples[i] > 1.0f) samples[i] = 1.0f;
if (samples[i] < -1.0f) samples[i] = -1.0f;
```

**処理コストの最適化**:
- `filter_`がnullptrの場合、`if (filter_)`の条件チェックのみ（ほぼコストゼロ）
- フィルター無効時は従来の処理フローと完全に同一

### 5. sound/sound.h の更新

```cpp
// エフェクト
#include "effect/biquad_filter.h"
```

エフェクト関連のヘッダをインクルード。

### 6. CMakeLists.txt の更新

```cmake
# sound library (Phase 2: core classes + sequencer + effect)
set(SOUND_SOURCES
    sound/core/oscillator.cc
    sound/core/envelope.cc
    sound/core/synthesizer.cc
    sound/sequencer/sequencer.cc
    sound/sequencer/multi_track_sequencer.cc
    sound/sequencer/bgm_manager.cc
    sound/effect/biquad_filter.cc  # 追加
)
```

## ビルド結果

```
[ 94%] Building CXX object CMakeFiles/sound.dir/sound/core/synthesizer.cc.o
[ 94%] Building CXX object CMakeFiles/sound.dir/sound/sequencer/sequencer.cc.o
[ 94%] Building CXX object CMakeFiles/sound.dir/sound/sequencer/multi_track_sequencer.cc.o
[ 95%] Building CXX object CMakeFiles/sound.dir/sound/sequencer/bgm_manager.cc.o
[ 95%] Building CXX object CMakeFiles/sound.dir/sound/effect/biquad_filter.cc.o
[ 96%] Linking CXX static library libsound.a
[ 96%] Built target sound
...
[100%] Built target main
```

**成功！** BiquadFilterが正常にコンパイルされ、libsound.aに組み込まれた。

## 使用例

### 基本的な使い方

```cpp
#include "sound/sound.h"

using namespace MySound;

// シンセサイザーを作成
auto synth = std::make_unique<SimpleSynthesizer>(44100);

// フィルターを有効化（デフォルト: Lowpass 1000Hz Q=1.0）
synth->enableFilter();

// フィルターパラメータを調整
auto* filter = synth->getFilter();
if (filter) {
  filter->setType(BiquadFilterType::Highpass);
  filter->setFrequency(500.0f);  // 500Hz
  filter->setQ(2.0f);            // Q値を高めに
}

// 音を鳴らす
synth->noteOn(440.0f, 1.0f);  // A4を1秒間、フィルター適用

// フィルターを無効化
synth->disableFilter();

// フィルター無効時は従来通りの音
synth->noteOn(440.0f, 1.0f);
```

### ノイズのフィルタリング

```cpp
// ノイズにローパスフィルターを適用
synth->getOscillator().setWaveType(WaveType::Noise);
synth->enableFilter();

auto* filter = synth->getFilter();
filter->setType(BiquadFilterType::Lowpass);
filter->setFrequency(2000.0f);  // 2kHz以下のノイズのみ通過
filter->setQ(0.7f);             // 緩やかなカーブ

synth->noteOn(440.0f, 2.0f);  // フィルタリングされたノイズ
```

### ハイパスフィルターでノイズから高音を抽出

```cpp
synth->getOscillator().setWaveType(WaveType::Noise);
synth->enableFilter();

auto* filter = synth->getFilter();
filter->setType(BiquadFilterType::Highpass);
filter->setFrequency(5000.0f);  // 5kHz以上のみ通過（ハイハットのような音）
filter->setQ(1.5f);

synth->noteOn(440.0f, 0.1f);  // 短いハイハット風の音
```

### バンドパスフィルターで特定周波数帯域を強調

```cpp
synth->getOscillator().setWaveType(WaveType::Noise);
synth->enableFilter();

auto* filter = synth->getFilter();
filter->setType(BiquadFilterType::Bandpass);
filter->setFrequency(1000.0f);  // 1kHz周辺を強調
filter->setQ(10.0f);            // 狭い帯域（Q値が高い）

synth->noteOn(440.0f, 1.0f);  // 1kHz周辺のノイズのみ
```

## フィルタータイプの説明

### Lowpass（ローパスフィルター）
- **用途**: 高周波数をカット、低周波数を通過
- **ノイズへの効果**: 「シュー」という高音を抑え、「ゴー」という低音のみ残す
- **パラメータ**: frequency（カットオフ周波数）、Q（急峻度）

### Highpass（ハイパスフィルター）
- **用途**: 低周波数をカット、高周波数を通過
- **ノイズへの効果**: 「ゴー」という低音を抑え、「シュー」という高音のみ残す（ハイハット風）
- **パラメータ**: frequency（カットオフ周波数）、Q（急峻度）

### Bandpass（バンドパスフィルター）
- **用途**: 特定周波数帯域のみ通過
- **ノイズへの効果**: 特定の周波数帯域のノイズのみ抽出（電話の音声のような効果）
- **パラメータ**: frequency（中心周波数）、Q（帯域幅、高いほど狭い）

### Notch（ノッチフィルター）
- **用途**: 特定周波数を除去
- **ノイズへの効果**: 特定周波数のノイズを除去（ハムノイズ除去など）
- **パラメータ**: frequency（除去する周波数）、Q（除去の鋭さ）

### Peaking（ピーキングフィルター）
- **用途**: 特定周波数帯域をブースト/カット
- **ノイズへの効果**: 特定周波数帯域のノイズを強調または抑制
- **パラメータ**: frequency（中心周波数）、Q（帯域幅）、gain（±40dB）

### Lowshelf（ローシェルフフィルター）
- **用途**: 低周波数帯域全体をブースト/カット
- **ノイズへの効果**: 低音のノイズ全体を増減
- **パラメータ**: frequency（変化が始まる周波数）、gain（±40dB）

### Highshelf（ハイシェルフフィルター）
- **用途**: 高周波数帯域全体をブースト/カット
- **ノイズへの効果**: 高音のノイズ全体を増減
- **パラメータ**: frequency（変化が始まる周波数）、gain（±40dB）

### Allpass（オールパスフィルター）
- **用途**: 位相特性のみ変更（振幅特性は変化なし）
- **ノイズへの効果**: 聴感上の変化は少ないが、他の信号と組み合わせる際に効果
- **パラメータ**: frequency、Q

## ディレクトリ構造（更新後）

```
sound/
├── sound_constants.h
├── sound.h（統合ヘッダ）
├── types/（wave_type.h, note.h）
├── core/（oscillator, envelope, synthesizer）
├── utilities/（music_utilities.h, fixed_note_sequence.h）
├── mml/（mml_parser.h）
├── sequencer/（sequencer, multi_track_sequencer, bgm_manager）
└── effect/              ← 新規
    └── biquad_filter.h/.cc  ← 新規
```

## 技術的な詳細

### Biquad（2次）フィルターとは

Biquad（Biquadratic）フィルターは、2次のIIR（Infinite Impulse Response）フィルターです。

**差分方程式**:
```
y[n] = (b0/a0)*x[n] + (b1/a0)*x[n-1] + (b2/a0)*x[n-2]
                    - (a1/a0)*y[n-1] - (a2/a0)*y[n-2]
```

**特徴**:
- 過去2サンプルの入力（x[n-1], x[n-2]）を使用（フィードフォワード）
- 過去2サンプルの出力（y[n-1], y[n-2]）を使用（フィードバック）
- 少ない計算量で効果的なフィルタリング
- Web Audio APIやVST/AUプラグインで広く使用

### Robert Bristow-Johnson Cookbook

フィルター係数の計算は、Robert Bristow-Johnsonの"Cookbook formulae for audio EQ biquad filter coefficients"に基づいています。

**基本的な計算**:
```cpp
float w0 = 2.0f * PI * frequency / sample_rate;
float cos_w0 = cos(w0);
float sin_w0 = sin(w0);
float alpha = sin_w0 / (2.0f * Q);
```

これらの値を使って、各フィルタータイプに応じた係数（b0, b1, b2, a0, a1, a2）を計算します。

### Direct Form I vs Direct Form II

今回はDirect Form Iを採用しました。

**Direct Form I**:
- 入力と出力の遅延要素が分離
- 実装がシンプル
- 丸め誤差の影響が少ない

**Direct Form II**:
- メモリ効率が良い（遅延要素が2つのみ）
- 実装がやや複雑

音質と実装の簡潔さを重視し、Direct Form Iを選択しました。

### デチューン（Detune）の実装

デチューンは周波数の微調整に使用します。

```cpp
float getDetunedFrequency() const {
  // frequency * 2^(detune/1200)
  // 1200セント = 1オクターブ = 2倍
  if (detune_ == 0.0f) {
    return frequency_;
  }
  return frequency_ * SDL_powf(2.0f, detune_ / 1200.0f);
}
```

- 1200セント = 1オクターブ
- 100セント = 半音
- デチューンを使うことで、わずかな周波数調整が可能

## パフォーマンス考察

### フィルター無効時のコスト

```cpp
if (filter_) {
  samples[i] = filter_->process(samples[i]);
}
```

`filter_`がnullptrの場合、ポインタチェック（1命令）のみ。
現代のCPUでは分岐予測が効くため、ほぼコストゼロ。

### フィルター有効時のコスト

process()メソッドは以下の演算を実行：
- 乗算: 5回
- 加算/減算: 4回
- 代入: 4回

合計13命令程度。サンプリングレート44100Hzの場合、秒間約57万命令。
現代のCPU（数GHz）では無視できるレベル。

### 係数再計算のコスト

パラメータ変更時（setFrequency()など）に係数を再計算：
- sin/cos計算: 2回
- 除算/乗算: 数回

リアルタイムでパラメータを変更しない限り、影響は少ない。

## メリット

1. **Web Audio API互換**: Webブラウザ版への移植が容易
2. **8種類のフィルター**: 幅広い音作りに対応
3. **オンオフ切り替え**: 柔軟な使用が可能
4. **低コスト**: オフ時はほぼゼロ、オン時も軽量
5. **sound/effect/フォルダ**: 今後のエフェクト追加が容易
6. **ノイズ調整**: ハイハット、スネア、キックなど打楽器音の作成に有用

## 今後の拡張予定

1. **トラック単位のフィルター**: MultiTrackSequencerの各トラックにフィルターを適用
2. **楽曲単位のフィルター**: BGMManager全体にマスターフィルターを適用
3. **他のエフェクト**: Reverb（リバーブ）、Delay（ディレイ）、Distortion（歪み）など
4. **エフェクトチェーン**: 複数のエフェクトを直列接続
5. **パラメータのオートメーション**: 時間経過でパラメータを自動変化

## まとめ

Web Audio APIを参考にしたBiquadFilterを実装し、SimpleSynthesizerにオプショナルなフィルター機能として統合しました。デフォルトはオフで、オフ時の処理コストはほぼゼロを実現しています。8種類のフィルタータイプをサポートし、特にノイズのフィルタリングによる打楽器音の作成に有用です。今後、トラック単位・楽曲単位での適用や、他のエフェクトの追加も計画しています。
