# 作業レポート - 2025/11/09 11:28

## 変更内容の概要

- スプライトシートからキャラクターを表示するSpriteRendererコンポーネントを実装しました
- タイルベースのアニメーションを実現するSpriteAnimatorコンポーネントを実装しました
- カーソルキーで移動できるKeyboardInputコンポーネントを実装しました
- test_impl_3.hでプレイヤーキャラクターを作成し、歩行アニメーションと移動操作を実装しました

## 変更理由

- **スプライトベースのゲーム表現**: 8x8ピクセルのタイルが並んだスプライトシートから特定のタイルを表示できるようにするため
- **アニメーションシステム**: キャラクターの歩行パターンなど、複数のフレームを切り替えるアニメーション機能を実現するため
- **プレイヤー操作**: カーソルキーで上下左右に移動できるインタラクティブな操作を実装するため

## 技術的な実装詳細

### 1. SpriteRendererコンポーネント (component.h)

```cpp
/**
 * @brief スプライトシートから特定のタイルを描画するコンポーネント
 */
class SpriteRenderer : public Component {
 public:
  SpriteRenderer(SDL_Texture* texture, int tile_size, int tile_x = 0,
                 int tile_y = 0)
      : texture_(texture), tile_size_(tile_size), tile_x_(tile_x),
        tile_y_(tile_y) {}

  void render(Entity* entity, SDL_Renderer* renderer) override;

  void setTile(int tile_x, int tile_y) {
    tile_x_ = tile_x;
    tile_y_ = tile_y;
  }

 private:
  SDL_Texture* texture_;  // スプライトシートのテクスチャ
  int tile_size_;         // タイル1つのサイズ
  int tile_x_, tile_y_;   // 描画するタイルのグリッド座標
};
```

**特徴:**
- テクスチャをグリッド状のタイルに分割
- タイル座標(tile_x, tile_y)で描画位置を指定
- Entityのスケール、カメラ変換に対応

**render()の実装 (entity_manager.h):**

```cpp
inline void SpriteRenderer::render(Entity* entity, SDL_Renderer* renderer) {
  if (!texture_) return;

  // ワールド座標とスケールを取得
  auto [world_x, world_y] = entity->getWorldPosition();
  auto [scale_x, scale_y] = entity->getWorldScale();

  // カメラ変換
  float screen_x = world_x;
  float screen_y = world_y;
  if (auto* camera = entity->getRenderCamera()) {
    auto [sx, sy] = camera->worldToScreen(world_x, world_y);
    screen_x = sx;
    screen_y = sy;
  }

  // スプライトシート上のソース矩形を計算
  SDL_FRect src_rect;
  src_rect.x = static_cast<float>(tile_x_ * tile_size_);
  src_rect.y = static_cast<float>(tile_y_ * tile_size_);
  src_rect.w = static_cast<float>(tile_size_);
  src_rect.h = static_cast<float>(tile_size_);

  // 描画先の矩形を計算（スケール適用）
  SDL_FRect dst_rect;
  dst_rect.x = screen_x;
  dst_rect.y = screen_y;
  dst_rect.w = tile_size_ * scale_x;
  dst_rect.h = tile_size_ * scale_y;

  // テクスチャを描画
  SDL_RenderTexture(renderer, texture_, &src_rect, &dst_rect);
}
```

**描画の流れ:**
1. ワールド座標を取得
2. カメラで画面座標に変換
3. スプライトシート上のソース矩形を計算（タイル座標 × タイルサイズ）
4. 描画先の矩形を計算（スケール適用）
5. SDL_RenderTexture()で部分テクスチャを描画

### 2. SpriteAnimatorコンポーネント (component.h)

```cpp
/**
 * @brief スプライトアニメーションを管理するコンポーネント
 */
class SpriteAnimator : public Component {
 public:
  SpriteAnimator(const std::vector<std::pair<int, int>>& frames,
                 Uint64 frame_duration = 500)
      : frames_(frames), frame_duration_(frame_duration), current_frame_(0),
        timer_(0) {}

  void update(Entity* entity, Uint64 delta_time) override;

 private:
  std::vector<std::pair<int, int>> frames_;  // フレームリスト（タイル座標）
  Uint64 frame_duration_;                    // 1フレームの表示時間
  size_t current_frame_;                     // 現在のフレーム番号
  Uint64 timer_;                             // タイマー
};
```

**update()の実装 (entity_manager.h):**

```cpp
inline void SpriteAnimator::update(Entity* entity, Uint64 delta_time) {
  if (frames_.empty()) return;

  // SpriteRendererコンポーネントを取得
  auto* sprite_renderer = entity->getComponent<SpriteRenderer>();
  if (!sprite_renderer) return;

  // タイマーを進める
  timer_ += delta_time;

  // フレーム切り替えが必要かチェック
  if (timer_ >= frame_duration_) {
    timer_ -= frame_duration_;

    // 次のフレームへ
    current_frame_ = (current_frame_ + 1) % frames_.size();

    // SpriteRendererのタイルを更新
    auto [tile_x, tile_y] = frames_[current_frame_];
    sprite_renderer->setTile(tile_x, tile_y);
  }
}
```

**アニメーションの仕組み:**
1. 毎フレーム、タイマーを進める
2. タイマーがframe_durationを超えたら次のフレームへ
3. SpriteRendererのタイル座標を更新
4. フレーム番号は循環（0→1→2→...→0）

### 3. KeyboardInputコンポーネント (component.h)

```cpp
/**
 * @brief キーボード入力で移動を制御するコンポーネント
 */
class KeyboardInput : public Component {
 public:
  explicit KeyboardInput(float speed = 100.0f) : speed_(speed) {}

  void update(Entity* entity, Uint64 delta_time) override;

 private:
  float speed_;  // 移動速度
};
```

**update()の実装 (entity_manager.h):**

```cpp
inline void KeyboardInput::update(Entity* entity, Uint64 delta_time) {
  // VelocityMoveコンポーネントを取得
  auto* velocity = entity->getComponent<VelocityMove>();
  if (!velocity) return;

  // キーボード状態を取得
  const bool* keys = SDL_GetKeyboardState(nullptr);

  // 移動方向を計算
  float vx = 0.0f;
  float vy = 0.0f;

  if (keys[SDL_SCANCODE_UP] || keys[SDL_SCANCODE_W]) {
    vy -= speed_;
  }
  if (keys[SDL_SCANCODE_DOWN] || keys[SDL_SCANCODE_S]) {
    vy += speed_;
  }
  if (keys[SDL_SCANCODE_LEFT] || keys[SDL_SCANCODE_A]) {
    vx -= speed_;
  }
  if (keys[SDL_SCANCODE_RIGHT] || keys[SDL_SCANCODE_D]) {
    vx += speed_;
  }

  // 速度を設定
  velocity->setVelocity(vx, vy);
}
```

**入力処理の流れ:**
1. SDL_GetKeyboardState()でキーボード状態を取得
2. カーソルキー（またはWASD）の押下状態をチェック
3. 速度ベクトル(vx, vy)を計算
4. VelocityMoveコンポーネントの速度を更新

**対応キー:**
- UP/W: 上移動（vy - speed）
- DOWN/S: 下移動（vy + speed）
- LEFT/A: 左移動（vx - speed）
- RIGHT/D: 右移動（vx + speed）

### 4. プレイヤーキャラクターの実装 (test_impl_3.h)

**initializeEntities()に追加:**

```cpp
// レイヤー5: プレイヤーキャラクター
if (texture_) {
  auto player = std::make_unique<Entity>(5);
  player->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);

  // 座標・スケール
  player->addComponent(std::make_unique<Locator>(320.0f, 240.0f));
  player->addComponent(std::make_unique<Scaler>(4.0f, 4.0f));  // 8x8を32x32に拡大

  // 移動・入力
  player->addComponent(std::make_unique<VelocityMove>(0.0f, 0.0f));
  player->addComponent(std::make_unique<KeyboardInput>(100.0f));  // 100px/秒

  // スプライト描画（初期タイル: x=0, y=1）
  player->addComponent(std::make_unique<SpriteRenderer>(texture_, 8, 0, 1));

  // 歩行アニメーション（x:0,y:1 と x:1,y:1 を500msごとに切り替え）
  std::vector<std::pair<int, int>> walk_frames = {{0, 1}, {1, 1}};
  player->addComponent(std::make_unique<SpriteAnimator>(walk_frames, 500));

  entity_manager_.addEntity(std::move(player));
}
```

**コンポーネント構成:**
- **Locator**: 初期位置(320, 240) - 画面中央
- **Scaler**: 4倍スケール - 8x8ピクセルを32x32に拡大表示
- **VelocityMove**: 速度による移動（初期速度0）
- **KeyboardInput**: カーソルキーで速度を制御（100px/秒）
- **SpriteRenderer**: スプライトシート描画（タイルサイズ8、初期タイル(0,1)）
- **SpriteAnimator**: 歩行アニメーション（(0,1)↔(1,1)を500msごと）

**レイヤー配置:**
- レイヤー5: 背景(0)、動く四角(1)、点滅(2)、回転(3-4)の後、UI(10)の前
- 適切な描画順序を確保

## コンポーネントシステムの利点

| 項目 | 実装方法 |
|------|----------|
| スプライト描画 | SpriteRenderer |
| アニメーション | SpriteAnimator |
| キーボード入力 | KeyboardInput |
| 移動 | VelocityMove |
| 拡大表示 | Scaler |

**各コンポーネントの責任:**
- **SpriteRenderer**: スプライトシートから特定タイルを描画
- **SpriteAnimator**: SpriteRendererのタイル座標を時間経過で変更
- **KeyboardInput**: キーボード状態を読み取り、VelocityMoveを制御
- **VelocityMove**: 速度に基づいてLocatorの座標を更新
- **Scaler**: 描画サイズを変更

**コンポーネント間の連携:**
```
KeyboardInput → VelocityMove → Locator → SpriteRenderer
                                            ↑
                                   SpriteAnimator
```

## 動作確認

- ✅ ビルド成功
- ✅ SpriteRendererでスプライトシート上のタイルを表示
- ✅ SpriteAnimatorで歩行パターンがアニメーション
- ✅ KeyboardInputでカーソルキー移動可能
- ✅ スケール適用で8x8ピクセルを拡大表示

## 実装の詳細

### SDL3のテクスチャ描画

**SDL_RenderTexture()の使用:**
```cpp
SDL_RenderTexture(renderer, texture, &src_rect, &dst_rect);
```

- `src_rect`: スプライトシート上の切り出し範囲
- `dst_rect`: 画面上の描画先範囲

**部分テクスチャの描画:**
- スプライトシートから特定のタイルだけを切り出して描画
- タイル座標(tile_x, tile_y)からピクセル座標を計算
- スケールを適用して拡大/縮小表示

### アニメーションのタイミング制御

**フレーム切り替えのロジック:**
```cpp
timer_ += delta_time;
if (timer_ >= frame_duration_) {
  timer_ -= frame_duration_;
  current_frame_ = (current_frame_ + 1) % frames_.size();
}
```

- delta_time: 前フレームからの経過時間（ミリ秒）
- frame_duration: 1フレームの表示時間
- タイマーがframe_durationを超えたら次のフレームへ
- 余剰時間は次のフレームに持ち越し（timer_ -= frame_duration_）

### キーボード入力の即時反映

**SDL_GetKeyboardState():**
```cpp
const bool* keys = SDL_GetKeyboardState(nullptr);
if (keys[SDL_SCANCODE_UP]) {
  vy -= speed_;
}
```

- イベントベースではなく、状態ベースで入力を取得
- 複数キー同時押しに対応（斜め移動可能）
- 毎フレーム速度をリセットして、押下キーに応じて速度を設定

## 次のステップの提案

このスプライトシステムにより、以下の機能が実装可能になりました：

1. **複雑なアニメーション**: フレームリストを拡張して多段階アニメーション
2. **移動方向に応じたスプライト変更**: KeyboardInputで移動方向を判定し、SpriteAnimatorのフレームリストを切り替え
3. **敵キャラクター**: 同じコンポーネントを組み合わせて敵を配置
4. **アイテム**: SpriteRendererのみで静止画スプライト
5. **タイルマップ**: 複数のSpriteRendererエンティティでマップを構築

これで、本格的なスプライトベースのゲームを構築する基盤が整いました。
