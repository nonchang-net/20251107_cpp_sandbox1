# 20251110_1205 - FixedNoteSequenceによる完全なconstexpr対応

## 変更内容の概要

- `FixedNoteSequence`クラスを新規作成し、`std::array`ベースの固定長コンテナでMML音符シーケンスを保存できるようにした
- MMLパーサーが`FixedNoteSequence`を返すように変更し、完全な`constexpr`変数として保存可能にした
- Sequencerが`FixedNoteSequence`と`std::span`を受け取れるように拡張し、あらゆるコンテナに対応させた

## 変更理由

前回の実装では`std::vector`を使っていたため、コンパイル時定数として保存できなかった（ヒープ割り当てが必要なため）。`std::array`ベースの固定長コンテナを使うことで、完全な`constexpr`変数として保存できるようになり、MMLのパース処理が**確実にコンパイル時に実行される**ようになった。

## 変更箇所

### game_manager/sound_synthesizer.h

1. **NoteDataにデフォルトコンストラクタを追加**:
   ```cpp
   constexpr NoteData()
       : note(Note::C), octave(4), duration(0.0f), is_rest(true), wave_type(WaveType::Sine) {}
   ```
   - `std::array`の初期化に必要

2. **FixedNoteSequenceクラスを新規作成**:
   ```cpp
   class FixedNoteSequence {
    public:
     static constexpr size_t MAX_NOTES = 256;  // 最大音符数

     constexpr bool push_back(const NoteData& note);
     constexpr size_t size() const;
     constexpr bool empty() const;
     constexpr const NoteData& operator[](size_t index) const;
     constexpr const NoteData* data() const;
     constexpr const NoteData* begin() const;
     constexpr const NoteData* end() const;

    private:
     size_t size_;
     std::array<NoteData, MAX_NOTES> notes_;
   };
   ```
   - `std::array<NoteData, 256>`を内部で使用
   - 全てのメソッドを`constexpr`化
   - `std::vector`風のインターフェース

3. **MMLParser::parse()の戻り値を変更**:
   ```cpp
   static constexpr FixedNoteSequence parse(const std::string& mml)
   ```
   - `std::vector<NoteData>`から`FixedNoteSequence`に変更
   - `emplace_back`を`push_back`に変更

4. **ユーザー定義リテラルの戻り値を変更**:
   ```cpp
   constexpr FixedNoteSequence operator""_mml(const char* str, size_t len)
   ```
   - `std::vector<NoteData>`から`FixedNoteSequence`に変更

5. **ヘッダーに`<array>`と`<span>`を追加**:
   ```cpp
   #include <array>
   #include <span>
   ```

6. **Sequencerに新しいsetSequenceメソッドを追加**:
   ```cpp
   // FixedNoteSequence版
   void setSequence(const FixedNoteSequence& notes);

   // std::span版（あらゆるコンテナに対応）
   void setSequence(std::span<const NoteData> notes);
   ```
   - `std::vector`版も残して互換性を維持
   - `std::span`によって、配列、`std::vector`、`FixedNoteSequence`など、あらゆるコンテナに対応

### game/test_impl_3.h

1. **MMLプリセットを完全なconstexpr変数として定義**:
   ```cpp
   namespace MMLPresets {
     constexpr auto frog_song = "t120 o4 l4 @0 cdefedec"_mml;
     constexpr auto oscillator_demo = "t140 o4 l8 @1 cdefgab>c r4 @2 <bagfedc"_mml;

     // コンパイル時評価の確認（static_assertで強制的にコンパイル時評価）
     static_assert(frog_song.size() == 8, "Frog song should have 8 notes");
     static_assert(oscillator_demo.size() == 16, "Oscillator demo should have 16 notes (including rest)");
   }
   ```
   - `inline const`から`constexpr`に変更
   - `static_assert`でコンパイル時評価を検証

## 技術的な詳細

### std::vectorとstd::arrayの違い

| 特徴 | std::vector | std::array |
|------|------------|-----------|
| サイズ | 動的（実行時） | 固定（コンパイル時） |
| メモリ | ヒープ | スタック |
| constexpr変数 | ❌ 保存不可 | ✅ 保存可能 |
| constexpr関数内 | ✅ 使用可能 | ✅ 使用可能 |

### constexpr評価の検証

`static_assert`を使って、コンパイル時に音符数を検証しています：

```cpp
static_assert(frog_song.size() == 8, "Frog song should have 8 notes");
```

この`static_assert`がコンパイルできたということは、以下が証明されました：
1. `frog_song`はコンパイル時に評価されている
2. `size()`メソッドがコンパイル時に呼び出せる
3. MMLパーサーが完全にコンパイル時に実行されている

### std::spanによる柔軟性

`std::span<const NoteData>`を受け取ることで、以下の全てに対応：
- `std::vector<NoteData>`
- `FixedNoteSequence`
- `std::array<NoteData, N>`
- 生の配列 `NoteData[]`

## 使用例

```cpp
// コンパイル時定数として保存（完全なconstexpr）
constexpr auto melody = "t120 o4 l4 cdefgab"_mml;

// 音符数をコンパイル時に取得
static_assert(melody.size() > 0);

// Sequencerで再生
sequencer->setSequence(melody);
sequencer->play();

// 実行時にMMLをパースすることも可能（後方互換性）
auto runtime_melody = "t140 o5 l8 edcdeee"_mml;
sequencer->setSequence(runtime_melody);

// std::vectorも引き続き使える
std::vector<NoteData> notes;
notes.push_back(NoteData(Note::C, 4, 0.5f));
sequencer->setSequence(notes);
```

## パフォーマンスへの影響

- **コンパイル時**: MMLパース処理が実行される（コンパイル時間が若干増加）
- **実行時**: MMLパース処理が**完全にゼロ**（すでにパース済みのデータ）
- **メモリ**: 固定サイズ配列（256音符分 = 約6KB）だが、未使用領域は最適化で削減される可能性がある

## 制限事項

- 最大音符数: 256音符（`FixedNoteSequence::MAX_NOTES`で変更可能）
- 256音符を超えるMMLは`push_back`が失敗する（現在はサイレント失敗）

## テスト方法

1. ビルドして実行: `cmake --build build && ./build/main`
2. **Enterキー**: カエルの歌が再生される（コンパイル時評価版）
3. **Mキー**: オシレーター変更デモが再生される（コンパイル時評価版）
4. `static_assert`がコンパイルできることを確認（コンパイル時評価の証明）
