# 作業レポート - 2025/11/08 22:15

## 変更内容の概要

- Entity に親子関係（階層構造）の機能を追加し、シーングラフを構築できるようにしました
- 座標系をローカル座標とワールド座標に分離し、親の座標・回転の影響を子が受けるようにしました
- EntityManager に常に存在する root エンティティを追加し、全てのエンティティは root の子孫として配置されるようにしました

## 変更理由

- **階層的な座標系**: 親子関係により、パーツの組み合わせや複雑なオブジェクト（例: キャラクターの手足、回転する歯車の組み合わせ）を簡単に表現できるようになります
- **座標変換の自動化**: 子は親の座標・回転を自動的に継承するため、相対的な位置関係を維持したまま親を動かすことができます
- **削除の連鎖**: 親が削除されると子も自動的に削除されるため、複雑なオブジェクトのライフサイクル管理が簡単になります
- **動的な付け替え**: 実行時に親子関係を変更できるため、オブジェクトの持ち替え（例: アイテムの装備・解除）などを実現できます

## 技術的な実装詳細

### 1. Entity クラスの拡張

**親子関係の管理:**
```cpp
class Entity {
  // 親子関係
  Entity* parent_;  // 親エンティティへのポインタ（非所有）
  std::vector<std::unique_ptr<Entity>> children_;  // 子エンティティ（所有）

  // ローカル座標系
  float local_x_, local_y_;  // 親からの相対位置
  float local_angle_;        // 親からの相対回転角度

  // APIメソッド
  void addChild(std::unique_ptr<Entity> child);
  std::unique_ptr<Entity> removeChild(Entity* child);
  void setParent(Entity* new_parent);
};
```

**座標変換:**
```cpp
// ワールド座標の計算（再帰的に親の座標を考慮）
std::pair<float, float> getWorldPosition() const {
  if (!parent_) {
    return {local_x_, local_y_};  // 親がいない場合はローカル座標=ワールド座標
  }

  // 親のワールド座標と回転を取得
  auto [parent_x, parent_y] = parent_->getWorldPosition();
  float parent_angle = parent_->getWorldAngle();

  // 回転行列で親の座標系に変換
  float rad = parent_angle * (M_PI / 180.0f);
  float rotated_x = local_x_ * cos(rad) - local_y_ * sin(rad);
  float rotated_y = local_x_ * sin(rad) + local_y_ * cos(rad);

  return {parent_x + rotated_x, parent_y + rotated_y};
}

// ワールド回転角度の計算
float getWorldAngle() const {
  if (!parent_) {
    return local_angle_;
  }
  return parent_->getWorldAngle() + local_angle_;  // 親の回転を加算
}
```

**更新と描画の再帰:**
```cpp
// 子を含めて更新
void updateWithChildren(Uint64 delta_time) {
  if (active_) {
    update(delta_time);  // 自分自身の更新
    for (auto& child : children_) {
      child->updateWithChildren(delta_time);  // 子の更新（再帰）
    }
  }
}

// 子を含めて描画
void renderWithChildren(SDL_Renderer* renderer, size_t visible_flag_index = 0) {
  if (active_ && getStateFlag(visible_flag_index)) {
    render(renderer);  // 自分自身の描画
  }
  for (auto& child : children_) {
    child->renderWithChildren(renderer, visible_flag_index);  // 子の描画（再帰）
  }
}
```

### 2. RootEntity の導入

```cpp
class RootEntity : public Entity {
 public:
  RootEntity() : Entity(0) {
    setLocalPosition(0.0f, 0.0f);  // 画面中央（座標原点）
    setStateFlag(0, 1);  // デフォルトで表示
  }

  void update(Uint64 delta_time) override {
    // rootは何もしない（子のみ更新）
  }

  void render(SDL_Renderer* renderer) override {
    // rootは何も描画しない（子のみ描画）
  }
};
```

root エンティティは:
- 常に座標 (0, 0) に配置（画面中央）
- 自身は何も描画しない
- 全てのエンティティはこの root の子孫として配置される

### 3. EntityManager の変更

**ツリーベースの管理:**
```cpp
class EntityManager {
  std::unique_ptr<RootEntity> root_;  // ルートエンティティ

  // エンティティを root の子として追加
  void addEntity(EntityPtr entity) {
    root_->addChild(std::move(entity));
  }

  // 更新は root から再帰的に
  void updateAll(Uint64 delta_time) {
    root_->updateWithChildren(delta_time);
  }

  // 描画はツリーから全エンティティを集めてレイヤー順にソート
  void renderAll(SDL_Renderer* renderer, size_t visible_flag_index = 0) {
    std::vector<Entity*> all_entities;
    collectEntities(root_.get(), all_entities);  // ツリーを走査

    // レイヤー順にソート
    std::sort(all_entities.begin(), all_entities.end(),
              [](const Entity* a, const Entity* b) {
                return a->getLayer() < b->getLayer();
              });

    // 描画
    for (Entity* entity : all_entities) {
      if (entity->isActive() && entity->getStateFlag(visible_flag_index)) {
        entity->render(renderer);
      }
    }
  }
};
```

**ポイント:**
- レイヤーベースの描画順は維持（後方互換性）
- 内部的にはツリー構造で管理
- 描画時にツリーを走査してレイヤー順にソート

### 4. 既存 Entity クラスの対応

**RectEntity, RotateRectEntity, TextEntity の変更:**
- `center_x_`, `center_y_`, `angle_` など独自の座標管理を削除
- 基底クラスの `local_x_`, `local_y_`, `local_angle_` を使用
- `setPosition()` → `setLocalPosition()` を呼ぶ
- `render()` 時に `getWorldPosition()`, `getWorldAngle()` を使用

例（RotateRectEntity の render）:
```cpp
void render(SDL_Renderer* renderer) override {
  // ワールド座標と回転角度を取得
  auto [world_x, world_y] = getWorldPosition();
  float world_angle = getWorldAngle();

  // ワールド座標で頂点を計算して描画
  SDL_FPoint vertices[4];
  calculateRotatedVertices(vertices, world_x, world_y, world_angle);
  // ... SDL_RenderGeometry で描画
}
```

## 使用例（親子関係のデモ）

```cpp
// 親エンティティ（回転する台座）
auto parent = std::make_unique<RotateRectEntity>(
    1, 0, 0, 100, 100, SDL_Color{255, 100, 100, 255});
parent->setAngularVelocity(30.0f);  // 30度/秒で回転

// 子エンティティ1（親の上に乗る矩形、親からの相対位置）
auto child1 = std::make_unique<RectEntity>(
    2, 0, -60, 40, 40, SDL_Color{100, 255, 100, 255});
child1->setVelocity(0.5f, 0.0f);  // ローカル座標でゆっくり移動

// 子エンティティ2（子1の上にさらに乗る矩形）
auto child2 = std::make_unique<RectEntity>(
    3, 0, -30, 20, 20, SDL_Color{100, 100, 255, 255});
child2->setAngularVelocity(60.0f);  // 独自に回転

// 階層構造を構築
Entity* parent_ptr = parent.get();
Entity* child1_ptr = child1.get();

entity_manager.addEntity(std::move(parent));  // root の子として追加
parent_ptr->addChild(std::move(child1));      // parent の子として追加
child1_ptr->addChild(std::move(child2));      // child1 の子として追加
```

この例では:
- `parent` が回転すると、`child1` と `child2` も一緒に回転
- `child1` がローカル座標で移動すると、`child2` も一緒に移動
- `child2` は自分自身も回転するので、複雑な動きになる
- `parent` を削除すると、`child1` と `child2` も自動的に削除される

## メリット

| 項目 | 変更前 | 変更後 |
|------|--------|--------|
| 座標系 | グローバル座標のみ | ローカル/ワールド座標の分離 |
| 階層構造 | フラット（レイヤーのみ） | ツリー構造（親子関係） |
| 複合オブジェクト | 手動で座標計算が必要 | 親子関係で自動的に追従 |
| 削除処理 | 個別に削除 | 親を削除すると子も自動削除 |
| 回転の継承 | なし | 親の回転を子が自動的に継承 |
| 動的な再配置 | 困難 | setParent()で簡単に付け替え可能 |

## 後方互換性

- 既存のコードは変更なしで動作（addEntity() は root の子として追加される）
- レイヤーベースの描画順は維持
- 座標指定は従来通り（内部的にローカル座標として扱われる）

## 今後の展開

この階層構造システムにより、以下のような表現が可能になります：

1. **複雑なキャラクター**: 体・腕・脚をパーツとして配置し、体を回転させると全体が回転
2. **回転する歯車の連結**: 親歯車が回転すると子歯車も連動
3. **装備システム**: アイテムをキャラクターの子として追加し、キャラクターの動きに追従
4. **カメラ効果**: root を動かすことで画面全体をスクロール・回転可能
5. **パーティクルシステム**: エミッターを親として、パーティクルを子として管理

これにより、game_manager ライブラリの表現力と柔軟性が飛躍的に向上しました。
