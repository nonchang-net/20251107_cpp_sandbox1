# 20251110_1447 - 3段階のボリューム制御機能実装

## 変更内容の概要

- シンセサイザー単位のマスターボリューム設定機能を追加
- シーケンサー単位のボリューム設定機能を追加
- ノート単位（noteOn呼び出し単位）のボリューム指定機能を追加
- MMLパーサーにvコマンド（v0〜v15）を追加してノート単位のボリューム指定をサポート

## 変更理由

複数のサウンドを扱う際に、個別のボリューム制御が必要になる。3つのレベルでボリューム制御を実装することで、柔軟な音量調整が可能になった。最終的なボリュームは「マスターボリューム × シーケンサーボリューム × ノートボリューム」として計算される。

## 変更箇所

### game_manager/sound_synthesizer.h

#### 1. SimpleSynthesizerクラス

**メンバー変数の追加**:
```cpp
float note_volume_;      // ノート単位のボリューム（0.0〜1.0）
float master_volume_;    // マスターボリューム（0.0〜1.0）
```

**マスターボリュームのgetter/setter追加**:
```cpp
void setVolume(float volume);
float getVolume() const;
```

**noteOn()メソッドにボリュームパラメータを追加**:
```cpp
void noteOn(float frequency, float duration = 0.0f, float volume = 1.0f);
```
- 第3引数としてノート単位のボリューム（0.0〜1.0）を指定可能
- デフォルト値は1.0（最大音量）

**generateSamples()でボリューム適用**:
```cpp
// 最終ボリューム = 波形 × エンベロープ × ノートボリューム × マスターボリューム
samples[i] = wave * envelope_value * note_volume_ * master_volume_;
```

#### 2. NoteDataクラス

**ボリュームフィールドを追加**:
```cpp
struct NoteData {
  Note note;
  int octave;
  float duration;
  bool is_rest;
  WaveType wave_type;
  float volume;      // NEW: ボリューム（0.0〜1.0）

  constexpr NoteData(Note n, int oct, float dur, bool rest = false,
                    WaveType wave = WaveType::Sine, float vol = 1.0f);
};
```

#### 3. MMLParserクラス

**vコマンドのサポートを追加**:
```cpp
// ボリューム設定 (v0〜v15など)
if (c == 'v') {
  i++;
  int vol = parseNumber(mml, i);
  // v0〜v15を0.0〜1.0にマップ
  volume = static_cast<float>(vol) / 15.0f;
  if (volume < 0.0f) volume = 0.0f;
  if (volume > 1.0f) volume = 1.0f;
  continue;
}
```

**音符と休符の生成時にボリューム情報を含める**:
```cpp
// 休符
result.push_back(NoteData(Note::C, 0, duration, true, wave_type, volume));

// 音符
result.push_back(NoteData(note, octave, duration, false, wave_type, volume));
```

#### 4. Sequencerクラス

**メンバー変数の追加**:
```cpp
float volume_;  // シーケンサーのボリューム（0.0〜1.0）
```

**ボリュームのgetter/setter追加**:
```cpp
void setVolume(float volume);
float getVolume() const;
```

**addNote()メソッドにボリュームパラメータを追加**:
```cpp
void addNote(Note note, int octave, int note_division, bool dotted = false,
             WaveType wave_type = WaveType::Sine, float volume = 1.0f);
```

**playCurrentNote()でボリューム計算**:
```cpp
// ボリュームを計算（シーケンサーボリューム × ノートボリューム）
float final_volume = volume_ * note_data.volume;

// 音符を再生
float frequency = note_data.getFrequency();
synthesizer_->noteOn(frequency, note_data.duration, final_volume);
```

### game/test_impl_3.h

**ボリュームデモのMMLプリセットを追加**:
```cpp
namespace MMLPresets {
  constexpr auto volume_demo = "t120 o4 l8 @0 v15 cccc v12 cccc v8 cccc v4 cccc v0 cccc"_mml;
  static_assert(volume_demo.size() == 20, "Volume demo should have 20 notes");
}
```

**Vキーでボリュームデモを再生**:
```cpp
case SDL_SCANCODE_V: {
  // Vキー: ボリュームデモ（v15→v12→v8→v4→v0でフェードアウト）
  sequencer_->clear();
  sequencer_->setSequence(MMLPresets::volume_demo);
  sequencer_->play();
  break;
}
```

## ボリューム制御の階層構造

```
最終出力ボリューム = マスターボリューム × シーケンサーボリューム × ノートボリューム
                   (Synthesizer)    (Sequencer)        (NoteData)
```

### 使用例

```cpp
// 1. シンセサイザーのマスターボリュームを設定（全体の音量）
synthesizer->setVolume(0.8f);  // 80%の音量

// 2. シーケンサーのボリュームを設定（シーケンス全体の音量）
sequencer->setVolume(0.5f);    // 50%の音量

// 3. MMLでノート単位のボリュームを指定
auto notes = "t120 o4 @0 v15 c v12 d v8 e v4 f v0 g"_mml;
// v15=100%, v12=80%, v8=53%, v4=27%, v0=0%

// 最終的な音量計算例:
// C音: 0.8 × 0.5 × 1.0 = 0.40 (40%)
// D音: 0.8 × 0.5 × 0.8 = 0.32 (32%)
// E音: 0.8 × 0.5 × 0.53 = 0.212 (21.2%)
// F音: 0.8 × 0.5 × 0.27 = 0.108 (10.8%)
// G音: 0.8 × 0.5 × 0.0 = 0.0 (0% = 無音)
```

## MMLのvコマンド仕様

- **書式**: `v数字`
- **範囲**: v0〜v15（16段階）
- **マッピング**: v0=0.0（無音）、v15=1.0（最大音量）、線形補間
- **例**:
  - `v15` = 1.0（100%）
  - `v12` = 0.8（80%）
  - `v8` = 0.533（53.3%）
  - `v4` = 0.267（26.7%）
  - `v0` = 0.0（0% = 無音）

## テスト方法

1. ビルドして実行: `cmake --build build && ./build/main`
2. **Vキー**: ボリュームデモを再生（v15→v12→v8→v4→v0でフェードアウト）
3. 同じC音が5段階のボリュームで4回ずつ（計20音）再生される

## 使用シーン

- **マスターボリューム**: BGMとSEの全体音量を調整
- **シーケンサーボリューム**: BGMとSEの個別音量バランスを調整
- **ノートボリューム**: 音楽的な表現（クレッシェンド、デクレッシェンド、アクセントなど）

## 技術的な詳細

- ボリューム値は常に0.0〜1.0の範囲にクランプされる（`SDL_clamp`使用）
- 浮動小数点演算のため、厳密に0.0にならない可能性がある（実用上問題なし）
- constexpr対応により、MMLのvコマンドもコンパイル時に評価される
