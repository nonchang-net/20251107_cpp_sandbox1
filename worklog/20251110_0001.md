# 作業レポート - 2025/11/10 00:01

## 変更内容の概要

- SDL3のオーディオAPIについて調査し、シンセサイザー実装に必要な情報をまとめました
- 公式ドキュメント、サンプルコード、ベストプラクティスを収集しました
- モダンなSDL3のオーディオストリーム方式とコールバック方式の違いを理解しました

## 調査理由

- **オーディオ機能の実装準備**: 将来的にゲームにサウンド効果や音楽を追加するため、SDL3のオーディオAPIを理解する必要がありました
- **シンセサイザー実装の基礎**: 手続き的な音声生成（プロシージャルサウンド）を実装するための技術的基盤を確立したい
- **モダンなAPI理解**: SDL3はSDL2から大きく変更されており、新しいアーキテクチャを理解する必要がありました

## SDL3オーディオAPI調査結果

---

# SDL3オーディオAPI調査レポート

## 1. SDL3オーディオAPIの基本

### 1.1 中核となる概念

SDL3のオーディオシステムは**SDL_AudioStream**を中心に設計されています。SDL2とは大きく異なり、すべてのオーディオ処理がストリームを介して行われます。

**主要な特徴:**

- **論理デバイス**: 1つの物理デバイスを複数回開くことができ、それぞれが独立した論理デバイスIDを持つ
- **オーディオストリーム**: 任意のフォーマット、任意の量のデータを受け入れ、必要に応じて自動変換
- **自動ミキシング**: デバイスにバインドされた複数のストリームを自動的にミックス

### 1.2 主要なデータ構造

#### SDL_AudioSpec構造体

オーディオデータのフォーマットを指定します。

```cpp
typedef struct SDL_AudioSpec {
  SDL_AudioFormat format;  // オーディオデータフォーマット
  int channels;            // チャンネル数（1=モノラル、2=ステレオ）
  int freq;                // サンプリングレート（Hz）
} SDL_AudioSpec;
```

**使用例:**

```cpp
SDL_AudioSpec spec;
spec.channels = 1;           // モノラル
spec.format = SDL_AUDIO_F32; // 32ビット浮動小数点
spec.freq = 8000;            // 8000Hz
```

#### SDL_AudioFormat列挙型

利用可能なオーディオフォーマット:

- **SDL_AUDIO_U8**: 8ビット符号なし整数
- **SDL_AUDIO_S8**: 8ビット符号付き整数
- **SDL_AUDIO_S16**: 16ビット符号付き整数（ネイティブエンディアン）
- **SDL_AUDIO_S32**: 32ビット符号付き整数（ネイティブエンディアン）
- **SDL_AUDIO_F32**: 32ビット浮動小数点（ネイティブエンディアン）

**推奨フォーマット:**

- **SDL_AUDIO_S16**: 互換性が高く、デフォルトとして安全
- **SDL_AUDIO_F32**: モダンなシステムで推奨、計算が簡単（-1.0〜1.0の範囲）

### 1.3 オーディオデバイスの開き方

#### 方法1: SDL_OpenAudioDeviceStream（推奨）

単一のストリームのみを使用する場合の簡略化されたAPI。

```cpp
SDL_AudioSpec spec;
spec.channels = 1;
spec.format = SDL_AUDIO_F32;
spec.freq = 8000;

SDL_AudioStream* stream = SDL_OpenAudioDeviceStream(
    SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK,  // デフォルト再生デバイス
    &spec,                               // 入力フォーマット
    nullptr,                             // コールバック（nullptrならストリーム方式）
    nullptr                              // ユーザーデータ
);

if (!stream) {
    SDL_Log("Failed to open audio device: %s", SDL_GetError());
    return false;
}

// デバイスは一時停止状態で開かれるため、明示的に再開
SDL_ResumeAudioStreamDevice(stream);
```

**特徴:**

- デバイスの開放、ストリームの作成、バインドを一度に実行
- シンプルで使いやすい
- 単一ストリームの使用に最適

#### 方法2: SDL_OpenAudioDevice + SDL_CreateAudioStream

複数のストリームを使用する場合の詳細なAPI。

```cpp
// デバイスを開く
SDL_AudioDeviceID device = SDL_OpenAudioDevice(
    SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK,
    nullptr  // nullptr = デフォルト設定
);

if (device == 0) {
    SDL_Log("Failed to open audio device: %s", SDL_GetError());
    return false;
}

// ストリームを作成
SDL_AudioSpec spec;
spec.channels = 1;
spec.format = SDL_AUDIO_F32;
spec.freq = 8000;

SDL_AudioStream* stream = SDL_CreateAudioStream(&spec, &spec);
if (!stream) {
    SDL_Log("Failed to create audio stream: %s", SDL_GetError());
    SDL_CloseAudioDevice(device);
    return false;
}

// ストリームをデバイスにバインド
SDL_BindAudioStream(device, stream);

// デバイスを再開
SDL_ResumeAudioDevice(device);
```

**特徴:**

- より柔軟な制御が可能
- 複数のストリームを同一デバイスにバインドできる
- 各ストリームを個別に管理可能

### 1.4 サンプルレート、チャンネル数、フォーマットの設定

#### サンプルレート（freq）

**一般的な値:**

- **8000 Hz**: 電話品質、低音質
- **22050 Hz**: ラジオ品質、中音質
- **44100 Hz**: CD品質、高音質（標準）
- **48000 Hz**: プロフェッショナル品質（DVDなど）

**シンセサイザーでの推奨:**

- サンプルコードでは8000Hzを使用（シンプルで計算が軽い）
- 実用的には44100Hzまたは48000Hzを推奨

#### チャンネル数（channels）

- **1**: モノラル（シンプル、メモリ節約）
- **2**: ステレオ（標準、空間表現）
- **6**: 5.1サラウンド
- **8**: 7.1サラウンド

**シンセサイザーでの推奨:**

- モノラル（1）: シンプルなサウンドエフェクト
- ステレオ（2）: 音楽や空間的なサウンド

#### フォーマット（format）

**SDL_AUDIO_F32の利点（推奨）:**

- 範囲: -1.0〜1.0
- 計算が簡単: `sample = amplitude * sin(phase)`
- クリッピングの検出が容易
- モダンなシステムで高速

**SDL_AUDIO_S16の利点:**

- 範囲: -32768〜32767
- メモリ効率が良い（F32の半分）
- 古いシステムとの互換性

### 1.5 コールバック方式とストリーム方式の違い

#### ストリーム方式（推奨）

**特徴:**

- メインループでデータを供給
- タイミングを自分で制御
- 実装がシンプル
- デバッグしやすい

**実装例:**

```cpp
// 初期化
SDL_AudioStream* stream = SDL_OpenAudioDeviceStream(
    SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK, &spec, nullptr, nullptr);
SDL_ResumeAudioStreamDevice(stream);

// メインループ
while (running) {
    // キューの残量を確認
    int queued = SDL_GetAudioStreamQueued(stream);
    if (queued < MIN_BUFFER_SIZE) {
        // データを生成
        float samples[512];
        generateSamples(samples, 512);

        // ストリームに供給
        SDL_PutAudioStreamData(stream, samples, sizeof(samples));
    }

    // その他の処理
}
```

#### コールバック方式

**特徴:**

- バックグラウンドスレッドから自動的に呼ばれる
- ハードウェアが必要とするタイミングで呼ばれる
- SDL2からの移行に適している
- リアルタイム性が高い

**実装例:**

```cpp
void AudioCallback(void* userdata, SDL_AudioStream* stream, int additional_amount, int total_amount) {
    // ハードウェアが必要とするサンプル数を生成
    if (additional_amount > 0) {
        float* samples = new float[additional_amount];
        generateSamples(samples, additional_amount);
        SDL_PutAudioStreamData(stream, samples, additional_amount * sizeof(float));
        delete[] samples;
    }
}

// 初期化
SDL_AudioStream* stream = SDL_OpenAudioDeviceStream(
    SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK, &spec, AudioCallback, userdata);
SDL_ResumeAudioStreamDevice(stream);
```

**注意点:**

- コールバック内で重い処理をしない（音切れの原因）
- スレッドセーフな実装が必要
- ロックやミューテックスの使用に注意

**比較表:**

| 項目 | ストリーム方式 | コールバック方式 |
|------|---------------|-----------------|
| データ供給 | 手動（メインループ） | 自動（バックグラウンドスレッド） |
| タイミング制御 | 自分で管理 | ハードウェアが制御 |
| 実装の難易度 | 簡単 | 中程度（スレッドセーフ必須） |
| デバッグ | 容易 | やや困難 |
| リアルタイム性 | 低 | 高 |
| SDL2からの移行 | 新しい設計が必要 | 既存コードを活用可能 |

**シンセサイザーでの推奨:**

- 初心者: **ストリーム方式**（デバッグしやすい）
- 上級者: **コールバック方式**（低レイテンシ）

---

## 2. オーディオサンプル生成

### 2.1 波形データの生成方法

#### 正弦波（Sine Wave）の生成

**数式:**

```
sample = amplitude × sin(2π × phase)
phase = (current_sample × frequency) / sample_rate
```

**実装例（SDL3公式サンプルより）:**

```cpp
const int freq = 440;  // 440Hz（ラ音）
const int sample_rate = 8000;
const float amplitude = 0.5f;

for (int i = 0; i < sample_count; i++) {
    float phase = current_sine_sample * freq / (float)sample_rate;
    samples[i] = amplitude * SDL_sinf(phase * 2.0f * SDL_PI_F);
    current_sine_sample++;
}

// オーバーフロー防止
if (current_sine_sample > sample_rate) {
    current_sine_sample %= sample_rate;
}
```

**ポイント:**

- `SDL_sinf()`: SDL提供のsin関数（float版）
- `SDL_PI_F`: SDL提供の円周率（float版、3.14159265f）
- `current_sine_sample`: サンプル位置を追跡（波形の連続性を保つ）
- モジュロ演算: 浮動小数点誤差の蓄積を防ぐ

#### 矩形波（Square Wave）の生成

```cpp
for (int i = 0; i < sample_count; i++) {
    float phase = current_sine_sample * freq / (float)sample_rate;
    float phase_mod = fmodf(phase, 1.0f);
    samples[i] = (phase_mod < 0.5f) ? amplitude : -amplitude;
    current_sine_sample++;
}
```

#### ノコギリ波（Sawtooth Wave）の生成

```cpp
for (int i = 0; i < sample_count; i++) {
    float phase = current_sine_sample * freq / (float)sample_rate;
    float phase_mod = fmodf(phase, 1.0f);
    samples[i] = amplitude * (2.0f * phase_mod - 1.0f);
    current_sine_sample++;
}
```

#### 三角波（Triangle Wave）の生成

```cpp
for (int i = 0; i < sample_count; i++) {
    float phase = current_sine_sample * freq / (float)sample_rate;
    float phase_mod = fmodf(phase, 1.0f);
    samples[i] = amplitude * (4.0f * fabsf(phase_mod - 0.5f) - 1.0f);
    current_sine_sample++;
}
```

### 2.2 サンプルフォーマット

#### float（SDL_AUDIO_F32）の場合

**範囲:** -1.0〜1.0

**特徴:**

- 計算が簡単（そのまま三角関数の結果を使える）
- クリッピング検出が容易（絶対値が1.0を超えたら警告）
- モダンなハードウェアで高速

**実装例:**

```cpp
float samples[512];
for (int i = 0; i < 512; i++) {
    samples[i] = 0.5f * SDL_sinf(phase * 2.0f * SDL_PI_F);
    // 範囲: -0.5〜0.5（振幅50%）
}

SDL_PutAudioStreamData(stream, samples, sizeof(samples));
```

#### int16（SDL_AUDIO_S16）の場合

**範囲:** -32768〜32767

**特徴:**

- メモリ効率が良い
- 古いシステムとの互換性
- 整数演算のみで実装可能

**実装例:**

```cpp
Sint16 samples[512];
for (int i = 0; i < 512; i++) {
    float value = 0.5f * SDL_sinf(phase * 2.0f * SDL_PI_F);
    samples[i] = (Sint16)(value * 32767.0f);
    // 範囲: -16383〜16383（振幅50%）
}

SDL_PutAudioStreamData(stream, samples, sizeof(samples));
```

**変換式:**

```cpp
// float → int16
Sint16 sample_i16 = (Sint16)(sample_f32 * 32767.0f);

// int16 → float
float sample_f32 = sample_i16 / 32768.0f;
```

### 2.3 バッファ管理

#### バッファサイズの決定

**考慮事項:**

- 小さすぎる: バッファアンダーラン（音切れ）
- 大きすぎる: レイテンシ増加、メモリ浪費

**推奨値:**

- **512サンプル**: 低レイテンシ（44100Hzで約11.6ms）
- **1024サンプル**: バランス（44100Hzで約23.2ms）
- **2048サンプル**: 安定性重視（44100Hzで約46.4ms）

**計算式:**

```
レイテンシ(ms) = (バッファサイズ / サンプルレート) × 1000
```

#### キューイング戦略

**ストリーム方式の場合:**

```cpp
// 最小バッファレベルを設定（例: 0.5秒）
const int min_buffer_ms = 500;
const int min_buffer_bytes = (sample_rate * channels * sizeof(float) * min_buffer_ms) / 1000;

// メインループ
while (running) {
    int queued = SDL_GetAudioStreamQueued(stream);

    if (queued < min_buffer_bytes) {
        // バッファが少なくなったらデータを追加
        float samples[512];
        generateSamples(samples, 512);
        SDL_PutAudioStreamData(stream, samples, sizeof(samples));
    }

    // フレーム処理
    SDL_Delay(16);  // 約60FPS
}
```

**ポイント:**

- `SDL_GetAudioStreamQueued()`: 現在キューにあるバイト数を取得
- 一定以下になったらデータを補充
- 適切な閾値で音切れを防ぐ

---

## 3. リアルタイム再生

### 3.1 SDL_PutAudioStreamData

**関数シグネチャ:**

```cpp
bool SDL_PutAudioStreamData(
    SDL_AudioStream* stream,  // ストリーム
    const void* buf,          // データバッファ
    int len                   // バイト数
);
```

**特徴:**

- データを無変換でキューイング（変換は再生時に行われる）
- スレッドセーフ（任意のスレッドから呼び出し可能）
- 失敗時はfalseを返す

**使用例:**

```cpp
float samples[512];
generateSineWave(samples, 512, 440.0f);

if (!SDL_PutAudioStreamData(stream, samples, sizeof(samples))) {
    SDL_Log("Failed to put audio data: %s", SDL_GetError());
}
```

### 3.2 SDL_GetAudioStreamQueued

**関数シグネチャ:**

```cpp
int SDL_GetAudioStreamQueued(SDL_AudioStream* stream);
```

**戻り値:** キューにあるバイト数（失敗時は-1）

**使用例:**

```cpp
int queued_bytes = SDL_GetAudioStreamQueued(stream);
int queued_samples = queued_bytes / sizeof(float);

SDL_Log("Queued: %d samples (%.2f seconds)",
        queued_samples,
        queued_samples / (float)sample_rate);
```

### 3.3 SDL_GetAudioStreamAvailable

**関数シグネチャ:**

```cpp
int SDL_GetAudioStreamAvailable(SDL_AudioStream* stream);
```

**戻り値:** 取り出し可能なバイト数

**使用例（録音時）:**

```cpp
int available = SDL_GetAudioStreamAvailable(stream);
if (available > 0) {
    float* samples = new float[available / sizeof(float)];
    int read = SDL_GetAudioStreamData(stream, samples, available);
    processSamples(samples, read / sizeof(float));
    delete[] samples;
}
```

### 3.4 バッファリングの考え方

#### 二重バッファリング

```cpp
const int buffer_size = 512;
float buffer_a[buffer_size];
float buffer_b[buffer_size];
bool use_buffer_a = true;

while (running) {
    int queued = SDL_GetAudioStreamQueued(stream);

    if (queued < MIN_BUFFER_SIZE) {
        // 空いているバッファに生成
        float* current_buffer = use_buffer_a ? buffer_a : buffer_b;
        generateSamples(current_buffer, buffer_size);
        SDL_PutAudioStreamData(stream, current_buffer, sizeof(float) * buffer_size);

        // バッファを切り替え
        use_buffer_a = !use_buffer_a;
    }
}
```

**利点:**

- 生成中に再生が続けられる
- メモリアロケーションを避ける
- 安定したパフォーマンス

---

## 4. 推奨される実装パターン

### 4.1 基本的なシンセサイザーの実装

```cpp
class SimpleSynthesizer {
 public:
  SimpleSynthesizer(int sample_rate = 44100)
      : sample_rate_(sample_rate), current_sample_(0) {
    // オーディオストリームを作成
    SDL_AudioSpec spec;
    spec.channels = 1;
    spec.format = SDL_AUDIO_F32;
    spec.freq = sample_rate_;

    stream_ = SDL_OpenAudioDeviceStream(
        SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK,
        &spec, nullptr, nullptr);

    if (stream_) {
      SDL_ResumeAudioStreamDevice(stream_);
    }
  }

  ~SimpleSynthesizer() {
    if (stream_) {
      SDL_DestroyAudioStream(stream_);
    }
  }

  void update() {
    // キューの残量を確認
    int queued = SDL_GetAudioStreamQueued(stream_);
    int min_buffer = (sample_rate_ * sizeof(float)) / 2;  // 0.5秒

    if (queued < min_buffer) {
      // サンプルを生成
      const int chunk_size = 512;
      float samples[chunk_size];
      generateSineWave(samples, chunk_size, 440.0f);

      // ストリームに送信
      SDL_PutAudioStreamData(stream_, samples, sizeof(samples));
    }
  }

 private:
  void generateSineWave(float* samples, int count, float frequency) {
    for (int i = 0; i < count; i++) {
      float phase = current_sample_ * frequency / (float)sample_rate_;
      samples[i] = 0.5f * SDL_sinf(phase * 2.0f * SDL_PI_F);
      current_sample_++;
    }

    // オーバーフロー防止
    if (current_sample_ > sample_rate_) {
      current_sample_ %= sample_rate_;
    }
  }

  SDL_AudioStream* stream_;
  int sample_rate_;
  int current_sample_;
};

// 使用例
int main() {
  SDL_Init(SDL_INIT_AUDIO);

  SimpleSynthesizer synth(44100);

  bool running = true;
  while (running) {
    synth.update();
    SDL_Delay(16);  // 約60FPS
  }

  SDL_Quit();
  return 0;
}
```

### 4.2 複数の音色を持つシンセサイザー

```cpp
enum class WaveType {
  Sine,
  Square,
  Sawtooth,
  Triangle
};

class MultiWaveSynthesizer {
 public:
  void setWaveType(WaveType type) { wave_type_ = type; }
  void setFrequency(float freq) { frequency_ = freq; }
  void setAmplitude(float amp) { amplitude_ = amp; }

  void generateSamples(float* samples, int count) {
    switch (wave_type_) {
      case WaveType::Sine:
        generateSine(samples, count);
        break;
      case WaveType::Square:
        generateSquare(samples, count);
        break;
      case WaveType::Sawtooth:
        generateSawtooth(samples, count);
        break;
      case WaveType::Triangle:
        generateTriangle(samples, count);
        break;
    }
  }

 private:
  void generateSine(float* samples, int count) {
    for (int i = 0; i < count; i++) {
      float phase = current_sample_ * frequency_ / (float)sample_rate_;
      samples[i] = amplitude_ * SDL_sinf(phase * 2.0f * SDL_PI_F);
      current_sample_++;
    }
  }

  void generateSquare(float* samples, int count) {
    for (int i = 0; i < count; i++) {
      float phase = current_sample_ * frequency_ / (float)sample_rate_;
      float phase_mod = fmodf(phase, 1.0f);
      samples[i] = (phase_mod < 0.5f) ? amplitude_ : -amplitude_;
      current_sample_++;
    }
  }

  void generateSawtooth(float* samples, int count) {
    for (int i = 0; i < count; i++) {
      float phase = current_sample_ * frequency_ / (float)sample_rate_;
      float phase_mod = fmodf(phase, 1.0f);
      samples[i] = amplitude_ * (2.0f * phase_mod - 1.0f);
      current_sample_++;
    }
  }

  void generateTriangle(float* samples, int count) {
    for (int i = 0; i < count; i++) {
      float phase = current_sample_ * frequency_ / (float)sample_rate_;
      float phase_mod = fmodf(phase, 1.0f);
      samples[i] = amplitude_ * (4.0f * fabsf(phase_mod - 0.5f) - 1.0f);
      current_sample_++;
    }
  }

  WaveType wave_type_ = WaveType::Sine;
  float frequency_ = 440.0f;
  float amplitude_ = 0.5f;
  int sample_rate_ = 44100;
  int current_sample_ = 0;
};
```

### 4.3 エンベロープ（ADSR）の実装

```cpp
class ADSREnvelope {
 public:
  struct Parameters {
    float attack_time;   // 秒
    float decay_time;    // 秒
    float sustain_level; // 0.0〜1.0
    float release_time;  // 秒
  };

  void noteOn() {
    state_ = State::Attack;
    time_ = 0.0f;
  }

  void noteOff() {
    state_ = State::Release;
    time_ = 0.0f;
  }

  float process(float delta_time) {
    time_ += delta_time;

    switch (state_) {
      case State::Attack:
        if (time_ < params_.attack_time) {
          return time_ / params_.attack_time;
        } else {
          state_ = State::Decay;
          time_ = 0.0f;
        }
        // フォールスルー

      case State::Decay:
        if (time_ < params_.decay_time) {
          float decay_amount = time_ / params_.decay_time;
          return 1.0f - (1.0f - params_.sustain_level) * decay_amount;
        } else {
          state_ = State::Sustain;
        }
        // フォールスルー

      case State::Sustain:
        return params_.sustain_level;

      case State::Release:
        if (time_ < params_.release_time) {
          return params_.sustain_level * (1.0f - time_ / params_.release_time);
        } else {
          state_ = State::Idle;
          return 0.0f;
        }

      case State::Idle:
        return 0.0f;
    }

    return 0.0f;
  }

 private:
  enum class State {
    Idle,
    Attack,
    Decay,
    Sustain,
    Release
  };

  Parameters params_ = {0.1f, 0.2f, 0.7f, 0.3f};
  State state_ = State::Idle;
  float time_ = 0.0f;
};
```

### 4.4 ベストプラクティス

#### 1. サンプル位置の管理

```cpp
// 悪い例: 浮動小数点誤差が蓄積
float phase = 0.0f;
for (int i = 0; i < count; i++) {
  samples[i] = SDL_sinf(phase * 2.0f * SDL_PI_F);
  phase += frequency / sample_rate;  // 誤差が蓄積
}

// 良い例: 整数カウンタを使用
int current_sample = 0;
for (int i = 0; i < count; i++) {
  float phase = current_sample * frequency / (float)sample_rate;
  samples[i] = SDL_sinf(phase * 2.0f * SDL_PI_F);
  current_sample++;
}
current_sample %= sample_rate;  // オーバーフロー防止
```

#### 2. クリッピング防止

```cpp
void generateSamples(float* samples, int count) {
  for (int i = 0; i < count; i++) {
    float value = calculateSample();

    // クリッピング検出と防止
    if (value > 1.0f) {
      SDL_Log("Clipping detected: %f", value);
      value = 1.0f;
    } else if (value < -1.0f) {
      SDL_Log("Clipping detected: %f", value);
      value = -1.0f;
    }

    samples[i] = value;
  }
}
```

#### 3. ゼロクロッシングでのフェード

音の開始・終了時にポップノイズを防ぐ:

```cpp
void applySmoothStart(float* samples, int count, int fade_samples) {
  for (int i = 0; i < SDL_min(count, fade_samples); i++) {
    float fade = (float)i / fade_samples;
    samples[i] *= fade;
  }
}

void applySmoothEnd(float* samples, int count, int fade_samples) {
  int start = SDL_max(0, count - fade_samples);
  for (int i = start; i < count; i++) {
    float fade = 1.0f - (float)(i - start) / fade_samples;
    samples[i] *= fade;
  }
}
```

#### 4. エラーハンドリング

```cpp
bool initAudio() {
  if (SDL_Init(SDL_INIT_AUDIO) < 0) {
    SDL_Log("Failed to initialize SDL: %s", SDL_GetError());
    return false;
  }

  SDL_AudioSpec spec;
  spec.channels = 1;
  spec.format = SDL_AUDIO_F32;
  spec.freq = 44100;

  stream_ = SDL_OpenAudioDeviceStream(
      SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK,
      &spec, nullptr, nullptr);

  if (!stream_) {
    SDL_Log("Failed to open audio device: %s", SDL_GetError());
    return false;
  }

  SDL_ResumeAudioStreamDevice(stream_);
  return true;
}
```

---

## 5. シンセサイザー実装のための基本設計案

### 5.1 クラス構造

```
AudioManager
├─ SDL_AudioStream* stream_
├─ SampleGenerator* generator_
└─ update()

SampleGenerator (抽象クラス)
├─ generateSamples(float* buffer, int count)
└─ virtual void generate() = 0

SimpleSineGenerator : SampleGenerator
├─ float frequency_
├─ float amplitude_
└─ int current_sample_

MultiOscillator : SampleGenerator
├─ Oscillator oscillators_[4]
├─ ADSREnvelope envelope_
└─ Mixer mixer_
```

### 5.2 初期化フロー

```cpp
// 1. SDL初期化
SDL_Init(SDL_INIT_AUDIO);

// 2. オーディオマネージャー作成
AudioManager audio_manager;
audio_manager.init(44100, 1, SDL_AUDIO_F32);

// 3. ジェネレータ設定
auto generator = std::make_unique<SimpleSineGenerator>();
generator->setFrequency(440.0f);
generator->setAmplitude(0.5f);
audio_manager.setGenerator(std::move(generator));

// 4. 再生開始
audio_manager.start();
```

### 5.3 更新フロー

```cpp
// メインループ
while (running) {
  // イベント処理
  SDL_Event event;
  while (SDL_PollEvent(&event)) {
    if (event.type == SDL_EVENT_KEY_DOWN) {
      if (event.key.scancode == SDL_SCANCODE_A) {
        // ラ音を再生
        generator->setFrequency(440.0f);
        envelope->noteOn();
      }
    }
  }

  // オーディオ更新
  audio_manager.update();

  // フレーム待機
  SDL_Delay(16);
}
```

### 5.4 終了処理

```cpp
// オーディオマネージャー停止
audio_manager.stop();

// SDL終了
SDL_Quit();
```

---

## 6. 参考リンク

### 公式ドキュメント

- SDL3 Audio API: https://wiki.libsdl.org/SDL3/CategoryAudio
- SDL_OpenAudioDevice: https://wiki.libsdl.org/SDL3/SDL_OpenAudioDevice
- SDL_AudioStream: https://wiki.libsdl.org/SDL3/SDL_AudioStream
- SDL_AudioFormat: https://wiki.libsdl.org/SDL3/SDL_AudioFormat
- SDL_AudioSpec: https://wiki.libsdl.org/SDL3/SDL_AudioSpec

### 公式サンプルコード

- simple-playback: https://examples.libsdl.org/SDL3/audio/01-simple-playback/
- simple-playback-callback: https://examples.libsdl.org/SDL3/audio/02-simple-playback-callback/
- load-wav: https://examples.libsdl.org/SDL3/audio/03-load-wav/
- GitHub: https://github.com/libsdl-org/SDL/tree/main/examples/audio

### 解説記事

- The SDL3 Audio Subsystem: https://www.patreon.com/posts/sdl3-audio-87089007
- SDL3 Official Release: https://www.phoronix.com/news/SDL3-Official-Release

---

## まとめ

SDL3のオーディオAPIは、SDL2から大きく進化しています:

### 主要な特徴

1. **SDL_AudioStreamが中心**: すべてのオーディオ処理がストリームを介して行われる
2. **柔軟なフォーマット変換**: 入出力フォーマットを自由に変換可能
3. **自動ミキシング**: 複数のストリームを自動的にミックス
4. **シンプルなAPI**: SDL_OpenAudioDeviceStreamで簡単に開始

### シンセサイザー実装の推奨事項

1. **フォーマット**: SDL_AUDIO_F32（計算が簡単）
2. **サンプルレート**: 44100Hz（標準品質）
3. **チャンネル**: 1（モノラル、シンプル）
4. **方式**: ストリーム方式（デバッグしやすい）
5. **バッファサイズ**: 512サンプル（低レイテンシとバランス）

### 次のステップ

1. SimpleSynthesizerクラスの実装
2. 複数の波形タイプの実装
3. ADSRエンベロープの追加
4. MIDIノート対応（周波数テーブル）
5. エフェクト（リバーブ、ディレイなど）

このドキュメントを基に、SDL3を使った本格的なシンセサイザーを実装できます。
