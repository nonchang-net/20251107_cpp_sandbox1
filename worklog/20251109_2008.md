# 作業レポート - 2025/11/09 20:08

## 変更内容の概要

- タイムスケール機能を実装しました。GameManagerクラスでタイムスケール値を管理し、SDL UserEventで変更を通知します。
- TestImpl3でTキー（1.0x ↔ 0.5x切り替え）とPキー（ポーズ/解除）によるタイムスケール操作を実装しました。
- デバッグテキストで現在のタイムスケールを表示し、オブジェクトの挙動がタイムスケールに即応するようにしました。

## 変更理由

- **ゲーム表現の拡張**: スローモーションやポーズなどの演出を実現するため、タイムスケールの概念が必要でした。
- **一元管理とイベント駆動設計**: GameManagerでタイムスケールを管理し、SDL UserEventで通知することで、複数のゲーム実装が同じ仕組みを使えるようにしました。
- **疎結合な設計**: TestImpl3とGameManagerの結合度を下げるため、カスタムイベント（EVENT_REQUEST_SET_TIMESCALE、EVENT_REQUEST_TOGGLE_PAUSE）を経由して通信する設計にしました。

## 技術的な実装詳細

### 1. game_constant.hにUserEventを定義

タイムスケール関連のイベントを定義しました。

**追加したイベント:**

```cpp
// タイムスケール関連のイベント
constexpr Uint32 EVENT_TIMESCALE_CHANGED = SDL_EVENT_USER + 0;  // タイムスケール変更イベント
constexpr Uint32 EVENT_PAUSE = SDL_EVENT_USER + 1;  // ポーズイベント
constexpr Uint32 EVENT_UNPAUSE = SDL_EVENT_USER + 2;  // アンポーズイベント

// タイムスケール変更要求イベント（ゲーム実装→game.cc）
constexpr Uint32 EVENT_REQUEST_SET_TIMESCALE = SDL_EVENT_USER + 10;  // タイムスケール設定要求
constexpr Uint32 EVENT_REQUEST_TOGGLE_PAUSE = SDL_EVENT_USER + 11;  // ポーズトグル要求
```

**イベントの役割:**

- `EVENT_TIMESCALE_CHANGED`: GameManagerからゲーム実装へ、タイムスケールが変更されたことを通知
- `EVENT_PAUSE` / `EVENT_UNPAUSE`: ポーズ/アンポーズ時に独立して発火（UI実装に備える）
- `EVENT_REQUEST_SET_TIMESCALE`: ゲーム実装からgame.ccへ、タイムスケール設定を要求
- `EVENT_REQUEST_TOGGLE_PAUSE`: ゲーム実装からgame.ccへ、ポーズトグルを要求

**イベント駆動設計の利点:**

- TestImpl3がGameManagerへの直接参照を持たなくて済む
- イベント経由で通信するため、疎結合な設計を維持
- 将来的にUI実装でポーズ状態を表示する際も、同じイベントを使える

### 2. GameManagerクラスにタイムスケール管理機能を追加

**追加したメンバ変数 (game_manager/game_manager.h):**

```cpp
// タイムスケール管理
float timescale_ = 1.0f;         // 現在のタイムスケール
float saved_timescale_ = 1.0f;   // ポーズ前のタイムスケールを保存
bool is_paused_ = false;          // ポーズ状態
```

**追加したメソッド:**

```cpp
/**
 * @brief 現在のタイムスケールを取得します
 * @return float タイムスケール値（1.0 = 100%, 0.5 = 50%, 0.0 = ポーズ）
 */
float getTimeScale() const;

/**
 * @brief タイムスケールを設定し、変更イベントを発火します
 * @param scale タイムスケール値（0.0以上）
 */
void setTimeScale(float scale);

/**
 * @brief ポーズ状態をトグルします
 *
 * ポーズ時：現在のタイムスケールを保存してタイムスケールを0に設定し、EVENT_PAUSEを発火
 * アンポーズ時：保存していたタイムスケールを復元し、EVENT_UNPAUSEを発火
 * いずれの場合もEVENT_TIMESCALE_CHANGEDも発火します
 */
void togglePause();

/**
 * @brief ポーズ状態を取得します
 * @return bool ポーズ中の場合true
 */
bool isPaused() const;
```

### 3. setTimeScale()の実装

```cpp
void setTimeScale(float scale) {
  if (scale < 0.0f) scale = 0.0f;

  timescale_ = scale;

  // タイムスケール変更イベントを発火
  SDL_Event event;
  SDL_zero(event);
  event.type = EVENT_TIMESCALE_CHANGED;
  event.user.data1 = this;
  event.user.code = static_cast<Sint32>(timescale_ * 100.0f);  // 整数化して渡す
  SDL_PushEvent(&event);
}
```

**処理の流れ:**

1. タイムスケール値を設定（0.0未満は0.0にクランプ）
2. EVENT_TIMESCALE_CHANGEDイベントを発火
3. event.user.codeにタイムスケール値を整数化して格納（100倍して整数化）

**整数化の理由:**

- SDL_Event::user.codeはSint32型
- floatをポインタで渡すのは危険（ライフタイム管理が複雑）
- 100倍して整数化することで、精度を保ちつつ安全に値を渡せる

### 4. togglePause()の実装

```cpp
void togglePause() {
  if (is_paused_) {
    // アンポーズ
    is_paused_ = false;
    timescale_ = saved_timescale_;

    // アンポーズイベントを発火
    SDL_Event event;
    SDL_zero(event);
    event.type = EVENT_UNPAUSE;
    event.user.data1 = this;
    SDL_PushEvent(&event);

    // タイムスケール変更イベントも発火
    SDL_zero(event);
    event.type = EVENT_TIMESCALE_CHANGED;
    event.user.data1 = this;
    event.user.code = static_cast<Sint32>(timescale_ * 100.0f);
    SDL_PushEvent(&event);
  } else {
    // ポーズ
    is_paused_ = true;
    saved_timescale_ = timescale_;
    timescale_ = 0.0f;

    // ポーズイベントを発火
    SDL_Event event;
    SDL_zero(event);
    event.type = EVENT_PAUSE;
    event.user.data1 = this;
    SDL_PushEvent(&event);

    // タイムスケール変更イベントも発火
    SDL_zero(event);
    event.type = EVENT_TIMESCALE_CHANGED;
    event.user.data1 = this;
    event.user.code = static_cast<Sint32>(timescale_ * 100.0f);
    SDL_PushEvent(&event);
  }
}
```

**処理の流れ:**

**ポーズ時:**
1. ポーズフラグを立てる
2. 現在のタイムスケールを保存
3. タイムスケールを0.0に設定
4. EVENT_PAUSEを発火
5. EVENT_TIMESCALE_CHANGEDを発火

**アンポーズ時:**
1. ポーズフラグを下ろす
2. 保存していたタイムスケールを復元
3. EVENT_UNPAUSEを発火
4. EVENT_TIMESCALE_CHANGEDを発火

**設計判断:**

- ポーズ/アンポーズ時に独立したイベントを発火することで、UI実装でポーズ状態を表示しやすくする
- タイムスケール変更イベントもセットで発火することで、タイムスケール表示が正しく更新される

### 5. TestImpl3にタイムスケール管理用のメンバ変数を追加

```cpp
// タイムスケール管理
float target_timescale_ = 1.0f;  // Tキーで切り替えるタイムスケール（1.0 or 0.5）
float current_timescale_ = 1.0f;  // 現在のタイムスケール（デバッグ表示用）
```

**変数の役割:**

- `target_timescale_`: Tキーで切り替えるタイムスケール値（1.0 ↔ 0.5）
- `current_timescale_`: EVENT_TIMESCALE_CHANGEDで更新される、現在のタイムスケール値（デバッグ表示用）

### 6. TestImpl3のhandleSdlEvent()にTキー・Pキーの処理を追加

**Tキーの処理:**

```cpp
case SDL_SCANCODE_T: {
  // Tキーでタイムスケールを切り替え（1.0 ↔ 0.5）
  target_timescale_ = (target_timescale_ == 1.0f) ? 0.5f : 1.0f;

  // タイムスケール設定要求イベントを発火
  SDL_Event request_event;
  SDL_zero(request_event);
  request_event.type = EVENT_REQUEST_SET_TIMESCALE;
  // floatをポインタで渡すのは危険なので、整数に変換（100倍して整数化）
  request_event.user.code = static_cast<Sint32>(target_timescale_ * 100.0f);
  SDL_PushEvent(&request_event);
  break;
}
```

**処理の流れ:**

1. target_timescale_を切り替え（1.0 → 0.5、0.5 → 1.0）
2. EVENT_REQUEST_SET_TIMESCALEイベントを発火
3. event.user.codeにタイムスケール値を整数化して格納

**Pキーの処理:**

```cpp
case SDL_SCANCODE_P: {
  // Pキーでポーズトグル
  SDL_Event request_event;
  SDL_zero(request_event);
  request_event.type = EVENT_REQUEST_TOGGLE_PAUSE;
  SDL_PushEvent(&request_event);
  break;
}
```

**処理の流れ:**

1. EVENT_REQUEST_TOGGLE_PAUSEイベントを発火
2. game.ccで処理され、GameManager::togglePause()が呼ばれる

### 7. TestImpl3のhandleSdlEvent()にEVENT_TIMESCALE_CHANGEDの処理を追加

```cpp
else if (event->type == EVENT_TIMESCALE_CHANGED) {
  // タイムスケール変更イベントを受け取る（デバッグ表示用に現在値を保存）
  // GameManagerから現在のタイムスケール値を取得する必要があるが、
  // ここではイベント経由で値を受け取る設計にする
  // event->user.codeに整数化された値が入っている想定
  current_timescale_ = static_cast<float>(event->user.code) / 100.0f;
}
```

**処理の流れ:**

1. EVENT_TIMESCALE_CHANGEDイベントを受け取る
2. event.user.codeから値を取得してfloatに変換（100で割る）
3. current_timescale_を更新

**即応性の確保:**

- SDL_AppEvent()でイベントが処理された後、SDL_AppIterate()が呼ばれる
- EVENT_TIMESCALE_CHANGEDは即座に処理されるため、current_timescale_は最新の値を保持
- デバッグテキストの更新は次のフレームで反映される

### 8. game.ccにタイムスケール変更要求イベントの処理を追加

**SDL_AppEvent()の修正:**

```cpp
SDL_AppResult SDL_AppEvent(void* appstate, SDL_Event* event) {
  AppState* as = (AppState*)appstate;

  switch (event->type) {
    case SDL_EVENT_QUIT:
      return SDL_APP_SUCCESS;
    case MyGame::EVENT_REQUEST_SET_TIMESCALE: {
      // タイムスケール設定要求を処理
      float timescale = static_cast<float>(event->user.code) / 100.0f;
      as->gameManager->setTimeScale(timescale);
      SDL_Log("Timescale set to %.2f", timescale);
      break;
    }
    case MyGame::EVENT_REQUEST_TOGGLE_PAUSE: {
      // ポーズトグル要求を処理
      as->gameManager->togglePause();
      SDL_Log("Pause toggled: %s", as->gameManager->isPaused() ? "PAUSED" : "RUNNING");
      break;
    }
    default:
      break;
  }

  return as->gameManager->handleSdlEvent(event);
}
```

**処理の流れ:**

1. EVENT_REQUEST_SET_TIMESCALEを受け取る
   - event.user.codeから値を取得してfloatに変換
   - GameManager::setTimeScale()を呼び出す
   - ログ出力

2. EVENT_REQUEST_TOGGLE_PAUSEを受け取る
   - GameManager::togglePause()を呼び出す
   - ポーズ状態をログ出力

3. その後、gameManager->handleSdlEvent()を呼び出してイベントをゲーム実装に委譲

### 9. デバッグテキストでタイムスケールを表示

**initializeEntities()に追加:**

```cpp
// タイムスケール表示（UI要素として左上にアンカー）
auto timescale_text = createTextEntity(
    10, 10, 45,
    [this]() {
      static char buffer[64];
      SDL_snprintf(buffer, sizeof(buffer), "TimeScale: %.2fx",
                   current_timescale_);
      return std::string(buffer);
    },
    SDL_Color{255, 255, 0, 255}, &top_left);
timescale_text->setStateFlag(toIndex(TestImpl3StateFlag::Visible), 1);
entity_manager_.addEntity(std::move(timescale_text));
```

**表示内容:**

- `TimeScale: 1.00x` - 通常速度
- `TimeScale: 0.50x` - 50%（スローモーション）
- `TimeScale: 0.00x` - 0%（ポーズ）

**UIアンカー:**

- UIAnchor::TopLeftを使用
- カメラの影響を受けずに左上に固定表示
- FPS表示の下に配置（y座標: 45）

### 10. オブジェクトの挙動をタイムスケールに対応させる

**update()の修正:**

```cpp
SDL_AppResult update() override {
  Uint64 current_time = SDL_GetTicks();
  Uint64 delta_time = current_time - last_time_;
  last_time_ = current_time;

  // FPS計測（タイムスケールの影響を受けない）
  fps_counter_.update();

  // タイムスケールを適用したdelta_timeを計算
  Uint64 scaled_delta_time = static_cast<Uint64>(delta_time * current_timescale_);

  // プレイヤー入力処理
  handlePlayerInput();

  // エンティティの更新（タイムスケールを適用）
  entity_manager_.updateAll(scaled_delta_time);

  // 定期的に新しいエンティティを追加（デモ、タイムスケールを適用）
  spawn_timer_ += scaled_delta_time;
  if (spawn_timer_ > 2000 && entity_manager_.getEntityCount() < 50) {
    spawnRandomEntity();
    spawn_timer_ = 0;
  }

  // 描画
  // ...
}
```

**処理の流れ:**

1. delta_timeを計算（実際の経過時間）
2. fps_counter_.update()を呼び出す（タイムスケールの影響を受けない）
3. delta_timeにcurrent_timescale_を掛けてscaled_delta_timeを計算
4. entity_manager_.updateAll(scaled_delta_time)でエンティティを更新
5. spawn_timer_にもscaled_delta_timeを加算

**タイムスケールの影響を受ける要素:**

- エンティティの移動（VelocityMove、AngularVelocity）
- エンティティのアニメーション（SpriteAnimator、Blink）
- エンティティのスポーン間隔（spawn_timer_）

**タイムスケールの影響を受けない要素:**

- FPS計測（fps_counter_）
- UI表示（デバッグテキスト、FPS表示）
- 入力処理（キーボード、ジョイスティック）

### 11. イベント駆動設計のフロー図

```
[ユーザーがTキーを押す]
        ↓
[TestImpl3::handleSdlEvent()]
  - target_timescale_を切り替え（1.0 ↔ 0.5）
  - EVENT_REQUEST_SET_TIMESCALEを発火
        ↓
[game.cc::SDL_AppEvent()]
  - EVENT_REQUEST_SET_TIMESCALEを受け取る
  - GameManager::setTimeScale()を呼び出す
        ↓
[GameManager::setTimeScale()]
  - timescale_を設定
  - EVENT_TIMESCALE_CHANGEDを発火
        ↓
[TestImpl3::handleSdlEvent()]
  - EVENT_TIMESCALE_CHANGEDを受け取る
  - current_timescale_を更新
        ↓
[TestImpl3::update()]
  - scaled_delta_time = delta_time * current_timescale_
  - entity_manager_.updateAll(scaled_delta_time)
        ↓
[エンティティの動きが変化]
  - タイムスケール1.0: 通常速度
  - タイムスケール0.5: 50%（スローモーション）
  - タイムスケール0.0: 0%（ポーズ）
```

### 12. ポーズ機能のフロー図

```
[ユーザーがPキーを押す]
        ↓
[TestImpl3::handleSdlEvent()]
  - EVENT_REQUEST_TOGGLE_PAUSEを発火
        ↓
[game.cc::SDL_AppEvent()]
  - EVENT_REQUEST_TOGGLE_PAUSEを受け取る
  - GameManager::togglePause()を呼び出す
        ↓
[GameManager::togglePause()]
  ポーズ時:
    - is_paused_ = true
    - saved_timescale_ = timescale_（現在値を保存）
    - timescale_ = 0.0
    - EVENT_PAUSEを発火
    - EVENT_TIMESCALE_CHANGEDを発火

  アンポーズ時:
    - is_paused_ = false
    - timescale_ = saved_timescale_（保存値を復元）
    - EVENT_UNPAUSEを発火
    - EVENT_TIMESCALE_CHANGEDを発火
        ↓
[TestImpl3::handleSdlEvent()]
  - EVENT_TIMESCALE_CHANGEDを受け取る
  - current_timescale_を更新
        ↓
[TestImpl3::update()]
  - scaled_delta_time = delta_time * current_timescale_
  - タイムスケール0.0のため、scaled_delta_time = 0
  - エンティティの動きが停止
```

## 設計思想

### 1. 疎結合な設計

**問題:**
- TestImpl3がGameManagerへの参照を持つと、循環依存が発生する
- テンプレートクラスのGameManagerへの依存は型の複雑さを増す

**解決策:**
- カスタムイベント（EVENT_REQUEST_*）を経由して通信
- TestImpl3はGameManagerを直接知らない
- game.ccがイベントを仲介する

**メリット:**
- 結合度が低い
- TestImpl3を他のプロジェクトに移植しやすい
- 将来的に他のゲーム実装でも同じ仕組みを使える

### 2. イベント駆動設計

**SDL UserEventの活用:**
- タイムスケール変更通知
- ポーズ/アンポーズ通知
- タイムスケール設定要求
- ポーズトグル要求

**メリット:**
- SDLのイベントループに自然に統合される
- 非同期的な通知が可能
- 複数のリスナーに通知できる（将来的にUI実装など）

### 3. タイムスケールの一元管理

**GameManagerでの管理:**
- タイムスケール値を1箇所で管理
- ポーズ状態を1箇所で管理
- イベント発火も1箇所で行う

**メリット:**
- 状態の一貫性が保たれる
- デバッグしやすい
- 将来的に他のゲーム実装でも同じ値を参照できる

### 4. UI要素はタイムスケールの影響を受けない

**FPS表示:**
- fps_counter_.update()はdelta_timeを使用（タイムスケールの影響を受けない）
- 実際のフレームレートを正確に表示

**タイムスケール表示:**
- current_timescale_をそのまま表示
- UIアンカーでカメラの影響を受けずに表示

**入力処理:**
- handlePlayerInput()はタイムスケールに関わらず毎フレーム呼ばれる
- プレイヤーはいつでもキー入力ができる

## ビルド結果

✅ ビルド成功
✅ タイムスケール機能実装完了
✅ Tキーでタイムスケール切り替え（1.0x ↔ 0.5x）
✅ Pキーでポーズ/解除
✅ デバッグテキストでタイムスケール表示
✅ オブジェクトの動きがタイムスケールに即応

## 動作確認

以下の操作を試してください：

1. **Tキーでスローモーション**
   - Tキーを1回押す → TimeScale: 0.50x表示、オブジェクトが50%の速度で動く
   - Tキーを再度押す → TimeScale: 1.00x表示、通常速度に戻る

2. **Pキーでポーズ**
   - Pキーを1回押す → TimeScale: 0.00x表示、すべてのオブジェクトが停止
   - Pキーを再度押す → 元のタイムスケールに戻る

3. **ポーズ中にTキーでタイムスケール変更**
   - Pキーでポーズ
   - Tキーでタイムスケール切り替え（次回アンポーズ時の速度が変わる）
   - Pキーでアンポーズ → 設定したタイムスケールで動き出す

4. **FPS表示はタイムスケールの影響を受けない**
   - タイムスケールを変更してもFPS表示は変わらない（60FPS付近を維持）

## まとめ

タイムスケール機能の実装により、以下が実現されました：

1. **ゲーム表現の拡張**: スローモーション、ポーズなどの演出が可能になった
2. **疎結合な設計**: イベント駆動設計により、TestImpl3とGameManagerの結合度を低く保った
3. **即応性**: タイムスケール変更が即座にオブジェクトの動きに反映される
4. **UI要素の独立性**: FPS表示などのUI要素はタイムスケールの影響を受けない

この機能は今後のゲーム開発で、戦闘演出やメニュー表示などに活用できます。

---

## 追加修正 - 2025/11/09 20:20

### 問題点の発見

初回実装後、以下の問題が発見されました：

1. **プレイヤーの移動速度がタイムスケールの影響を受けていない**
   - ポーズ中でもプレイヤーが操作できてしまう
2. **VelocityMoveコンポーネントがdelta_timeを無視している**
   - 速度が「ピクセル/フレーム」として実装されていた
   - 仕様では「ピクセル/秒」で定義する必要がある

### 根本原因

**VelocityMoveの実装:**

```cpp
// 修正前
inline void VelocityMove::update(Entity* entity, Uint64 delta_time) {
  if (auto* locator = entity->getComponent<Locator>()) {
    auto [x, y] = locator->getPosition();
    locator->setPosition(x + velocity_x_, y + velocity_y_);  // delta_timeを無視
  }
}
```

delta_timeを使わずに速度を直接加算していたため：
- タイムスケールが0でもdelta_time=0になるだけで、速度が設定されていれば移動してしまう
- 速度の単位が「ピクセル/フレーム」になっていた
- コメントには「ピクセル/秒」と書かれているが、実装が矛盾していた

**参考: AngularVelocityの正しい実装:**

```cpp
inline void AngularVelocity::update(Entity* entity, Uint64 delta_time) {
  if (auto* rotater = entity->getComponent<Rotater>()) {
    float angle = rotater->getAngle();
    // delta_timeをミリ秒→秒に変換して角速度を適用
    angle += angular_velocity_ * (delta_time / 1000.0f);  // 正しい実装
    rotater->setAngle(angle);
  }
}
```

### 修正内容

#### 1. VelocityMoveをdelta_timeベースに修正

**修正後 (entity_manager.h:743-752):**

```cpp
inline void VelocityMove::update(Entity* entity, Uint64 delta_time) {
  // Locatorコンポーネントを取得して座標を更新
  if (auto* locator = entity->getComponent<Locator>()) {
    auto [x, y] = locator->getPosition();
    // delta_timeをミリ秒→秒に変換して速度を適用
    // 速度の単位は「ピクセル/秒」
    float dt_sec = delta_time / 1000.0f;
    locator->setPosition(x + velocity_x_ * dt_sec, y + velocity_y_ * dt_sec);
  }
}
```

**効果:**
- delta_timeが0の場合、移動量も0になる（ポーズ時に停止）
- 速度の単位が「ピクセル/秒」になり、仕様と一致
- AngularVelocityと同じパターンで統一

#### 2. 速度の単位を「ピクセル/秒」に調整

速度が「ピクセル/フレーム」から「ピクセル/秒」に変わったため、60FPS想定で60倍に調整しました。

**プレイヤーの移動速度 (test_impl_3.h:276):**

```cpp
// 修正前
const float speed = 3.0f;  // ピクセル/フレーム

// 修正後
const float speed = 180.0f;  // 60FPSで3ピクセル/フレーム相当
```

計算式: `3.0 ピクセル/フレーム × 60 フレーム/秒 = 180 ピクセル/秒`

**動く四角形の速度 (test_impl_3.h:310, 319):**

```cpp
// 修正前
vel->setVelocity(2.0f, 1.5f);
vel->setVelocity(-1.5f, 2.0f);

// 修正後
vel->setVelocity(120.0f, 90.0f);   // 60FPSで2.0, 1.5ピクセル/フレーム相当
vel->setVelocity(-90.0f, 120.0f);  // 60FPSで-1.5, 2.0ピクセル/フレーム相当
```

**ランダムエンティティの速度 (test_impl_3.h:468-469):**

```cpp
// 修正前
vel->setVelocity((SDL_randf() - 0.5f) * 4.0f,
                 (SDL_randf() - 0.5f) * 4.0f);

// 修正後
vel->setVelocity((SDL_randf() - 0.5f) * 240.0f,
                 (SDL_randf() - 0.5f) * 240.0f);  // 60FPSで±2ピクセル/フレーム相当
```

#### 3. プレイヤーの移動処理をポーズ中に無効化

**handlePlayerInput()の修正 (test_impl_3.h:266-270):**

```cpp
// ポーズ中は入力を無効化
if (current_timescale_ == 0.0f) {
  velocity->setVelocity(0.0f, 0.0f);
  return;
}
```

**処理の流れ:**
1. current_timescale_が0.0（ポーズ中）の場合
2. プレイヤーの速度を(0, 0)に設定
3. 入力処理をスキップ

**効果:**
- ポーズ中はプレイヤーが操作できない
- VelocityMoveがdelta_time=0で呼ばれるため、座標も更新されない

### 動作確認

**期待される動作:**

1. **通常時（タイムスケール1.0x）:**
   - すべてのオブジェクトが通常速度で動く
   - プレイヤーの操作が可能

2. **スローモーション（タイムスケール0.5x）:**
   - すべてのオブジェクトが50%の速度で動く
   - プレイヤーの移動も50%の速度

3. **ポーズ（タイムスケール0.0x）:**
   - すべてのオブジェクトが完全に停止
   - プレイヤーの操作が無効化される

4. **FPS表示:**
   - タイムスケールに関わらず60FPS付近を維持
   - UI要素は常に正常に動作

### 技術的なポイント

#### 速度の単位統一の重要性

**「ピクセル/フレーム」の問題点:**
- フレームレートに依存する（30FPSと60FPSで動きが変わる）
- タイムスケールの影響を受けにくい
- 直感的でない（1秒で何ピクセル動くか分からない）

**「ピクセル/秒」の利点:**
- フレームレートに依存しない（delta_timeで補正）
- タイムスケールの影響を自然に受ける（delta_time × timescale）
- 直感的（「180ピクセル/秒」= 1秒で180ピクセル移動）

#### delta_timeの正しい使い方

```cpp
// 間違った実装（フレームレート依存）
position += velocity;

// 正しい実装（フレームレート非依存）
position += velocity * (delta_time / 1000.0f);
```

60FPSの場合: `delta_time ≈ 16.67ms → dt_sec ≈ 0.01667秒`
- `velocity = 180 ピクセル/秒`
- `移動量 = 180 × 0.01667 ≈ 3.0 ピクセル/フレーム`

30FPSの場合: `delta_time ≈ 33.33ms → dt_sec ≈ 0.03333秒`
- `velocity = 180 ピクセル/秒`
- `移動量 = 180 × 0.03333 ≈ 6.0 ピクセル/フレーム`

**結果:** 同じ速度設定（180ピクセル/秒）でも、フレームレートに応じて適切な移動量が自動計算される

### まとめ

VelocityMoveの実装をdelta_timeベースに修正し、速度の単位を「ピクセル/秒」に統一することで：

1. **タイムスケールへの即応性**: delta_time=0の場合、移動量も0になる
2. **フレームレート非依存**: 30FPSでも60FPSでも同じ速度で動く
3. **仕様との一致**: コメントと実装が一致し、保守性が向上
4. **ポーズ機能の完成**: プレイヤー操作も含めてすべてが停止

これにより、タイムスケール機能が完全に動作するようになりました。
