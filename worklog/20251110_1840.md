# 20251110_1840 - SDL_AddTimerNSへの移行による高精度タイミング実装

## 変更内容の概要

- SDL_AddTimerからSDL_AddTimerNSに移行し、ナノ秒単位の高精度タイミングを実現
- デフォルト値は15ms (15,000,000ns) を維持
- setUpdateInterval()のミリ秒版とsetUpdateIntervalNS()のナノ秒版の両方を提供
- MultiTrackSequencerにも同様の変更を適用

## 変更理由

SDL_AddTimerは最小精度が約1ms（実際にはシステムタイマーに依存）であり、一部の速い曲や細かいリズム表現において精度不足が発覚した。SDL_AddTimerNSに移行することで、ナノ秒単位の精度指定が可能になり、より正確なタイミングで音符を進行できるようになった。

## 変更箇所

### game_manager/sound_synthesizer.h

#### 1. Sequencerクラスのメンバー変数

**変更前**:
```cpp
SDL_TimerID timer_id_;
Uint32 update_interval_ms_;  // 更新間隔（ミリ秒）
```

**変更後**:
```cpp
SDL_TimerID timer_id_;
Uint64 update_interval_ns_;  // 更新間隔（ナノ秒）
```

#### 2. コンストラクタの初期化

**変更前**:
```cpp
Sequencer(SimpleSynthesizer* synthesizer, float bpm = 120.0f)
    : /* ... */, timer_id_(0), update_interval_ms_(15) {
  // デフォルト: 32分音符相当の精度（15ms間隔）
}
```

**変更後**:
```cpp
Sequencer(SimpleSynthesizer* synthesizer, float bpm = 120.0f)
    : /* ... */, timer_id_(0), update_interval_ns_(15000000) {
  // デフォルト: 32分音符相当の精度（15ms = 15,000,000ns間隔）
}
```

#### 3. 更新間隔設定メソッドの追加

**ナノ秒版（新規追加）**:
```cpp
/**
 * @brief シーケンサーの更新間隔を設定（ナノ秒）
 * @param interval_ns 更新間隔（ナノ秒）、小さいほど精度が高い
 */
void setUpdateIntervalNS(Uint64 interval_ns) {
  update_interval_ns_ = interval_ns;
}

/**
 * @brief シーケンサーの更新間隔を取得（ナノ秒）
 * @return 更新間隔（ナノ秒）
 */
Uint64 getUpdateIntervalNS() const {
  return update_interval_ns_;
}
```

**ミリ秒版（互換性維持のため変更）**:
```cpp
/**
 * @brief シーケンサーの更新間隔を設定（ミリ秒、利便性のため）
 * @param interval_ms 更新間隔（ミリ秒）
 */
void setUpdateInterval(Uint32 interval_ms) {
  update_interval_ns_ = static_cast<Uint64>(interval_ms) * 1000000;  // ms to ns
}

/**
 * @brief シーケンサーの更新間隔を取得（ミリ秒）
 * @return 更新間隔（ミリ秒）
 */
Uint32 getUpdateInterval() const {
  return static_cast<Uint32>(update_interval_ns_ / 1000000);  // ns to ms
}
```

#### 4. タイマーコールバックのシグネチャ変更

**変更前（SDL2/SDL3 SDL_AddTimer用）**:
```cpp
static Uint32 SDLCALL timerCallback(void* userdata, SDL_TimerID timerID, Uint32 interval) {
  Sequencer* sequencer = static_cast<Sequencer*>(userdata);
  if (sequencer) {
    sequencer->internalUpdate();
  }
  return interval;  // 同じ間隔で継続
}
```

**変更後（SDL3 SDL_AddTimerNS用）**:
```cpp
/**
 * @brief タイマーコールバック（静的関数、SDL_AddTimerNS用）
 * @param userdata Sequencerインスタンスへのポインタ
 * @param timerID タイマーID
 * @param interval タイマー間隔（ナノ秒）
 * @return 次のタイマー間隔（0で停止）
 */
static Uint64 SDLCALL timerCallback(void* userdata, SDL_TimerID timerID, Uint64 interval) {
  Sequencer* sequencer = static_cast<Sequencer*>(userdata);
  if (sequencer) {
    sequencer->internalUpdate();
  }
  return interval;  // 同じ間隔で継続
}
```

#### 5. タイマー開始メソッド

**変更前**:
```cpp
void startTimer() {
  if (timer_id_ != 0) {
    stopTimer();  // 既存のタイマーを停止
  }
  timer_id_ = SDL_AddTimer(update_interval_ms_, timerCallback, this);
  if (timer_id_ == 0) {
    SDL_LogError(SDL_LOG_CATEGORY_AUDIO, "Failed to create timer: %s", SDL_GetError());
  }
}
```

**変更後**:
```cpp
void startTimer() {
  if (timer_id_ != 0) {
    stopTimer();  // 既存のタイマーを停止
  }
  timer_id_ = SDL_AddTimerNS(update_interval_ns_, timerCallback, this);
  if (timer_id_ == 0) {
    SDL_LogError(SDL_LOG_CATEGORY_AUDIO, "Failed to create timer: %s", SDL_GetError());
  }
}
```

#### 6. MultiTrackSequencerクラス

**ナノ秒版（新規追加）**:
```cpp
/**
 * @brief シーケンサーの更新間隔を設定（ナノ秒）
 * @param interval_ns 更新間隔（ナノ秒）、小さいほど精度が高い
 */
void setUpdateIntervalNS(Uint64 interval_ns) {
  for (auto& seq : sequencers_) {
    seq->setUpdateIntervalNS(interval_ns);
  }
}
```

**ミリ秒版（既存、内部でns変換を使用）**:
```cpp
/**
 * @brief シーケンサーの更新間隔を設定（ミリ秒、利便性のため）
 * @param interval_ms 更新間隔（ミリ秒）
 */
void setUpdateInterval(Uint32 interval_ms) {
  for (auto& seq : sequencers_) {
    seq->setUpdateInterval(interval_ms);
  }
}
```

## SDL_AddTimerとSDL_AddTimerNSの比較

| 項目 | SDL_AddTimer | SDL_AddTimerNS |
|------|-------------|----------------|
| **精度** | ミリ秒 (Uint32) | ナノ秒 (Uint64) |
| **最小間隔** | 約1ms（システム依存） | 理論上1ns（実際はシステム依存） |
| **コールバックシグネチャ** | `Uint32 callback(void*, SDL_TimerID, Uint32)` | `Uint64 callback(void*, SDL_TimerID, Uint64)` |
| **最大間隔** | 約49日 (2^32ms) | 約584年 (2^64ns) |
| **用途** | 一般的なタイミング | 高精度タイミング |

## 精度の改善

### 理論上の精度

- **SDL_AddTimer**: 1ms単位（1,000,000ns）
- **SDL_AddTimerNS**: 1ns単位

### 実際の精度

システムのタイマー解像度に依存するが、多くの環境で：
- **Windows**: 約1ms～15ms（タイマー解像度に依存）
- **macOS**: 約100μs～1ms（高精度）
- **Linux**: 約1μs～1ms（CONFIG_HZに依存）

SDL_AddTimerNSを使うことで、システムが許す最高精度を引き出せる。

## 使用例

### デフォルト（15ms = 32分音符精度）

```cpp
auto sequencer = std::make_unique<Sequencer>(synthesizer.get(), 120.0f);
// デフォルトで15ms (15,000,000ns) 間隔
sequencer->play();
```

### ミリ秒指定（利便性重視）

```cpp
// 10ms間隔に設定（64分音符精度）
sequencer->setUpdateInterval(10);  // ms単位

// 5ms間隔に設定（128分音符精度）
sequencer->setUpdateInterval(5);   // ms単位
```

### ナノ秒指定（超高精度）

```cpp
// 1ms間隔 = 1,000,000ns
sequencer->setUpdateIntervalNS(1000000);  // ns単位

// 500μs間隔 = 500,000ns
sequencer->setUpdateIntervalNS(500000);   // ns単位

// 100μs間隔 = 100,000ns（システムが許す限り）
sequencer->setUpdateIntervalNS(100000);   // ns単位
```

### MultiTrackSequencerでの使用

```cpp
auto bgm = std::make_unique<MultiTrackSequencer>(3, 44100, 160.0f);

// 全トラックに1ms間隔を設定（超高精度）
bgm->setUpdateInterval(1);  // ms単位

// または直接ナノ秒指定
bgm->setUpdateIntervalNS(1000000);  // 1ms = 1,000,000ns
```

## 推奨設定

| 用途 | 推奨間隔（ms） | ナノ秒 | 対応音符（120BPM） |
|------|--------------|--------|------------------|
| 一般的なBGM | 15ms | 15,000,000ns | 32分音符 (62.5ms) |
| リズミカルなBGM | 10ms | 10,000,000ns | 64分音符 (31.25ms) |
| 超高速曲 | 5ms | 5,000,000ns | 128分音符 (15.6ms) |
| 最高精度 | 1ms | 1,000,000ns | 256分音符 (7.8ms) |
| 実験的 | 0.5ms | 500,000ns | 512分音符 (3.9ms) |

**注意**: 間隔を小さくしすぎると、CPU負荷が増加する可能性があります。多くの場合、5ms～15msで十分です。

## パフォーマンスへの影響

### CPU負荷

- **15ms間隔**: 1秒あたり約67回の呼び出し → 軽微な負荷
- **10ms間隔**: 1秒あたり約100回の呼び出し → 軽微な負荷
- **5ms間隔**: 1秒あたり約200回の呼び出し → 中程度の負荷
- **1ms間隔**: 1秒あたり約1000回の呼び出し → 高負荷

### メモリ

変更前後でメモリ使用量に差はありません（Uint32 → Uint64で4バイト増加のみ）。

### 精度

システムのタイマー解像度に依存しますが、SDL_AddTimerNSを使うことで、システムが提供する最高精度を引き出せます。

## 互換性

### 既存コードへの影響

**ミリ秒指定の既存コード（互換性維持）**:
```cpp
sequencer->setUpdateInterval(15);  // 15ms
// 内部で自動的に15,000,000nsに変換される
```

**新しいナノ秒指定コード**:
```cpp
sequencer->setUpdateIntervalNS(15000000);  // 15ms = 15,000,000ns
```

どちらも使用可能です。ミリ秒単位で十分な場合は従来通り`setUpdateInterval()`を、より細かい制御が必要な場合は`setUpdateIntervalNS()`を使用してください。

## テスト方法

1. ビルドして実行: `cmake --build build && ./build/main`
2. **1-3キー**: BGM1-3を再生
3. BGM3は高速な16分音符が多く含まれているため、精度の違いが最も分かりやすい
4. 従来のSDL_AddTimer (15ms) では若干のジッターが感じられる可能性がある
5. SDL_AddTimerNS (15ms = 15,000,000ns) では、システムが許す限りジッターが減少する

## SDL3の仕様

### SDL_AddTimerNSのシグネチャ

```c
SDL_TimerID SDL_AddTimerNS(Uint64 interval, SDL_NSTimerCallback callback, void *userdata);
```

### コールバックのシグネチャ

```c
typedef Uint64 (SDLCALL *SDL_NSTimerCallback)(void *userdata, SDL_TimerID timerID, Uint64 interval);
```

**引数**:
- `userdata`: ユーザーデータ（Sequencerインスタンスへのポインタ）
- `timerID`: タイマーID
- `interval`: タイマー間隔（ナノ秒）

**戻り値**:
- 次のタイマー間隔（ナノ秒）
- 0を返すとタイマーが停止する

## 今後の拡張可能性

- 動的な精度調整（負荷に応じて自動的に間隔を調整）
- タイミング統計情報の収集（ジッター測定、最大/最小/平均間隔など）
- タイマー精度のベンチマークツール
- システムタイマー解像度の取得と表示
